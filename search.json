[{"title":"Bitcpy","url":"/2021/06/24/Bitcpy/","content":"<blockquote>\r\n<p><strong>两种bitcpy的实现方式</strong></p>\r\n</blockquote>\r\n<h3 id=\"显示数据bits\">1. 显示数据bits</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HALF_WORD   uint16_t</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WORD        uint32_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showBits</span><span class=\"params\">(<span class=\"type\">void</span>* d, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> bytes = len / <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* p = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)d;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; bytes; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">char</span> tmp = <span class=\"number\">0x80</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tmp &amp; *p)</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">            tmp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        ++p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"bitcpy-算术方式\">2. bitcpy 算术方式</h3>\r\n<p><strong>拷贝方式是从单个字节的低位开始拷贝，进位式拷贝。</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitcopy</span><span class=\"params\">(<span class=\"type\">void</span>* to, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> tOfs, <span class=\"type\">int</span> tCnt, <span class=\"type\">const</span> <span class=\"type\">void</span>* from, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> fOfs, <span class=\"type\">int</span> fCnt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> BitsOfHalfWord = <span class=\"built_in\">sizeof</span>(HALF_WORD) * <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">// align data and offset to HALF_WORD</span></span><br><span class=\"line\">    to = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)to + (tOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">    from = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)from + (fOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">    fOfs %= BitsOfHalfWord;</span><br><span class=\"line\">    tOfs %= BitsOfHalfWord;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> NbrOfCopiedBits = <span class=\"number\">0</span>, bCnt = (fCnt &lt; tCnt) ? fCnt : tCnt;</span><br><span class=\"line\">    WORD rMask, wMask;</span><br><span class=\"line\">    WORD temp, * _to = (WORD*)to, * _from = (WORD*)from;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bCnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// update counter</span></span><br><span class=\"line\">        <span class=\"type\">int</span> BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;</span><br><span class=\"line\">        bCnt -= BitsToCopy;</span><br><span class=\"line\">        NbrOfCopiedBits += BitsToCopy;</span><br><span class=\"line\">        <span class=\"comment\">// mask reading from &#x27;_from&#x27; and mask writing to &#x27;_to&#x27;</span></span><br><span class=\"line\">        rMask = (((WORD)<span class=\"number\">-1</span>) &lt;&lt; fOfs) ^ (((WORD)<span class=\"number\">-1</span>) &lt;&lt; (fOfs + BitsToCopy));</span><br><span class=\"line\">        wMask = (((WORD)<span class=\"number\">-1</span>) &lt;&lt; tOfs) ^ (((WORD)<span class=\"number\">-1</span>) &lt;&lt; (tOfs + BitsToCopy));</span><br><span class=\"line\">        <span class=\"built_in\">showBits</span>(&amp;rMask, <span class=\"number\">32</span>);</span><br><span class=\"line\">        <span class=\"built_in\">showBits</span>(&amp;wMask, <span class=\"number\">32</span>);</span><br><span class=\"line\">        temp = (*_from &amp; rMask) &gt;&gt; fOfs &lt;&lt; tOfs;</span><br><span class=\"line\">        *_to &amp;= ~wMask;</span><br><span class=\"line\">        *_to |= temp;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d bit(s) copied\\n&quot;</span>, BitsToCopy);</span><br><span class=\"line\">        <span class=\"comment\">// increase data pointer if copy is not completed</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BitsToCopy == BitsOfHalfWord) &#123;</span><br><span class=\"line\">            _to = (WORD*)((<span class=\"type\">intptr_t</span>)_to + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">            _from = (WORD*)((<span class=\"type\">intptr_t</span>)_from + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">showBits</span>(to, <span class=\"number\">64</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NbrOfCopiedBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"bitcpy-物理方式\">3. bitcpy 物理方式</h3>\r\n<p><strong>物理左移</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">WORD <span class=\"title\">shiftLeft</span><span class=\"params\">(WORD w, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* s = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)&amp;w;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (len--) &#123;</span><br><span class=\"line\">        *(s) &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*(s + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*(s + i) &amp; <span class=\"number\">0x80</span>)</span><br><span class=\"line\">                *(s + i - <span class=\"number\">1</span>) |= <span class=\"number\">1</span>;</span><br><span class=\"line\">            *(s + i) &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>物理右移</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">WORD <span class=\"title\">shiftRight</span><span class=\"params\">(WORD w, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* s = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)&amp;w;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (len--) &#123;</span><br><span class=\"line\">        *(s+<span class=\"number\">3</span>) &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*(s + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*(s + i) &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">                *(s + i + <span class=\"number\">1</span>) |= <span class=\"number\">0x80</span>;</span><br><span class=\"line\">            *(s + i) &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>拷贝方式是按照实际的物理bit位进行顺序拷贝的</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitcpy</span><span class=\"params\">(<span class=\"type\">void</span>* to, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> tOfs, <span class=\"type\">const</span> <span class=\"type\">void</span>* from, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> fOfs, <span class=\"type\">int</span> bCnt)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> BitsOfHalfWord = <span class=\"built_in\">sizeof</span>(HALF_WORD) * <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 将数据和偏置对其“半字”</span></span><br><span class=\"line\">    <span class=\"comment\">// 指针视为intptr_t，加1则前进一个Byte，且更安全（适用于将指针进行算术运算时使用）</span></span><br><span class=\"line\">    to = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)to + (tOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">    from = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)from + (fOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">    fOfs %= BitsOfHalfWord;</span><br><span class=\"line\">    tOfs %= BitsOfHalfWord;</span><br><span class=\"line\">    <span class=\"type\">int</span> NbrOfCopiedBits = <span class=\"number\">0</span>;</span><br><span class=\"line\">    WORD rMask, wMask;</span><br><span class=\"line\">    WORD temp;</span><br><span class=\"line\">    WORD *_to = (WORD*)to;</span><br><span class=\"line\">    WORD *_from = (WORD*)from;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (bCnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 更新</span></span><br><span class=\"line\">        <span class=\"type\">int</span> BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;</span><br><span class=\"line\">        bCnt -= BitsToCopy;</span><br><span class=\"line\">        NbrOfCopiedBits += BitsToCopy;</span><br><span class=\"line\">        <span class=\"comment\">// 源与目标的遮罩</span></span><br><span class=\"line\">        rMask = <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, fOfs) ^ <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, fOfs + BitsToCopy);</span><br><span class=\"line\">        wMask = <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, tOfs) ^ <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, tOfs + BitsToCopy);</span><br><span class=\"line\">        temp = (*_from &amp; rMask);</span><br><span class=\"line\">        temp = <span class=\"built_in\">shiftLeft</span>(temp, fOfs);</span><br><span class=\"line\">        temp = <span class=\"built_in\">shiftRight</span>(temp, tOfs);</span><br><span class=\"line\">        *_to &amp;= ~wMask;    <span class=\"comment\">// 先清理此部分</span></span><br><span class=\"line\">        *_to |= temp;    <span class=\"comment\">// 在“拷贝”进来</span></span><br><span class=\"line\">        <span class=\"comment\">// 拷贝未完成情况下，跟进指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (BitsToCopy == BitsOfHalfWord) &#123;</span><br><span class=\"line\">            _to = (WORD*)((<span class=\"type\">intptr_t</span>)_to + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">            _from = (WORD*)((<span class=\"type\">intptr_t</span>)_from + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> NbrOfCopiedBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C/C++"]},{"title":"C++ priority_queue自定义排序","url":"/2021/10/31/C-priority-queue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","content":"<blockquote>\r\n<p><strong>C++ priority_queue自定义排序总结</strong></p>\r\n</blockquote>\r\n<h3 id=\"方法一函数指针\">方法一：函数指针</h3>\r\n<p>以下几种都可以，具体可参考《C++ Primer》</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> elem;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(elem a, elem b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &lt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, <span class=\"keyword\">decltype</span>(&amp;cmp)&gt; <span class=\"built_in\">q</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, <span class=\"keyword\">decltype</span>(cmp)*&gt; <span class=\"built_in\">q</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, <span class=\"type\">bool</span>(*)(elem, elem)&gt; <span class=\"built_in\">q</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\"><span class=\"comment\">// 构造函数前两个可以不填，但是必须传入cmp</span></span><br><span class=\"line\"><span class=\"comment\">// 前面模板只是告诉它是一个函数指针bool(*)(elem, elem)，但并没有传入函数地址（实体）</span></span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, <span class=\"type\">bool</span>(*)(elem, elem)&gt; <span class=\"built_in\">q</span>(cmp);</span><br></pre></td></tr></table></figure>\r\n<p>**对于cmp和&amp;cmp你应该这样理解，cmp是函数的首地址，它的类型是bool(elem, elem)，&amp;cmp表示一个指向函数cmp这个对象的地址，它的类型是bool(*)(elem, elem)，因此test和&amp;test所代表的地址的值是一样的，但类型不一样！**</p>\r\n<h3 id=\"方法二重载运算符\">方法二：重载运算符</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elem</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> elem&amp; another) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;b &lt; another.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, less&lt;elem&gt;&gt; q;</span><br></pre></td></tr></table></figure>\r\n<p>注意：operator函数要有const，这是能构成重载的，否则未找到对应函数报错</p>\r\n<h3 id=\"方法三仿函数\">方法三：仿函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">elem</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"type\">int</span> b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cmp</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> elem&amp; left, <span class=\"type\">const</span> elem&amp; right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left.b &lt; right.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, cmp&gt; q;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, cmp&gt; <span class=\"built_in\">q</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 不需要传入cmp参数</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"方法四匿名函数类似仿函数\">方法四：匿名函数（类似仿函数）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> cmp = [](<span class=\"type\">const</span> item&amp; a, <span class=\"type\">const</span> item&amp; b) &#123;<span class=\"keyword\">return</span> a.first &lt; b.first; &#125;; <span class=\"comment\">// 实例</span></span><br><span class=\"line\">priority_queue&lt;item, vector&lt;item&gt;, <span class=\"keyword\">decltype</span>(cmp)&gt; <span class=\"built_in\">pq</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>(), cmp); <span class=\"comment\">// decltype解析类型，并需要传入实例</span></span><br></pre></td></tr></table></figure>\r\n","tags":["C/C++"]},{"title":"CPP线程使用","url":"/2022/05/01/CPP%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8/","content":"<h2 id=\"函数介绍\">函数介绍</h2>\r\n<ul>\r\n<li><code>lock_guard</code>：锁定互斥锁后，生命周期结束后会自动释放，不需要手动解锁，也无法手动解锁</li>\r\n<li><code>unique_lock</code>：多数情况与上面一个可以相互替代，但是其更具功能性（付出一些代价）。<code>unique_lock</code>可以进行unlock操作，因此可以和条件变量搭配使用</li>\r\n</ul>\r\n<h2 id=\"多线程输出数字\">多线程输出数字</h2>\r\n<p>多个线程互斥输出: <code>0 1 2 3 4 5 6 ...</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">mutex _mutex;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (idx &lt; n) &#123; <span class=\"comment\">// 改成true一样的</span></span><br><span class=\"line\">        <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">tmp</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= n) <span class=\"keyword\">break</span>; <span class=\"comment\">// 必须，否则多输出几个数才停</span></span><br><span class=\"line\">        cout &lt;&lt; idx++ &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;thread&gt; arr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        arr.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">thread</span>(func, <span class=\"number\">1000</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr)</span><br><span class=\"line\">        e.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 版本2 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">mutex _mutex;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (idx &lt; n) &#123;</span><br><span class=\"line\">        <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">tmp</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &gt;= n) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        cout &lt;&lt; idx++ &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;thread&gt; arr;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> t = <span class=\"built_in\">thread</span>(func, <span class=\"number\">1000</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 不需要join了</span></span><br><span class=\"line\">        t.<span class=\"built_in\">detach</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 这里不能传入左值，会报错“尝试引用已删除的函数”</span></span><br><span class=\"line\">        <span class=\"comment\">// 或者通过vector存放thread的指针的方式</span></span><br><span class=\"line\">        arr.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">move</span>(t));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟其他操作，虽然detach后不需要join但是主线程结束后</span></span><br><span class=\"line\">    <span class=\"comment\">// 子线程也会直接结束</span></span><br><span class=\"line\">    <span class=\"built_in\">Sleep</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"多线程输出abc\">多线程输出ABC</h2>\r\n<p>多个线程互斥输出: <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">A B C</span><br><span class=\"line\">A B C</span><br><span class=\"line\">A B C</span><br><span class=\"line\">A B C</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">mutex _mutex;</span><br><span class=\"line\"><span class=\"type\">int</span> step = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> stepNum = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">tmp</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stepNum == <span class=\"number\">30</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step % <span class=\"number\">3</span> == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ++step;</span><br><span class=\"line\">            ++stepNum;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;A&quot;</span> &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">tmp</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stepNum == <span class=\"number\">30</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step % <span class=\"number\">3</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            ++step;</span><br><span class=\"line\">            ++stepNum;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;B&quot;</span> &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">tmp</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stepNum == <span class=\"number\">30</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (step % <span class=\"number\">3</span> == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            ++step;</span><br><span class=\"line\">            ++stepNum;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;C&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(func1)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(func2)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t3</span><span class=\"params\">(func3)</span></span>;</span><br><span class=\"line\">    t1.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t2.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    t3.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"条件变量\">条件变量</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">mutex _mutex;</span><br><span class=\"line\">condition_variable cv;</span><br><span class=\"line\"><span class=\"type\">bool</span> ready = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">// 最开始10个线程会在cv.wait处阻塞，并且会unlock _mutex。</span></span><br><span class=\"line\"><span class=\"comment\">// 当cv.notify后，这十个线程便会以随机的顺序尝试lock _mutex继续向下执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">workers</span><span class=\"params\">(<span class=\"type\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">unique_lock&lt;mutex&gt; <span class=\"title\">ulck</span><span class=\"params\">(_mutex)</span></span>; <span class=\"comment\">// 可以灵活unlock</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ready == <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;here: &quot;</span>&lt;&lt; id &lt;&lt; endl;</span><br><span class=\"line\">        cv.<span class=\"built_in\">wait</span>(ulck); <span class=\"comment\">// 阻塞</span></span><br><span class=\"line\">        <span class=\"comment\">// 其他操作...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;thread: &quot;</span> &lt;&lt; id &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">go</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">unique_lock&lt;mutex&gt; <span class=\"title\">ulck</span><span class=\"params\">(_mutex)</span></span>;</span><br><span class=\"line\">    ready = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    cv.<span class=\"built_in\">notify_all</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    thread mt[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">        mt[i] = <span class=\"built_in\">thread</span>(workers, i);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;10 threads ready to race...(already!)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">Sleep</span>(<span class=\"number\">50</span>); <span class=\"comment\">// 确保前面的线程先到地方wait</span></span><br><span class=\"line\">    <span class=\"built_in\">go</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : mt)</span><br><span class=\"line\">        e.<span class=\"built_in\">join</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C/C++"]},{"title":"C与CPP互相调用","url":"/2022/09/23/C%E4%B8%8ECPP%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/","content":"<h2 id=\"说明\">0. 说明</h2>\r\n<ul>\r\n<li>C++采用g++编译，C采用gcc编译。两者主要不同点是：C++编译考虑到函数重载，会将原函数“改名”（命名倾轧name mangling）；而在C中不存在重载，函数名不会变动。</li>\r\n<li>g++和gcc可以兼容C++和C的编译方式，但是默认情况下g++采用C++编译方式；而gcc采用C的编译方式</li>\r\n<li>注意：gcc编译C++文件时不会主动链接C++用到的库stdc++，需要手动指定链接选项<code>-lstdc++</code></li>\r\n<li><code>__cplusplus</code>宏定义会在编译cpp文件以及用C++的方式编译时被包含，因此用gcc编译.cpp文件或者g++编译.c、.cpp文件都会有这个宏</li>\r\n<li>之所以用条件判断，因为gcc不认识<code>extern \"C\"</code>，直接编译会报错</li>\r\n</ul>\r\n<h2 id=\"c调用c\">1. C++调用C</h2>\r\n<p>只需要声明时包含<code>extern \"C\"</code>即可。下面的代码中，func.h可以不动，在main.cpp调用时，直接<code>extern \"C\" int func(int, int)</code>也是可以的。只需要让编译器按照C的方式编译，不要改动函数名即可正确链接的函数符号。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.h 不论.c还是.cpp文件调用，都不会出错</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FUNC_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FUNC_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"built_in\">func</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c调用c-1\">2. C调用C++</h2>\r\n<p>C调用C++稍微麻烦点，遇到类函数和重载函数往往需要嵌套一层，详细如下。</p>\r\n<h3 id=\"普通函数\">2.1. 普通函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> FUNC_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FUNC_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;void func()&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"重载函数\">2.2. 重载函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ADAPTER_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADAPTER_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func_</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func_i</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// func.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;void func()&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;void func(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// adapter</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func_</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func_i</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(a);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;func.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func_</span>();</span><br><span class=\"line\">    <span class=\"built_in\">func_i</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"类函数\">2.3. 类函数</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Circle.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CIRCLE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CIRCLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">double</span> radius;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Circle</span>(<span class=\"type\">double</span> r) :<span class=\"built_in\">radius</span>(r) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Circle.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Circle.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Circle::getArea</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">3.1415926</span> * radius * radius;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p><strong>核心文件（adapter.h），此代码必须在C ++和C文件中都可以编译。</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// adapter.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> ADAPTER_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ADAPTER_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// __cplusplus</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">Circle_new</span><span class=\"params\">(<span class=\"type\">double</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Circle_getAea</span><span class=\"params\">(<span class=\"type\">void</span>*)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Circle_detete</span><span class=\"params\">(<span class=\"type\">void</span>*)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// adapter.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;adapter.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Circle.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span>* <span class=\"title\">Circle_new</span><span class=\"params\">(<span class=\"type\">double</span> r)</span> </span>&#123;</span><br><span class=\"line\">    Circle *p = <span class=\"keyword\">new</span> <span class=\"built_in\">Circle</span>(r);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">void</span>*)p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Circle_getAea</span><span class=\"params\">(<span class=\"type\">void</span>* p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((Circle*)p)-&gt;<span class=\"built_in\">getArea</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Circle_detete</span><span class=\"params\">(<span class=\"type\">void</span>* p)</span> </span>&#123;</span><br><span class=\"line\">    Circle* cp = (Circle*)p;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> cp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;adapter.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span>* p = <span class=\"built_in\">Circle_new</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lf\\n&quot;</span>, <span class=\"built_in\">Circle_getAea</span>(p));</span><br><span class=\"line\">    <span class=\"built_in\">Circle_detete</span>(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考\">3. 参考</h2>\r\n<ul>\r\n<li><a href=\"https://blog.csdn.net/qq_29344757/article/details/73332501\">c语言和c++的相互调用</a></li>\r\n<li><a href=\"https://blog.csdn.net/qq_37061368/article/details/118929829\">C语言中调用C＋＋</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/85663512\">极简式从C调用C++类方法</a></li>\r\n<li><a href=\"https://blog.csdn.net/qq_34799070/article/details/122118875\">C调用C++和C++调用C</a></li>\r\n<li><a href=\"https://blog.csdn.net/wuguinianjing/article/details/115282307\">C++与C的相互调用</a></li>\r\n</ul>\r\n","tags":["C/C++"]},{"title":"Hexo说明","url":"/2021/06/28/Hexo%E8%AF%B4%E6%98%8E/","content":"<blockquote>\r\n<p><strong>Hexo相关说明</strong></p>\r\n</blockquote>\r\n<h2 id=\"安装hexo\">安装Hexo</h2>\r\n<p><a href=\"https://blog.csdn.net/guixinchn/article/details/107787660\">安装hexo</a></p>\r\n<h2 id=\"hexo基本语法\">Hexo基本语法</h2>\r\n<p>hexo n 我的博客 == hexo new 我的博客 //新建文章 hexo g == hexo generate //生成 hexo s == hexo server //启动服务预览 hexo d == hexo deploy //部署</p>\r\n<p>hexo server //Hexo会监视文件变动并自动更新，无须重启服务器 hexo server -s //静态模式 hexo server -p 5000 //更改端口 hexo server -i 192.168.1.1 //自定义 IP hexo clean //清除缓存，若是网页正常情况下可以忽略这条命令</p>\r\n<h3 id=\"hexo相关\">Hexo相关</h3>\r\n<ol type=\"1\">\r\n<li>自动展开设置1：<a href=\"https://blog.csdn.net/yueyue200830/article/details/104470646\">显示部分摘要</a></li>\r\n<li>自动展开设置2：<a href=\"https://www.zhihu.com/question/394167076\">显示部分摘要</a></li>\r\n<li>hexo显示公式乱码问题：<a href=\"https://www.cnblogs.com/zhyantao/p/10424874.html\">公式乱码问题</a></li>\r\n<li><a href=\"https://www.cnblogs.com/study-everyday/p/8902136.html\">如何在另一台电脑使用hexo更新博客</a></li>\r\n</ol>\r\n<h3 id=\"github相关\">Github相关</h3>\r\n<p>如果无法deploy到Github，此时打开命令行输入<code>ping github.com</code>又失败，则可能是梯子的原因，无法进行DNS，即使关掉梯子也不行。此时可以手动在电脑的hosts文件里添加到Github的域名到ip映射，具体操作如下： 1. 在<a href=\"https://ipaddress.com/website/github.com\">IP查询网页</a>搜索github，找到github的网站地址 2. 进入<code>C:\\Windows\\System32\\drivers\\etc</code>修改hosts 3. 由于需要权限所以<strong>以管理员模式</strong>打开cmd，cd到hosts，然后输入<code>notepad hosts</code>即可进行修改添加，只需插入<code>IP www.github.com和IP github.com</code>保存即可</p>\r\n<h3 id=\"主题相关\">主题相关</h3>\r\n<ol type=\"1\">\r\n<li><a href=\"http://home.ustc.edu.cn/~liujunyan/blog/hexo-next-theme-config/\">NEXT常用配置</a></li>\r\n<li><a href=\"https://blog.csdn.net/qq_52116176/article/details/109406842\">背景图片修改问题</a></li>\r\n<li><a href=\"https://www.zhihu.com/question/29017171\">tags无法显示问题</a></li>\r\n<li><a href=\"https://blog.csdn.net/Domino_b/article/details/81704118\">next动画速度修改</a></li>\r\n<li><a href=\"https://blog.csdn.net/weixin_45511189/article/details/115798563\">数学公式问题</a></li>\r\n<li>代码复制功能：去主题的_config.yml修改<code>codeblock</code>下的<code>copy_button</code>改为<code>true</code>即可</li>\r\n</ol>\r\n","tags":["Others"]},{"title":"Qt信号与槽","url":"/2022/09/16/Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/","content":"<p>Qt的信号与槽机制是如何实现的？</p>\r\n<h2 id=\"猜测1回调函数\">猜测1：回调函数</h2>\r\n<ul>\r\n<li>这里用C11出现的function来封装所有可调用的对象：函数、指针、lambda、bind创建的对象、重载了小括号的仿函数</li>\r\n<li>通过unordered_multimap来记录某个字符串与一个可调用对象的映射（注意unordered_multimap未实现[]和at函数，不能通过这类方式获取value）</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Connection</span> &#123;</span><br><span class=\"line\">    unordered_multimap&lt;string, function&lt;<span class=\"type\">void</span>()&gt;&gt; mmap;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 按照名称建立映射关系</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">const</span> function&lt;<span class=\"type\">void</span>()&gt;&amp; callback)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//mmap[name] = callback; ERROR</span></span><br><span class=\"line\">        mmap.<span class=\"built_in\">insert</span>(&#123; name, callback &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">invok</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> res = mmap.<span class=\"built_in\">equal_range</span>(name);</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> l = res.first, r = res.second;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l != r) &#123;</span><br><span class=\"line\">            l-&gt;<span class=\"built_in\">second</span>();</span><br><span class=\"line\">            ++l;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 全局共享的Connection</span></span><br><span class=\"line\"><span class=\"type\">static</span> Connection con;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Tom</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">miaow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;喵&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        con.<span class=\"built_in\">invok</span>(<span class=\"string\">&quot;mouse&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Jerry</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Jerry</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通类函数的第一个参数是this，所以这里绑定this</span></span><br><span class=\"line\">        con.<span class=\"built_in\">connect</span>(<span class=\"string\">&quot;mouse&quot;</span>, <span class=\"built_in\">bind</span>(&amp;Jerry::RunAway, <span class=\"keyword\">this</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RunAway</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;那只笨又猫来了，快跑！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟嵌套层级很深的场景，外部不能直接访问到tom</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">struct</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span>:</span><br><span class=\"line\">                Tom tom;</span><br><span class=\"line\">            <span class=\"keyword\">public</span>:</span><br><span class=\"line\">                <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MiaoMiaoMiao</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    tom.<span class=\"built_in\">miaow</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; c;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MiaoMiao</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                c.<span class=\"built_in\">MiaoMiaoMiao</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; b;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Miao</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            b.<span class=\"built_in\">MiaoMiao</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 模拟嵌套层级很深的场景，外部不能直接访问到jerry</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">D</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> <span class=\"title class_\">E</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">struct</span> <span class=\"title class_\">F</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span>:</span><br><span class=\"line\">                Jerry jerry1, jerry2, jerry3;</span><br><span class=\"line\">            &#125; f;</span><br><span class=\"line\">        &#125; e;</span><br><span class=\"line\">    &#125; d;</span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">Miao</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>输出结果： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">喵</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"猜测2观察者模式\">猜测2：观察者模式</h2>\r\n<ul>\r\n<li>别名：订阅-发布模式</li>\r\n<li>任意类继承Subject模板类，提供观察者参数，即拥有了订阅-发布模式</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> ObserverType&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    vector&lt;ObserverType*&gt; _list;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 订阅</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObserverType* obs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itor = std::<span class=\"built_in\">find</span>(_list.<span class=\"built_in\">begin</span>(), _list.<span class=\"built_in\">end</span>(), obs);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_list.<span class=\"built_in\">end</span>() == itor) &#123;</span><br><span class=\"line\">            _list.<span class=\"built_in\">push_back</span>(obs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unSubscribe</span><span class=\"params\">(ObserverType* obs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// erase配合remove</span></span><br><span class=\"line\">        _list.<span class=\"built_in\">erase</span>(std::<span class=\"built_in\">remove</span>(_list.<span class=\"built_in\">begin</span>(), _list.<span class=\"built_in\">end</span>(), obs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FuncType&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">void</span> <span class=\"title\">publish</span><span class=\"params\">(FuncType func)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> obs : _list) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用回调函数，将obs作为一个参数传入</span></span><br><span class=\"line\">            <span class=\"built_in\">func</span>(obs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CatObserver接口 猫的观察者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CatObserver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">onMiaow</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">CatObserver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Tom继承自Subject，模板参数CatObserver</span></span><br><span class=\"line\"><span class=\"comment\">// 这样Tom就可以订阅、发布对应类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Tom</span> : <span class=\"keyword\">public</span> Subject&lt;CatObserver&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">miaow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;喵&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"comment\">// 这里CatObserver的成员函数，所以第一个参数需要this指针，这里悬置-&gt;对应publish的object</span></span><br><span class=\"line\">        <span class=\"built_in\">publish</span>(std::<span class=\"built_in\">bind</span>(&amp;CatObserver::onMiaow, std::placeholders::_1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Jerry继承自CatObserver，可以被订阅</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Jerry</span> : <span class=\"keyword\">public</span> CatObserver &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">onMiaow</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">RunAway</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RunAway</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;那只笨又猫来了，快跑！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Tom tom;</span><br><span class=\"line\">    Jerry jerry1, jerry2, jerry3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拿一堆jerry去订阅tom的 猫叫 事件</span></span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry1);</span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry2);</span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    tom.<span class=\"built_in\">miaow</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>输出结果： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">喵</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"真实的qt信号与槽\">真实的Qt信号与槽</h2>\r\n<ul>\r\n<li>同线程：类似函数调用，比观察者模式多一点性能损失</li>\r\n<li>异线程：发送者线程将槽函数的调用转化为一次“调用事件”加入到事件循环中，接收者线程执行到下一个事件处理时，处理调用事件</li>\r\n</ul>\r\n<p>信号与槽借助一个工具：元对象编译器MOC（Meta Object Compiler），集成在Qt编译工具链qmake中，在编译Qt工程前会先执行MOC，解析signals、slot、emit等关键字，处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等宏，生成一个moc_xxx.cpp的C++文件（黑魔法来实现语法糖）比如信号只要声明不用实现，因为MOC自动生成实现放在moc_xxx.cpp中。之后即可进行常规的C/C++编译、链接流程</p>\r\n<p>MOC的本质：反射 反射简单来说，就是运行过程中，获取对象的构造函数、成员函数、成员变量，例如：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Tom</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Tom</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> std::string &amp; <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class=\"line\">        m_name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>类的使用者看不到类的声明，头文件都拿不到，不能直接调用类的构造函数、成员函数。因此将Tom类的构造函数、成员函数等信息存储起来，还要能够被调用到。这些信息就是“元信息”，使用者通过“元信息”就可以“使用这个类了”，这便是反射。设计模式中的工厂模式就是反射的一种。</p>\r\n<p>python中涉及反射机制的函数有：<code>getattr(), setattr(), delattr(), exec(), eval(), __import__</code>等，都可以执行字符串</p>\r\n<p>更具体的实现机制参考<a href=\"https://zhuanlan.zhihu.com/p/80539605\">窥探信号槽的实现细节</a>，这里仅摘录部分。</p>\r\n<h2 id=\"参考\">参考</h2>\r\n<ul>\r\n<li><a href=\"https://blog.csdn.net/thorking01/article/details/120911438\">C++ function</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/75126932\">认清信号槽的本质</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/80539605\">窥探信号槽的实现细节</a></li>\r\n<li><a href=\"https://zhuanlan.zhihu.com/p/345452320\">Qt进阶之路</a></li>\r\n</ul>\r\n","tags":["C/C++","Qt"]},{"title":"Rand7实现Rand10","url":"/2022/03/19/Rand7%E5%AE%9E%E7%8E%B0Rand10/","content":"<h1 id=\"用-rand7-实现-rand10\">470 <a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">用 Rand7() 实现 Rand10()</a></h1>\r\n<h2 id=\"拒绝采样\">1. 拒绝采样</h2>\r\n<p>在解LC-470前先介绍一道拒绝采样的经典问题：利用频率近似概率的方式求出 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.29ex\" height=\"1ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -431 570 442\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D70B\" d=\"M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z\"></path></g></g></g></svg></mjx-container></span> 的值。在 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: 0;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.028ex\" height=\"1.507ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 2222.4 666\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mn\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(722.2,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1722.4,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></g></g></svg></mjx-container></span> 的方块内随机坐标采样，记录落入以原点为圆心，半径为1的 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.781ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.795ex\" height=\"2.737ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -864.9 793.6 1209.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mn\" transform=\"translate(220,394) scale(0.707)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(220,-345) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"></path></g><rect width=\"553.6\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></svg></mjx-container></span> 圆内的次数。</p>\r\n<p>由 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.781ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.336ex\" height=\"2.737ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -864.9 5010.4 1209.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mn\" transform=\"translate(220,394) scale(0.707)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(220,-345) scale(0.707)\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"></path></g><rect width=\"553.6\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mi\" transform=\"translate(793.6,0)\"><path data-c=\"1D70B\" d=\"M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1363.6,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(484,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(2528.9,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mfrac\" transform=\"translate(3584.7,0)\"><g data-mml-node=\"mrow\" transform=\"translate(220,394) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1033,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(398.9,-345) scale(0.707)\"><path data-c=\"1D441\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g><rect width=\"1185.7\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></svg></mjx-container></span> 可得 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.871ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.577ex\" height=\"2.846ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -872.7 4232.9 1257.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D70B\" d=\"M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(847.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mfrac\" transform=\"translate(1903.6,0)\"><g data-mml-node=\"mrow\" transform=\"translate(220,394) scale(0.707)\"><g data-mml-node=\"mn\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(500,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1278,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1711,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2311,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g><g data-mml-node=\"mrow\" transform=\"translate(261.9,-377.4) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D441\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(888,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(1666,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(484,289) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g></g><rect width=\"2089.4\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></svg></mjx-container></span> ，由于 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.186ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.169ex\" height=\"1.692ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -666 2284.6 748\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(728.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(1784.6,0)\"><path data-c=\"31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path></g></g></g></svg></mjx-container></span> ，所以 <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.781ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.577ex\" height=\"2.755ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -872.7 4232.9 1217.7\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D70B\" d=\"M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(847.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mfrac\" transform=\"translate(1903.6,0)\"><g data-mml-node=\"mrow\" transform=\"translate(220,394) scale(0.707)\"><g data-mml-node=\"mn\"><path data-c=\"34\" d=\"M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(500,0)\"><path data-c=\"D7\" d=\"M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1278,0)\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1711,0)\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2311,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(850.7,-345) scale(0.707)\"><path data-c=\"1D441\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path></g><rect width=\"2089.4\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g></g></svg></mjx-container></span></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"type\">unsigned</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">// time(0)表示从1970到现在的秒数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> N = (<span class=\"type\">int</span>)<span class=\"number\">1e7</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) {</span><br><span class=\"line\">        <span class=\"type\">double</span> a = (<span class=\"number\">1.0</span> * <span class=\"built_in\">rand</span>() / RAND_MAX); <span class=\"comment\">// 除以RAND_MAX归一化0~1</span></span><br><span class=\"line\">        <span class=\"type\">double</span> b = (<span class=\"number\">1.0</span> * <span class=\"built_in\">rand</span>() / RAND_MAX);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a * a + b * b &lt; <span class=\"number\">1.0</span>) cnt++; <span class=\"comment\">// 落入1/4圆则加一</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%lf\"</span>, (<span class=\"number\">4.0</span> * cnt) / N);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"lc-470-rand7生成rand10\">2. LC-470 Rand7生成Rand10</h2>\r\n<p><a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/\">力扣高赞题解</a></p>\r\n<p><strong>(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数</strong> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>){</span><br><span class=\"line\">            <span class=\"comment\">// 等概率生成[1,49]范围的随机数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> num = (<span class=\"built_in\">rand7</span>()<span class=\"number\">-1</span>)*<span class=\"number\">7</span> + <span class=\"built_in\">rand7</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 拒绝采样，并返回[1,10]范围的随机数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num &lt;= <span class=\"number\">40</span>) <span class=\"keyword\">return</span> num % <span class=\"number\">10</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法"]},{"title":"Set、Map、Unordered","url":"/2022/03/27/Set%E3%80%81Map%E3%80%81Unordered/","content":"<h1 id=\"map和set\">Map和Set</h1>\r\n<ul>\r\n<li>Map是<code>&lt;key, value&gt;</code>结构；Set是<code>&lt;key&gt;</code>结构，天然具有去重功能</li>\r\n<li>自定义类放入Map或Set需要实现<code>bool operator&lt;(const MyClass&amp; ano) const</code>，注意里面的两个const是必备的，不能漏</li>\r\n<li>不用实现<code>operator=</code>，因为<code>a&lt;b == false &amp;&amp; a&gt;b == false</code>会自动推断出等于</li>\r\n</ul>\r\n<h2 id=\"示范图\">0、示范图</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">         <span class=\"number\">0</span></span><br><span class=\"line\">         |</span><br><span class=\"line\">        (<span class=\"number\">1</span>)</span><br><span class=\"line\">         |</span><br><span class=\"line\"><span class=\"number\">2</span> —(<span class=\"number\">1</span>)—  <span class=\"number\">1</span>  —(<span class=\"number\">1</span>)— <span class=\"number\">3</span></span><br><span class=\"line\">   \\           /</span><br><span class=\"line\">   (<span class=\"number\">3</span>)       (<span class=\"number\">2</span>)</span><br><span class=\"line\">      \\     /</span><br><span class=\"line\">         <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"错误代码示例\">1、错误代码示例</h2>\r\n<ul>\r\n<li>下面<code>Node</code>类，利用Set来实现Dijkstra是不对的，因为在<code>operator&lt;</code>中参与返回结果的只有<code>val</code>因此，两个不一样的<code>Node</code>在<code>Set</code>中会被认为是相同的。即<code>Node a = Node(&#123;1,1&#125;)和Node b = Node(&#123;2,1&#125;)</code>，由于<code>(a&lt;b==false &amp;&amp; b&gt;a==false)</code>所以被判定为相等，与我们的目的南辕北辙。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _p, <span class=\"type\">int</span> _v):<span class=\"built_in\">pos</span>(_p), <span class=\"built_in\">val</span>(_v)&#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;val &lt; ano.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; g = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>,   <span class=\"number\">1</span>,   inf, inf, inf&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>,   <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">1</span>,   inf&#125;,</span><br><span class=\"line\">        &#123;inf, <span class=\"number\">1</span>,   <span class=\"number\">0</span>,   inf, <span class=\"number\">3</span>  &#125;,</span><br><span class=\"line\">        &#123;inf, <span class=\"number\">1</span>,   inf, <span class=\"number\">0</span>,   <span class=\"number\">2</span>  &#125;,</span><br><span class=\"line\">        &#123;inf, inf, <span class=\"number\">3</span>,   <span class=\"number\">2</span>,   <span class=\"number\">0</span>  &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = (<span class=\"type\">int</span>)g.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ------------------------------------</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">    dist[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    set&lt;Node&gt; pq;</span><br><span class=\"line\">    pq.<span class=\"built_in\">insert</span>(<span class=\"built_in\">Node</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        Node cur = *pq.<span class=\"built_in\">begin</span>(); pq.<span class=\"built_in\">erase</span>(pq.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> from = cur.pos;</span><br><span class=\"line\">        <span class=\"type\">int</span> dis = cur.val;</span><br><span class=\"line\">        cout &lt;&lt; from &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; cur.val &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> to = <span class=\"number\">0</span>; to &lt; n; ++to) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;</span><br><span class=\"line\">                dist[to] = dis + g[from][to];</span><br><span class=\"line\">                pq.<span class=\"built_in\">insert</span>(<span class=\"built_in\">Node</span>(to, dist[to]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : dist)</span><br><span class=\"line\">        cout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 输出结果为： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"comment\">// 错误，应该是4</span></span><br><span class=\"line\"><span class=\"comment\">// 原因是插入Node&#123;3,2&#125;时发现已经有了，所以就取消插入，因此无法利用&#123;3,2&#125;来更新最小边</span></span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"正确用法priority_queue\">2、正确用法priority_queue</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _p, <span class=\"type\">int</span> _v):<span class=\"built_in\">pos</span>(_p), <span class=\"built_in\">val</span>(_v)&#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pos;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Node&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;val &gt; ano.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; g = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">0</span>,   <span class=\"number\">1</span>,   inf, inf, inf&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">1</span>,   <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">1</span>,   inf&#125;,</span><br><span class=\"line\">        &#123;inf, <span class=\"number\">1</span>,   <span class=\"number\">0</span>,   inf, <span class=\"number\">3</span>  &#125;,</span><br><span class=\"line\">        &#123;inf, <span class=\"number\">1</span>,   inf, <span class=\"number\">0</span>,   <span class=\"number\">2</span>  &#125;,</span><br><span class=\"line\">        &#123;inf, inf, <span class=\"number\">3</span>,   <span class=\"number\">2</span>,   <span class=\"number\">0</span>  &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = (<span class=\"type\">int</span>)g.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// ------------------------------------</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">    dist[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq;</span><br><span class=\"line\">    pq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        Node cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> from = cur.pos;</span><br><span class=\"line\">        <span class=\"type\">int</span> dis = cur.val;</span><br><span class=\"line\">        cout &lt;&lt; from &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; cur.val &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> to = <span class=\"number\">0</span>; to &lt; n; ++to) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;</span><br><span class=\"line\">                dist[to] = dis + g[from][to];</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(to, dist[to]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : dist)</span><br><span class=\"line\">        cout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>输出结果为： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"总之以后写dijkstra不要妄图用set和map来替换优先队列\">总之，以后写Dijkstra不要妄图用set和map来替换优先队列!!!</h2>\r\n<h1 id=\"unordered_set和unordered_map\">Unordered_set和unordered_map</h1>\r\n<ol type=\"1\">\r\n<li>需要定义一个仿函数<code>operator(...)</code>用来计算hash_value，并在定义时传入模板参数</li>\r\n<li>重载<code>operator==</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">node</span>(<span class=\"type\">int</span> _id, <span class=\"type\">double</span> _val) : <span class=\"built_in\">id</span>(_id), <span class=\"built_in\">val</span>(_val) &#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">double</span> val;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> node&amp; ano) <span class=\"type\">const</span> &#123; <span class=\"comment\">// 判断两个对象是否相等（自动加上key匹配再判断相等）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> val == ano.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> node&amp; v)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"comment\">// 生成hash value，必须返回 [无符号整数] 用来进行映射</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.id; <span class=\"comment\">// 生成hash value的方式都可以灵活自定义</span></span><br><span class=\"line\">        <span class=\"comment\">//return hash&lt;double&gt;()(v.val);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;node, string, node_hash&gt; ms;</span><br><span class=\"line\">    node a = &#123; <span class=\"number\">1</span>, <span class=\"number\">1.1111</span> &#125;;</span><br><span class=\"line\">    node b = &#123; <span class=\"number\">2</span>, <span class=\"number\">1.1111</span> &#125;;</span><br><span class=\"line\">    ms[a] = <span class=\"string\">&quot;aaaa&quot;</span>;</span><br><span class=\"line\">    ms[b] = <span class=\"string\">&quot;bbbb&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; ms[a] &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; ms[b] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n","tags":["C/C++"]},{"title":"YOLOv3源码理解","url":"/2022/10/08/YOLOv3%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/","content":"<h2 id=\"主干网络\">0 主干网络</h2>\r\n<p>YOLOv3采用DarkNet-53网络，结构如下图（DarkNet-53预训练于ImageNet，由于是1000类的分类，所以网络最后输出经过全连接层。但是目标检测不需要那个全连接层，因此实际上只使用了“DarkNet-52”，共52层卷积层）：</p>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/YOLOv3_Backbone.jpg\" alt=\"YOLOv3 Backbone\" /><figcaption aria-hidden=\"true\">YOLOv3 Backbone</figcaption>\r\n</figure>\r\n<p>BN为批归一化层，Acti为激活函数，YOLOv3采用LeakyReLU</p>\r\n<p>输入批次经过一个3X3卷积改变通道数为32，然后经过5个降残差块。每个降残差块包含一次步幅为2的3X3卷积加上一系列残差块。每个残差块包含一次1X1卷积降低通道数，再经过一次3X3卷积提升通道数，最后和残差边进行连接。</p>\r\n<p>整体主干网络清晰，每经过一个降残差块，通道数翻倍，特征图宽高减半。</p>\r\n<h2 id=\"预测分支网络\">1 预测分支网络</h2>\r\n<p>下图是YOLOv3的预测分支网络部分，是一个典型的特征金字塔结构。最后的输出通道75是假设采用VOC数据集进行20个类别的检测，因此输出的75代表<code>3*(4+1+20)</code>，3代表每个特征点3个先验框；4代表先验框x、y的偏移量以及宽高的伸缩量；1代表该先验框包含目标的置信度；20代表该数据集类别个数。</p>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/YOLOv3_Branch.png\" alt=\"YOLOv3 Branch\" /><figcaption aria-hidden=\"true\">YOLOv3 Branch</figcaption>\r\n</figure>\r\n<h2 id=\"数据加载\">2 数据加载</h2>\r\n<ul>\r\n<li>图片会被进行各种图像增强、添加灰条等操作，最终大小为<code>(416，416)</code>，值归一化到<code>0~1</code>，形状为<code>(B, 3, 416, 416)</code></li>\r\n<li>标签会被归一化<code>0~1</code>（从数据集<code>[左上右下]</code>转换为<code>[中心宽高]</code>），形状为<code>list[(GT, 4)...B个]</code></li>\r\n</ul>\r\n<h2 id=\"训练网络\">3 训练网络</h2>\r\n<ul>\r\n<li>网络前向传播会获得一个包含三元素的元组：<code>((bs,75,13,13),(bs,75,26,26),(bs,75,52,52))</code>，代表网络三个层的输出</li>\r\n<li>依次计算每个层的损失，相加之后进行反向传播</li>\r\n</ul>\r\n<h3 id=\"输出层的解码\">3.1 输出层的解码</h3>\r\n<p>以<code>(bs,75,13,13)</code>为例，<code>view</code>到<code>(bs,3,13,13,25)</code>，随后通过其中包含的信息结合给该层分配的三个先验框的宽高，可以得到预测框的结果。 - <code>(..., 0:2)</code>执行<code>sigmoid</code>获得该层先验框的偏移 - <code>(..., 2:4)</code>不执行任何操作，之后用于宽高的缩放 - <code>(..., 4)</code>执行<code>sigmoid</code>获得包含物体的置信度 - <code>(..., 5:)</code>执行<code>sigmoid</code>获得被认为是每个类别的概率</p>\r\n<h3 id=\"正负样本\">3.2 正负样本</h3>\r\n<ul>\r\n<li>批次里的每个图片都会单独循环处理：将这些真实框与9个先验框做IOU，从而确定每个真实框由哪个大小的先验框负责。确认后，再根据真实框的中心位置，确认属于哪个特征点负责，最终即可确认由哪一个先验框（确定了哪一层）的哪个特征图（该层的哪个格子）负责，正样本既定。</li>\r\n<li>按理说，其他未分配真实框的预测框都是负样本，有<code>(13*13+26*26+52*52)*3 - 9 = 10647 - 9 = 10638</code>个负样本。但是作者考虑到，某些本不负责预测目标框的预测框，如果其IOU与该目标比较重合（例如大于0.5），则不能将其作为负样本，应该忽略之。因此实际的负样本应该是小于该值的。</li>\r\n</ul>\r\n<h3 id=\"损失函数计算\">3.3 损失函数计算</h3>\r\n<ul>\r\n<li>YOLOv3包含三个损失：边框回归损失、目标置信度损失、类别损失</li>\r\n<li>对于正样本，三项损失都要计算：\r\n<ul>\r\n<li>其中边框回归损失可以采用<code>MSELoss</code>、<code>BCELoss</code>、或者各类的<code>IOU损失</code>，例如<code>DIOU, GIOU, CIOU</code></li>\r\n<li>目标置信度损失直接采用<code>BCELoss</code>，可以选择和<code>Focal Loss</code>形式结合</li>\r\n<li>类别损失直接采用<code>BCELoss</code></li>\r\n</ul></li>\r\n<li>对于负样本，只计算目标置信度损失，直接采用<code>BCELoss</code>，可以选择和<code>Focal Loss</code>形式结合。注意，当选择<code>Focal Loss</code>形式时，该项损失的权重系数要重新配置，一般要增大很多。而且训练结束后的预测的<code>置信度*类别</code>可能会降低，因为只学习难的，简单易判的往往损失权值极地，基本不学习，导致这种现象产生。</li>\r\n</ul>\r\n<h2 id=\"预测网络\">4 预测网络</h2>\r\n<ul>\r\n<li>转RGB、调整形状、添加灰条（可选）、归一化0~1、添加批次通道，最终形状：<code>(1,3,416,416)</code></li>\r\n<li>送入网络得到结果，一个包含三元素的元组：<code>((1,75,13,13),(1,75,26,26),(1,75,52,52))</code></li>\r\n<li>将结果解码：根据预测结果和先验框宽高，得到一个包含三元素的列表：<code>[(1, 3*13*13, 25), (1, 3*26*26, 25), (1, 3*52*52, 25)]</code>，最终合并为单个张量：<code>(1, 10647, 25)</code>。其中的值都被归一化为0~1了</li>\r\n<li>将数据转换为<code>(10647, 7)</code>代表<code>xmin, ymin, xmax, ymax, conf, class_conf, class_pred</code>，按照<code>(..., 4)*(..., 5) &gt; threshold</code>获得保留的预测框</li>\r\n<li>按照每个类别，分别执行非极大值抑制，最后收集保留的这些预测框</li>\r\n<li>将预测框按照之前图像预处理，进行反向操作（其中为方便操作，将之前的7属性的坐标部分进行颠倒，现在为<code>ymin, xmin, ymax, xmax, conf, class_conf, class_pred</code>），可以理解为<code>top, left, bottom, right</code></li>\r\n</ul>\r\n","tags":["目标检测"]},{"title":"const要点","url":"/2022/08/19/const%E8%A6%81%E7%82%B9/","content":"<h1 id=\"const要点\">const要点</h1>\r\n<ul>\r\n<li>C的const是虚假的，就是个只读量，只是说不能通过变量名进行修改，但是拿到指针就可修改；</li>\r\n<li>C++的const会保险一些，会有类似符号表的东西；但是类内的const普通成员变量则依旧会被通过指针改变</li>\r\n<li>静态const和全局const虽然可以通过指针修改，编译时期可能不会报错，但是运行到那个地方就会报错</li>\r\n<li>const只在编译期间保证常量被使用时的不变性，无法保证运行期间的行为。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> val2 = <span class=\"number\">22</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> val3;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">int</span> val4 = <span class=\"number\">44</span>; <span class=\"comment\">// !</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> A::val3 = <span class=\"number\">33</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> val5 = <span class=\"number\">55</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> val6 = <span class=\"number\">66</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> val1 = <span class=\"number\">11</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>* p1 = (<span class=\"type\">int</span>*)&amp;val1; <span class=\"comment\">// 栈区，拿到地址随便改，但是符号表会覆盖</span></span><br><span class=\"line\">    *p1 = <span class=\"number\">1111</span>;</span><br><span class=\"line\">    cout &lt;&lt; &amp;val1 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; p1 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;===&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    A ins;</span><br><span class=\"line\">    <span class=\"type\">int</span>* p2 = (<span class=\"type\">int</span>*)&amp;ins.val2;</span><br><span class=\"line\">    *p2 = <span class=\"number\">2222</span>; <span class=\"comment\">// 栈区，拿到地址随便改</span></span><br><span class=\"line\">    cout &lt;&lt; &amp;ins.val2 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; ins.val2 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; p2 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;===&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span>* p3 = (<span class=\"type\">int</span>*)&amp;A::val3;</span><br><span class=\"line\">    *p3 = <span class=\"number\">3333</span>; <span class=\"comment\">// 全局数据区，但是不在常量区，可以修改</span></span><br><span class=\"line\">    cout &lt;&lt; p3 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p3 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &amp;A::val3 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; A::val3 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;===&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span>* p4 = (<span class=\"type\">int</span>*)&amp;A::val4;</span><br><span class=\"line\">    <span class=\"comment\">//*p4 = 4444; // 编译不出错，运行会异常（常量区不能修改）</span></span><br><span class=\"line\">    cout &lt;&lt; p4 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p4 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &amp;A::val4 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; A::val4 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;===&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span>* p5 = (<span class=\"type\">int</span>*)&amp;val5;</span><br><span class=\"line\">    <span class=\"comment\">//*p5 = 5555; // 编译不出错，运行会异常（常量区不能修改）</span></span><br><span class=\"line\">    cout &lt;&lt; p5 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p5 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &amp;val5 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; val5 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;===&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span>* p6 = (<span class=\"type\">int</span>*)&amp;val6;</span><br><span class=\"line\">    *p6 = <span class=\"number\">6666</span>; <span class=\"comment\">// 全局数据区，但是不在常量区，可以修改</span></span><br><span class=\"line\">    cout &lt;&lt; p6 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *p6 &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &amp;val6 &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; val6 &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 输出结果： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">00EFFD98 11</span></span><br><span class=\"line\"><span class=\"comment\">00EFFD98 1111</span></span><br><span class=\"line\"><span class=\"comment\">===</span></span><br><span class=\"line\"><span class=\"comment\">00EFFD80 2222</span></span><br><span class=\"line\"><span class=\"comment\">00EFFD80 2222</span></span><br><span class=\"line\"><span class=\"comment\">===</span></span><br><span class=\"line\"><span class=\"comment\">0027C038 3333</span></span><br><span class=\"line\"><span class=\"comment\">0027C038 3333</span></span><br><span class=\"line\"><span class=\"comment\">===</span></span><br><span class=\"line\"><span class=\"comment\">00279B38 44</span></span><br><span class=\"line\"><span class=\"comment\">00279B38 44</span></span><br><span class=\"line\"><span class=\"comment\">===</span></span><br><span class=\"line\"><span class=\"comment\">00279B30 55</span></span><br><span class=\"line\"><span class=\"comment\">00279B30 55</span></span><br><span class=\"line\"><span class=\"comment\">===</span></span><br><span class=\"line\"><span class=\"comment\">0027C03C 6666</span></span><br><span class=\"line\"><span class=\"comment\">0027C03C 6666</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"c内存分区\">C++内存分区</h1>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/C%2B%2B内存分区.jpg\" alt=\"C++内存分区\" /><figcaption aria-hidden=\"true\">C++内存分区</figcaption>\r\n</figure>\r\n<h1 id=\"参考\">参考</h1>\r\n<ol type=\"1\">\r\n<li><a href=\"https://blog.csdn.net/qq_43152052/article/details/99306967\">C++：const常量的存储位置</a></li>\r\n<li><a href=\"https://www.cnblogs.com/heluan/p/8652809.html\">C/C++的四大内存分区和常量的存储位置</a></li>\r\n<li><a href=\"https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-基础语法.html\">阿秀的笔记</a></li>\r\n</ol>\r\n","tags":["C/C++"]},{"title":"Essential C++ note","url":"/2021/08/05/essential-C-note/","content":"<blockquote>\r\n<p><strong>记录本书（对我来说）的一些重点内容</strong></p>\r\n</blockquote>\r\n<h3 id=\"c编程基础\">1 C++编程基础</h3>\r\n<ol type=\"1\">\r\n<li>初始化方法：构造函数法（constructor syntax）</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">var</span><span class=\"params\">(<span class=\"number\">66</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> var2&#123;<span class=\"number\">66</span>&#125;; <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li>srand()随机数种子；rand()则产生一个介于0和int所能表示的最大整数；需包含头文件cstdlib</li>\r\n<li>cerr（standard error）代表标准错误设备，与cout唯一区别就是不带缓冲，立即显示于用户终端</li>\r\n</ol>\r\n<h3 id=\"面向过程的编程风格\">2 面向过程的编程风格</h3>\r\n<ol type=\"1\">\r\n<li>使用模板，则声明与定义要放在一起</li>\r\n<li>函数指针</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给函数指针赋初值</span></span><br><span class=\"line\"><span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;* (*seq_str)(<span class=\"type\">int</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// seq_array是个数组，内放函数指针</span></span><br><span class=\"line\"><span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;* (*seq_array[])(<span class=\"type\">int</span>) = &#123;</span><br><span class=\"line\">    fibon_seq, lucas_seq, pell_seq,</span><br><span class=\"line\">    triang_seq, square_seq, pent_seq</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>inline函数的声明和定义都需要放在头文件，声明和定义有一个标明inline即可（在类定义中实现则默认是inline）；其他的函数，则必须是<strong>“定义放在程序代码文件”、“声明放在头文件”</strong></li>\r\n<li>多文件共享变量</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    变量只能定义一次，但是可以声明多次</span></span><br><span class=\"line\"><span class=\"comment\">    假定main.cpp func.cpp func.h三个文件</span></span><br><span class=\"line\"><span class=\"comment\">    1. 在func.cpp有一个int a=1;如果要在main.cpp中使用，要在func.h或main.cpp中写extern int a；</span></span><br><span class=\"line\"><span class=\"comment\">    2. const object和inline函数一样，是“一次定义”规则下的例外。const object定义只要一出文件外就</span></span><br><span class=\"line\"><span class=\"comment\">       不可见（意味着可以在多个程序代码中加以定义）。因此如果const int a=1想多文件共享，可以直接写</span></span><br><span class=\"line\"><span class=\"comment\">       在func.h中，其他的非const object则不可。</span></span><br><span class=\"line\"><span class=\"comment\">       可参考：https://www.icode9.com/content-1-915590.html</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"泛型编程风格\">3 泛型编程风格</h3>\r\n<ol type=\"1\">\r\n<li>list不支持iterator的偏移运算（+、-）但是有++和--</li>\r\n<li>对于标准容器，不确保目标空间大小，可使用iterator inserter用插入操作替代赋值操作</li>\r\n<li>&lt;这章挺多东西，需要结合书本去看&gt;</li>\r\n</ol>\r\n<h3 id=\"基于对象的编程风格\">4 基于对象的编程风格</h3>\r\n<ol type=\"1\">\r\n<li>如果有必要为某个class编写[拷贝构造]，则同样有必要为它编写[赋值操作]</li>\r\n<li>没有一个const reference class参数可以调用公开接口中的non-const成分</li>\r\n<li>类中的变量声明为mutable，标明其不会破坏对象的<strong>常量性</strong>（constness），即可在const函数中可以修改它</li>\r\n<li>当定义class的static function时，不可加上关键字static（同理静态成员变量）</li>\r\n<li>当类中有静态成员变量时，需要及时在类外进行初始化，否则报错：无法解析的外部命令</li>\r\n<li>通常情况：**operator*无参表示解引用；有参表示乘法**</li>\r\n<li>friend声明可以出现在类定义任意位置，不受public或private影响</li>\r\n<li><strong>嵌套类型</strong>（Nested Type），类中可以定义嵌套类型，再用域解析符（例如每个STL容器类都有自己的iterator）</li>\r\n<li>重载iostream（看书）</li>\r\n<li>类的函数指针：</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> (num_sequence::*pm)(<span class=\"type\">int</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果决定上面一行复杂可以写成：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(num_sequence::*PtrType)</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\">PtrType pm = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 成员函数取址要加上class scope限定符和&amp;取地址运算符（不同于一般函数，都不可以省！）</span></span><br><span class=\"line\">PtrType pm = &amp;num_sequence::fibonaci;</span><br><span class=\"line\"><span class=\"comment\">// 调用，由此要引出pointer to member selection运算符“.*”和&quot;-&gt;*&quot;</span></span><br><span class=\"line\">(ns.*pm)(pos)</span><br><span class=\"line\">(pns-&gt;*pm)(pos)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"面向对象编程风格\">5 面向对象编程风格</h3>\r\n<ol type=\"1\">\r\n<li>纯虚函数：将虚函数赋值为0</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li>任何类声明了纯虚函数，那么由于其接口不完整（无定义），程序无法为其产生实体。这种类只能作为派生类的子对象使用，而且前提是这些派生类为<strong>所有</strong>虚函数提供确切的定义。</li>\r\n<li>一般规则：凡基类定义了虚函数，则destructor也要声明为virtual</li>\r\n<li>一般而言，对象的拷贝构造函数开发者如果未提供，则编译器会自动生成默认的拷贝构造函数。然而以下情况默认的拷贝构造函数会被删除：</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1、存在非静态的const成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    2、存在非静态的引用成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    3、存在不能拷贝的成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    4、存在不能拷贝的基类</span></span><br><span class=\"line\"><span class=\"comment\">    5、存在用户定义的移动构造函数或移动赋值函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"5\" type=\"1\">\r\n<li>在基类的constructor中，派生类的虚函数不允许被调用</li>\r\n<li>static_cast和dynamic_cast，前者无条件转换，后者判断（比如基类的指针是否真的指向了该派生类）是否可以转换为目的类型再进行转换</li>\r\n</ol>\r\n<h3 id=\"以template进行编程\">6 以template进行编程</h3>\r\n<ol type=\"1\">\r\n<li>函数传入一个指针，只能改变指针所指对象的内容，要想改变指针本身（指向）就要传递reference to pointer</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">BTnode*&amp; prev <span class=\"comment\">// 可以看成BTnode* &amp;prev 或 ((BTnode*)&amp;) prev</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"2\" type=\"1\">\r\n<li>模板类声明友元的问题：</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面代码直接运行会报错：无法解析的外部命令</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(T t):<span class=\"built_in\">dy</span>(t) &#123;&#125;</span><br><span class=\"line\">    T dy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&lt;T&gt;&amp; b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(ostream&amp; os)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        os &lt;&lt; dy &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&lt;T&gt;&amp; b) &#123;</span><br><span class=\"line\">    b.<span class=\"built_in\">func</span>(os);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">A&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">4.2</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    原因：</span></span><br><span class=\"line\"><span class=\"comment\">    因为&quot;operator&lt;&lt;&quot;这个函数的参数T不应该依赖于class的模板参数，友元本来是可以访问类的所有数据成员的(该模板类的int、double、string对象)，你这样依赖的话，放到外部表名该参数T是属于类内部本身，解决方案是为了更好的支持友元，我们一般单独给友元一个模板参数</span></span><br><span class=\"line\"><span class=\"comment\">    1、类中友元声明改为（意义不明不过能用，但是其下绿波浪线提示函数未定义）（不推荐）</span></span><br><span class=\"line\"><span class=\"comment\">    friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; os, const A&lt;T&gt;&amp; b);</span></span><br><span class=\"line\"><span class=\"comment\">    2、类中友元声明改为（S不同于T）（推荐）</span></span><br><span class=\"line\"><span class=\"comment\">    template &lt;typename S&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&lt;S&gt;&amp; b);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>非类型参数</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1、这类参数在模板内部都是常量值</span></span><br><span class=\"line\"><span class=\"comment\">    2、只允许传入整形、指针和引用这三类</span></span><br><span class=\"line\"><span class=\"comment\">    3、调用非类型参数的实参必须为常量表达式（必须在编译时能计算出结果的）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"异常处理\">7 异常处理</h3>\r\n<ol type=\"1\">\r\n<li>重新抛出时，只需写下关键字throw即可。它只能出现于catch子句中</li>\r\n<li>局部资源管理，在易发生异常后释放资源是一件风险很大的事情。虽然可以通过try catch处理，但是释放资源的代码要出现两次，不好。这就引出了resource acquisition is initialization(RAII)策略，即初始化阶段进行资源请求。说人话就是，在构造函数中请求所有资源，在析构函数中释放所有资源：C++保证，在异常处理机制终结某个函数之前，所有局部对象的destructor都会被调用。或者使用智能指针例如：unique_ptr、shared_ptr等。</li>\r\n<li>ptext = new vector<string>; 经过以下几个步骤（异常出现，余下不会执行，会沿着调用链抛出）</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    // 可能会reorder哦~</span></span><br><span class=\"line\"><span class=\"comment\">    1、分配足够的空间</span></span><br><span class=\"line\"><span class=\"comment\">    2、将vector&lt;string&gt; default constructor应用于heap对象之上</span></span><br><span class=\"line\"><span class=\"comment\">    3、将对象地址设置给ptext</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\r\n","tags":["C/C++"]},{"title":"二分变种","url":"/2022/03/21/%E4%BA%8C%E5%88%86%E5%8F%98%E7%A7%8D/","content":"<h1 id=\"有序数组中的单一元素\">540 <a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">有序数组中的单一元素</a></h1>\r\n<h2 id=\"我的二分\">我的二分</h2>\r\n<ul>\r\n<li>与右侧配对失败:\r\n<ul>\r\n<li>右侧是奇数: <code>l = m + 1</code></li>\r\n<li>右侧是偶数: <code>r = m</code></li>\r\n</ul></li>\r\n<li>与右侧配对成功:\r\n<ul>\r\n<li>右侧是奇数: <code>l = m + 2</code></li>\r\n<li>右侧是偶数: <code>r = m - 1</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123; <span class=\"comment\">// 这样可以放心取m+1不越界</span></span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] != nums[m+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((r-m) &amp; <span class=\"number\">1</span>) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((r-m<span class=\"number\">-1</span>) &amp; <span class=\"number\">1</span>) l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"官方的全数组二分查找\">官方的全数组二分查找</h2>\r\n<ul>\r\n<li><p>假设要找的是数字X，则在X左边的数，下标是偶数的都是重复数字的第一位，下标是奇数的都是重复数字的第二位；在X右边的数，下标是奇数的都是重复数字的第一位，下标是偶数的都是重复数字的第二位；</p></li>\r\n<li><p>取中值时，若m是偶数，则尝试与m+1比较是否相等，相等则表明[:m+1]正常，X在m+1的右侧，因此<code>l = m + 2</code>；若不相等，则X在[:m]，因此<code>r = m</code></p></li>\r\n<li><p>取中值时，若m是奇数，则尝试与m-1比较是否相等，相等则表明[:m]正常，X在m的右侧，因此<code>l = m + 1</code>；若不相等，则X在[:m]，因此<code>r = m</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((m &amp; <span class=\"number\">1</span>) &amp;&amp; nums[m] == nums[m<span class=\"number\">-1</span>])&#123; <span class=\"comment\">// 奇数</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!(m &amp; <span class=\"number\">1</span>) &amp;&amp; nums[m] == nums[m+<span class=\"number\">1</span>])&#123; <span class=\"comment\">// 偶数</span></span><br><span class=\"line\">                l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p></li>\r\n<li><p>上述思想可以在代码层面进行简化<code>m ^ 1</code>，对于偶数表示<code>m + 1</code>；对于奇数表示<code>m - 1</code>，同时照顾到短板，每次更新<code>l</code>时，有<code>l = m + 1</code></p></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[m] == nums[m ^ <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 这是技巧</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"官方的偶数范围二分查找\">官方的偶数范围二分查找</h2>\r\n<ul>\r\n<li>X的下标一定是偶数 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">            m -= m &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 变为偶数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[m] == nums[m + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// [...m+1]都ok</span></span><br><span class=\"line\">                l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n","tags":["算法","特殊"]},{"title":"二叉树最大和","url":"/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"<h1 id=\"二叉树中的最大路径和\">1. 124 <a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">二叉树中的最大路径和</a></h1>\r\n<h3 id=\"两个递归的笨方法\">1.1 两个递归的笨方法</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span> </span>&#123; <span class=\"comment\">// 找到以root为起点，深入向下的最大路径一条线（分叉只走一条）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">core</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(lv, rv), <span class=\"number\">0</span>) + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion</span><span class=\"params\">(TreeNode* root)</span></span>&#123; <span class=\"comment\">// 遍历树中每个结点，尝试寻找本题答案的“起点根”</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">core</span>(root-&gt;left); <span class=\"comment\">// 以左孩子为起点的“线”</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">core</span>(root-&gt;right); <span class=\"comment\">// 以右孩子为起点的“线”</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lv &lt; <span class=\"number\">0</span>) lv = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rv &lt; <span class=\"number\">0</span>) rv = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, lv + rv + root-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"一个递归的好方法\">1.2 一个递归的好方法</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 递归计算左右子节点的最大贡献值</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">max</span>(<span class=\"built_in\">core</span>(root-&gt;left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">max</span>(<span class=\"built_in\">core</span>(root-&gt;right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ifAnsRoot = root-&gt;val + lv + rv;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, ifAnsRoot);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(lv, rv) + root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"二叉树的直径\">2. 543 <a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\">二叉树的直径</a></h1>\r\n<h2 id=\"这些问题都有共性递归主线依旧所求是副产物\"><strong>这些问题都有共性：递归主线依旧，所求是副产物</strong></h2>\r\n<h3 id=\"两个递归的笨方法-1\">2.1 两个递归的笨方法</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">core</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l, r) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">diameterOfBinaryTree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">diameterOfBinaryTree</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> m = <span class=\"built_in\">core</span>(root-&gt;left) + <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(m, <span class=\"built_in\">max</span>(l, r));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"一个递归的好方法-1\">2.2 一个递归的好方法</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归主线还是算高度，直径是 [副产品]</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span></span>&#123; <span class=\"comment\">// 给定根节点，计算最长深度节点数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">core</span>(root-&gt;left); <span class=\"comment\">// 左儿子为根的子树的深度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">core</span>(root-&gt;right); <span class=\"comment\">// 右儿子为根的子树的深度</span></span><br><span class=\"line\">        res = <span class=\"built_in\">max</span>(res, l + r); <span class=\"comment\">// 在这里更新res，不用+1，因为路径长度是总结点长度-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l, r) + <span class=\"number\">1</span>; <span class=\"comment\">// 返回该节点为根的子树的最长深度节点数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","tags":["算法","树"]},{"title":"十大排序总结","url":"/2022/04/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","content":"<h1 id=\"一简单排序\">一、简单排序</h1>\r\n<h2 id=\"冒泡排序\">1. 冒泡排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(N^2)</li>\r\n<li>空间复杂度：O(1)</li>\r\n<li>稳定 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) <span class=\"built_in\">swap</span>(arr[j], arr[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"选择排序\">2. 选择排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(N^2)</li>\r\n<li>空间复杂度：O(1)</li>\r\n<li><strong>不稳定</strong>（是不是以为<code>(arr[j] &gt; arr[pos])</code>改为<code>&gt;=</code>就变成稳定的了？那看一下<code>3, 2, 1, 2</code>。所以若想选择排序稳定，需要开辟新的数组空间；或者进行大量移动位置操作；或者是对链表排序） <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n - i; ++j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; arr[pos]) pos = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[pos], arr[n - i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"插入排序\">3. 插入排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(N^2)</li>\r\n<li>空间复杂度：O(1)</li>\r\n<li>稳定 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; --j)</span><br><span class=\"line\">            arr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"二高级排序\">二、高级排序</h1>\r\n<h2 id=\"希尔排序\">4. 希尔排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(N^(4/3~3/2))复杂度非常难以估算</li>\r\n<li>空间复杂度：O(1)</li>\r\n<li><strong>不稳定</strong></li>\r\n<li>下面两个实现都一样，唯一区别就是<code>插入排序外循环里面i增加的形式，第一种分开实现，第二种合并了</code></li>\r\n</ul>\r\n<h3 id=\"实现1\">4.1 实现1</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了</span></span><br><span class=\"line\">    <span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; incre = &#123; <span class=\"number\">1023</span>, <span class=\"number\">511</span>, <span class=\"number\">255</span>, <span class=\"number\">127</span>, <span class=\"number\">63</span>, <span class=\"number\">31</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">0</span>; u &lt;incre.<span class=\"built_in\">size</span>(); ++u) &#123; <span class=\"comment\">// 增量循环</span></span><br><span class=\"line\">        <span class=\"type\">int</span> width = incre[u];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width &gt; n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v = <span class=\"number\">0</span>; v &lt; width; ++v) &#123; <span class=\"comment\">// 当前增量循环</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = width + v; i &lt; n; i += width) &#123; <span class=\"comment\">// 插入排序外循环</span></span><br><span class=\"line\">                <span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">                <span class=\"type\">int</span> j = i - width;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; j -= width) <span class=\"comment\">// 插入排序内循环</span></span><br><span class=\"line\">                    arr[j + width] = arr[j];</span><br><span class=\"line\">                arr[j + width] = cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实现2浙大陈姥姥代码\">4.2 实现2（浙大陈姥姥代码）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了</span></span><br><span class=\"line\">    <span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; incre = &#123; <span class=\"number\">1023</span>, <span class=\"number\">511</span>, <span class=\"number\">255</span>, <span class=\"number\">127</span>, <span class=\"number\">63</span>, <span class=\"number\">31</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">0</span>; u &lt; incre.<span class=\"built_in\">size</span>(); ++u) &#123; <span class=\"comment\">// 增量循环</span></span><br><span class=\"line\">        <span class=\"type\">int</span> width = incre[u];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = width; i &lt; n; ++i) &#123; <span class=\"comment\">// 插入排序外循环</span></span><br><span class=\"line\">            <span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> j = i - width;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; j -= width) <span class=\"comment\">// 插入排序内循环</span></span><br><span class=\"line\">                arr[j + width] = arr[j];</span><br><span class=\"line\">            arr[j + width] = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"堆排序\">5. 堆排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(NlogN)</li>\r\n<li>空间复杂度：O(1)</li>\r\n<li>不稳定 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">downMethod</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> f, <span class=\"type\">int</span> sz)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> s = f * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cur = arr[f];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(s &lt; sz)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[s] &lt; arr[s + <span class=\"number\">1</span>]) <span class=\"comment\">// 兄弟值大，让位</span></span><br><span class=\"line\">            ++s;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[s] &lt;= cur) <span class=\"keyword\">break</span>; <span class=\"comment\">// 父亲值大，镇压</span></span><br><span class=\"line\">        arr[f] = arr[s]; <span class=\"comment\">// 儿子值大，禅位</span></span><br><span class=\"line\">        f = s; <span class=\"comment\">// 下一代的父亲</span></span><br><span class=\"line\">        s = f * <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"comment\">// 下一代的儿子</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[f] = cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 数组形成堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; p &gt;= <span class=\"number\">0</span>; --p)</span><br><span class=\"line\">        <span class=\"built_in\">downMethod</span>(arr, p, n);</span><br><span class=\"line\">    <span class=\"comment\">// 堆首尾交换进行排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = n<span class=\"number\">-1</span>; p &gt; <span class=\"number\">0</span>; --p) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[p]);</span><br><span class=\"line\">        <span class=\"built_in\">downMethod</span>(arr, <span class=\"number\">0</span>, p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"归并排序\">6. 归并排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(NlogN)</li>\r\n<li>空间复杂度：O(N)</li>\r\n<li>稳定</li>\r\n</ul>\r\n<h3 id=\"递归版本\">6.1 递归版本</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [l, m] [m+1, r]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeTwoArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> m, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>, k = l;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= m || j &lt;= r) &#123; <span class=\"comment\">// k &lt;= r 一样</span></span><br><span class=\"line\">        <span class=\"type\">int</span> a = i &lt;= m ? arr[i] : INT_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> b = j &lt;= r ? arr[j] : INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) ++i; <span class=\"comment\">// 每次i和j只能有一个增加</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> ++j;</span><br><span class=\"line\">        trr[k++] = a &lt; b ? a : b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt;= r) &#123; <span class=\"comment\">// 拷贝回去</span></span><br><span class=\"line\">        arr[l] = trr[l];</span><br><span class=\"line\">        ++l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = l + ((r - l) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">mergeRecursion</span>(arr, trr, l, m);</span><br><span class=\"line\">    <span class=\"built_in\">mergeRecursion</span>(arr, trr, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    <span class=\"built_in\">mergeTwoArray</span>(arr, trr, l, m, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 避免频繁创建子数组</span></span><br><span class=\"line\">    <span class=\"built_in\">mergeRecursion</span>(arr, trr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"非递归版本\">6.2 非递归版本</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [l, m] [m+1, r]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeTwoArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> m, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>, k = l;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= m || j &lt;= r) &#123; <span class=\"comment\">// k &lt;= r 一样</span></span><br><span class=\"line\">        <span class=\"type\">int</span> a = i &lt;= m ? arr[i] : INT_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> b = j &lt;= r ? arr[j] : INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) ++i; <span class=\"comment\">// 每次i和j只能有一个增加</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> ++j;</span><br><span class=\"line\">        trr[k++] = a &lt; b ? a : b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不用拷贝回去...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> range = <span class=\"number\">1</span>; <span class=\"comment\">// 半径</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 避免频繁创建子数组</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (range &lt; n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i += range*<span class=\"number\">2</span>) &#123; <span class=\"comment\">// arr -&gt; trr</span></span><br><span class=\"line\">            <span class=\"type\">int</span> m = i + range - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &gt;= n - <span class=\"number\">1</span>) m = n - <span class=\"number\">1</span>; <span class=\"comment\">// 不能break</span></span><br><span class=\"line\">            <span class=\"type\">int</span> r = i + range * <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r &gt;= n - <span class=\"number\">1</span>) r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">mergeTwoArray</span>(arr, trr, i, m, r); <span class=\"comment\">// arr-&gt;trr</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        range &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i += range*<span class=\"number\">2</span>) &#123; <span class=\"comment\">// trr -&gt; arr</span></span><br><span class=\"line\">            <span class=\"type\">int</span> m = i + range - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m &gt;= n - <span class=\"number\">1</span>) m = n - <span class=\"number\">1</span>; <span class=\"comment\">// 不能break</span></span><br><span class=\"line\">            <span class=\"type\">int</span> r = i + range * <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r &gt;= n - <span class=\"number\">1</span>) r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">mergeTwoArray</span>(trr, arr, i, m, r); <span class=\"comment\">// trr-&gt;arr</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        range &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"快速排序\">7. 快速排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(NlogN)</li>\r\n<li>空间复杂度：栈上O(logN)</li>\r\n<li>不稳定</li>\r\n<li>注意1：遇到l和r指向相等时，需要交换，不然遇到全1的数组，退化为n^2</li>\r\n<li>注意2：快排在数据范围较小时（<code>r-l&lt;threshold</code>）直接使用插入排序可有效优化速度</li>\r\n</ul>\r\n<h3 id=\"实现1朴素版\">7.1 实现1（朴素版）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> oldl = l, oldr = r;</span><br><span class=\"line\">    <span class=\"comment\">// 选 [枢纽]</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\">    <span class=\"comment\">// 排序</span></span><br><span class=\"line\">    ++r;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[--r] &gt; pivot); <span class=\"comment\">// 右侧先动是安全的</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[++l] &lt; pivot); <span class=\"comment\">// 左侧后动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; r) <span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[oldl], arr[l]);</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, oldl, r - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, r + <span class=\"number\">1</span>, oldr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实现2改进朴素版\">7.2 实现2（改进朴素版）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\"><span class=\"comment\">// 改为</span></span><br><span class=\"line\"><span class=\"type\">int</span> randomPos = l + <span class=\"built_in\">rand</span>()%(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(arr[l], arr[randomPos]);</span><br><span class=\"line\"><span class=\"type\">int</span> pivot = arr[l];</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实现3中间值枢纽\">7.3 实现3（中间值枢纽）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三数选中间数并将最小值放在l，最大值放在r，中间值(pivot)放在l+1</span></span><br><span class=\"line\"><span class=\"comment\">// 陈姥姥代码里是放在r-1的，这样肯定正确因为m肯定&lt;r</span></span><br><span class=\"line\"><span class=\"comment\">// 我为了兼容朴素版的大部分代码，选择放在l+1，这样由于m可能等于l，所以需要多一次特殊点判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">median3</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = l + ((r - l) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[l] &gt; arr[m])</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[l], arr[m]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[l] &gt; arr[r])</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[m] &gt; arr[r])</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[m], arr[r]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l == m) <span class=\"keyword\">return</span> arr[l]; <span class=\"comment\">// 特殊点</span></span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[m], arr[l + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr[l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> oldl = l, oldr = r;</span><br><span class=\"line\">    <span class=\"comment\">// 选 [枢纽]</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = <span class=\"built_in\">median3</span>(arr, l, r);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 排序</span></span><br><span class=\"line\">    ++l; <span class=\"comment\">// 注意：两端收缩了一位</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[--r] &gt; pivot); <span class=\"comment\">// 右侧先动是安全的</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[++l] &lt; pivot); <span class=\"comment\">// 左侧后动</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &lt; r) <span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[oldl + <span class=\"number\">1</span>], arr[l]); <span class=\"comment\">// 注意：pivot枢纽放在了l+1位置</span></span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, oldl, r - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, r + <span class=\"number\">1</span>, oldr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实现4有限制\">7.4 实现4（有限制）</h3>\r\n<p>虽然代码看起来很简洁，但是有如下问题： 1. 极端情况会退化为n^2算法 2. 正因如此，在我的实验中，对3w个分布0~99的数字排序，会栈溢出（异常结束，main函数return 非0）。其实前面的方法里，移动i和j时如果<code>&gt;</code>改为<code>&gt;=</code>、<code>&lt;</code>改为<code>&lt;=</code>也会出现这种问题哦。因此在数据分布较窄时，这种方法无疑是低效的 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 选 [枢纽] 可改进随机化但效果还是差</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 排序</span></span><br><span class=\"line\">    <span class=\"type\">int</span> j = l;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l + <span class=\"number\">1</span>; i &lt;= r; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">            ++j;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[i], arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">swap</span>(arr[j], arr[l]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h1 id=\"三特殊排序\">三、特殊排序</h1>\r\n<h2 id=\"计数排序\">8. 计数排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(B+N)，B是数据范围一般较小，可认为是O(N)</li>\r\n<li>空间复杂度：栈上O(B+N) -&gt; O(N)</li>\r\n<li>稳定（实现的不好则不稳定，比如从前往后填） <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countingSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(maxV + <span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 计数数组</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) ++counting[e]; <span class=\"comment\">// 计数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">        counting[i] = counting[i - <span class=\"number\">1</span>] + counting[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123; <span class=\"comment\">// 从后向前填：稳定的排序</span></span><br><span class=\"line\">        <span class=\"type\">int</span> pos = --counting[arr[i]];</span><br><span class=\"line\">        trr[pos] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">        arr[i] = trr[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"基数排序\">9. 基数排序</h2>\r\n<ul>\r\n<li>时间复杂度：O(Rs * N)，Rs是数据最大值的位数一般较小，可认为是O(N)</li>\r\n<li>空间复杂度：栈上O(10 + N) -&gt; O(N)</li>\r\n<li>稳定（实现的不好则不稳定，比如从前往后填）</li>\r\n<li>经常利用计数排序实现</li>\r\n</ul>\r\n<h3 id=\"lsd基数排序\">9.1 LSD基数排序</h3>\r\n<ol type=\"1\">\r\n<li>最低位优先(Least Significant Digit first, LSD)，先排低位；再排高位</li>\r\n<li>由于每一位介于0~9，所以对每一个基位排序时都可看做是分为10个桶的桶排序 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得一个int的某一位的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getRadix</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> radices[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span>, <span class=\"number\">100000000</span>, <span class=\"number\">1000000000</span> &#125;;</span><br><span class=\"line\">    num %= radices[r + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num / radices[r];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixSortLSD</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">    <span class=\"type\">int</span> radixNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (maxV) &#123;</span><br><span class=\"line\">        ++radixNum;</span><br><span class=\"line\">        maxV /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> r = <span class=\"number\">0</span>; r &lt; radixNum; ++r) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>; <span class=\"comment\">// 计数数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) ++counting[<span class=\"built_in\">getRadix</span>(e, r)]; <span class=\"comment\">// 计数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">            counting[i] = counting[i - <span class=\"number\">1</span>] + counting[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> pos = --counting[<span class=\"built_in\">getRadix</span>(arr[i], r)];</span><br><span class=\"line\">            trr[pos] = arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">            arr[i] = trr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h3 id=\"msd基数排序\">9.2 MSD基数排序</h3>\r\n<ul>\r\n<li>最高位优先(Most Significant Digit first, MSD)，先排高位；再排低位</li>\r\n<li>MSD一般采用递归写法：按高位分组，形成连续区段，然后在区段内递归处理低一位 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得一个int的某一位的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getRadix</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> radices[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span>, <span class=\"number\">100000000</span>, <span class=\"number\">1000000000</span> &#125;;</span><br><span class=\"line\">    num %= radices[r + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num / radices[r];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r, <span class=\"type\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (l &gt;= r || d &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i) </span><br><span class=\"line\">        ++counting[<span class=\"built_in\">getRadix</span>(arr[i], d)]; <span class=\"comment\">// l~r 计数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) </span><br><span class=\"line\">        counting[i] = counting[i - <span class=\"number\">1</span>] + counting[i]; <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = r; i &gt;= l; --i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pos = --counting[<span class=\"built_in\">getRadix</span>(arr[i], d)] + l; <span class=\"comment\">// + l 偏移别忘了</span></span><br><span class=\"line\">        trr[pos] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">        arr[i] = trr[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"built_in\">radixRecursion</span>(arr, trr, l, l + counting[<span class=\"number\">0</span>] - <span class=\"number\">1</span>, d - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">radixRecursion</span>(arr, trr, l + counting[i - <span class=\"number\">1</span>], l + counting[i] - <span class=\"number\">1</span>, d - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">    <span class=\"type\">int</span> radixNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (maxV) &#123;</span><br><span class=\"line\">        ++radixNum;</span><br><span class=\"line\">        maxV /= <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">radixRecursion</span>(arr, trr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, radixNum<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"桶排序\">10. 桶排序</h2>\r\n<ul>\r\n<li>桶排序的时间复杂度和空间复杂度以及是不是稳定都看你采取的子排序算法</li>\r\n<li>桶排序一般用于数据<strong>分布均匀</strong>的</li>\r\n<li>桶排序用于遏制N^2、NlogN等复杂度的算法因数据量太大而带来的速度问题 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; --j)</span><br><span class=\"line\">            arr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">    ++maxV;</span><br><span class=\"line\">    <span class=\"type\">int</span> bckNum = <span class=\"number\">10</span>; <span class=\"comment\">// 分十个桶</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">buckets</span>(bckNum, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> pos = e * <span class=\"number\">10</span> / maxV;</span><br><span class=\"line\">        buckets[pos].<span class=\"built_in\">push_back</span>(e); <span class=\"comment\">// 放进桶里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; b : buckets) &#123; <span class=\"comment\">// 随意选取排序算法</span></span><br><span class=\"line\">        <span class=\"built_in\">insertSort</span>(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; buckets.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; buckets[i].<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">            arr[k++] = buckets[i][j]; <span class=\"comment\">// 从桶里面拿出来</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"四辅助代码\">四、辅助代码</h1>\r\n<ul>\r\n<li>获取数据、判断排序合格、显示已排序frontN等 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Data</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Data</span>(string fn, <span class=\"type\">int</span> _n) : <span class=\"built_in\">arr</span>(_n) &#123;</span><br><span class=\"line\">        fstream file;</span><br><span class=\"line\">        file.<span class=\"built_in\">open</span>(fn, ios::in);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!file) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">string</span>(<span class=\"string\">&quot;ERROR!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr)</span><br><span class=\"line\">            file &gt;&gt; e;</span><br><span class=\"line\">        file.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt;&amp;&amp; <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">move</span>(arr); &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSorted</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (arr[i] &lt; arr[i - <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showFrontN</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    n = n &gt; arr.<span class=\"built_in\">size</span>() ? arr.<span class=\"built_in\">size</span>() : n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n;) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; cnt &lt; <span class=\"number\">10</span> &amp;&amp; i + cnt &lt; n; ++cnt) <span class=\"comment\">// 每行十列显示</span></span><br><span class=\"line\">            cout &lt;&lt; arr[i + cnt] &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\">        i += cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Data <span class=\"title\">dataGenerator</span><span class=\"params\">(<span class=\"string\">&quot;Data.txt&quot;</span>, <span class=\"number\">1000</span>)</span></span>;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr = dataGenerator.<span class=\"built_in\">getData</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// yourSort(arr);</span></span><br><span class=\"line\">    <span class=\"built_in\">showFrontN</span>(arr, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isSorted</span>(arr)) cout &lt;&lt; <span class=\"string\">&quot;排序完成&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&quot;排序出错&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n","tags":["算法","排序"]},{"title":"右值引用详解","url":"/2022/04/08/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/","content":"<h1 id=\"问题\">问题</h1>\r\n<ol type=\"1\">\r\n<li>临时对象非必要的昂贵的拷贝操作</li>\r\n<li>在模板函数中如何按照参数的实际类型进行转发</li>\r\n</ol>\r\n<ul>\r\n<li>关键字：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义、完美转发</li>\r\n<li>以下用四条代码来阐述C++的右值引用及其思想</li>\r\n</ul>\r\n<h1 id=\"第一行代码\">1. 第一行代码</h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"built_in\">getVal</span>();</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>上式代码会产生一个左值和纯右值，<strong>右值是不具名的，判断左值和右值的办法就是看能否取地址</strong></li>\r\n<li>在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。</li>\r\n</ul>\r\n<h1 id=\"第二行代码\">2. 第二行代码</h1>\r\n<h2 id=\"特点1重获新生\">2.1 特点1：重获新生</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">T <span class=\"title\">getVal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">T</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">T k = <span class=\"built_in\">getVal</span>();     <span class=\"comment\">// F1</span></span><br><span class=\"line\">T&amp;&amp; k = <span class=\"built_in\">getVal</span>();   <span class=\"comment\">// F2</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>F1：调用一次默认构造、两次拷贝构造（一次函数内到函数外的临时值，一次临时值到k）</li>\r\n<li>F2：调用一次默认构造、一次拷贝构造（一次函数内到函数外的临时值，并且临时值通过右值引用<strong>重获新生</strong>）</li>\r\n<li>现代编译器进行了优化，可能仅仅调用一次默认构造，但这不是C++标准</li>\r\n<li>当然在C++98/03年代，为了相同的目的，可以用常量左值引用这种万能引用：<code>const T&amp; k = getVal();</code>，也能达到减少一次拷贝构造的目的，但是k不能再改变了。</li>\r\n</ul>\r\n<h2 id=\"特点2右值引用二相性\">2.2 特点2：右值引用“二相性”</h2>\r\n<ul>\r\n<li>右值引用独立于左值和右值，即，右值引用类型的变量可能是左值也可能是右值，例如： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; val = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></li>\r\n<li><strong>val类型为右值引用，但val本身是左值</strong>，所有具名变量都是左值 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// t是右值 T&amp;&amp; t = 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">f</span>(x);  <span class=\"comment\">// t是左值 (T&amp;)&amp;&amp; t = x，折叠后变为T&amp; t = x;</span></span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"特点3通用引用universal-references\">2.3 特点3：通用引用(universal references)</h2>\r\n<ul>\r\n<li>T&amp;&amp; t在<strong>发生自动类型推断</strong>的时候，它是通用引用类型</li>\r\n<li>通用引用是需要初始化的，如果是左值，那就归为左值引用，如果是右值，那就归为右值引用。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意上述关键词：&quot;发生自动类型推断&quot;时</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp;&amp; b = a;  <span class=\"comment\">// b类型为左值引用 (int&amp;)&amp;&amp; b -&gt; int&amp; b = a</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp;&amp; c = <span class=\"number\">10</span>; <span class=\"comment\">// c类型为右值引用 int&amp;&amp; b = 10</span></span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"引用折叠\"><strong>引用折叠</strong></h3>\r\n<ol type=\"1\">\r\n<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用\r\n<ul>\r\n<li>类型 T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li>\r\n</ul></li>\r\n<li>所有的其他引用类型之间的叠加都将变成左值引用\r\n<ul>\r\n<li>T&amp; &amp;、T&amp; &amp;&amp; 和 T&amp;&amp; &amp; 都会折叠成类型 T&amp;</li>\r\n</ul></li>\r\n</ol>\r\n<h1 id=\"第三行代码\">3. 第三行代码</h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; a) : <span class=\"built_in\">m_val</span>(a.m_val) &#123; a.m_val=<span class=\"literal\">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>即，移动构造函数(move constructor)，采用浅拷贝的方式，因为某些临时变量如果没有移动构造函数，则会频繁发生拷贝构造（深拷贝），如果对象内部堆空间很大的话，代价会非常大</li>\r\n<li>这里介绍move语句，move语句会将一个左值变为一个右值类型。<code>move(val)</code>后，并不会对val本身做出改变。类似上面的代码，将<code>move(val)</code>交给一个构造函数或者一个赋值函数，那么会按照右值类型匹配对应的移动构造函数和移动赋值函数，在移动函数里会将<code>val</code>的资源指针交给别人，<code>val</code>自身资源指针指向<code>nullptr</code>，这个时候<code>val</code>才会发生改变（你在代码里<code>move(val)</code>一百次，但是不交给对应函数匹配处理，那么<code>val</code>就不会有一丁点的变化）。当然，这些操作别人已经实现好了，如果是你自己的类，要自己实现！</li>\r\n</ul>\r\n<h1 id=\"第四行代码\">4. 第四行代码</h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">foo</span>(std::forward&lt;T&gt;(val));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"c11前调用模板函数的问题\">4.1 C++11前，调用模板函数的问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">processValue</span>(val); <span class=\"comment\">// 右值参数会变成左值传递给processValue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>因此引入了完美转发<code>std::forward</code>，他会按照参数的实际类型进行转发 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span>&#123; cout &lt;&lt; <span class=\"string\">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; a)</span></span>&#123; cout &lt;&lt; <span class=\"string\">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 照参数本来的类型进行转发。</span></span><br><span class=\"line\">    <span class=\"built_in\">processValue</span>(std::forward&lt;T&gt;(val)); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Testdelcl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    forwardValue(i); <span class=\"comment\">// 传入左值 输出：lvaue </span></span><br><span class=\"line\">    forwardValue(<span class=\"number\">0</span>); <span class=\"comment\">// 传入右值 暑促和：rvalue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li>T&amp;&amp;是一个通用引用(universal references)，可以接受左值或者右值，正是这个特性让他适合作为一个参数的<strong>路由</strong>，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。</li>\r\n</ul>\r\n<h2 id=\"进一步体会完美转发\">4.2 进一步体会完美转发</h2>\r\n<h3 id=\"问题-1\">4.2.1 问题</h3>\r\n<ul>\r\n<li><code>func</code>函数接收的<code>v2</code>是引用，但是引用的却是<code>middle</code>里面的一个局部变量<code>t2</code>，而非<code>main</code>中的<code>t2</code>，应该怎么办？ <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1 t1, T2 t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">f</span>(t1, t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;  <span class=\"comment\">// v2 是一个引用</span></span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">    ++v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">42</span>, i);</span><br><span class=\"line\">    <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">    <span class=\"built_in\">middle</span>(func, <span class=\"number\">42</span>, i);</span><br><span class=\"line\">    <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"尝试\">4.2.2 尝试</h3>\r\n<ul>\r\n<li><code>middle</code>中<code>t1</code>类型是<code>int&amp;&amp;</code>，<code>t2</code>类型是<code>int&amp; &amp;&amp; -&gt; int&amp;</code>，<code>i</code>的值也如预期般变化 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">f</span>(t1, t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;  <span class=\"comment\">// v2 是一个引用</span></span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">    ++v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(<span class=\"number\">42</span>, i);</span><br><span class=\"line\">    <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">    <span class=\"built_in\">middle</span>(func, <span class=\"number\">42</span>, i);</span><br><span class=\"line\">    <span class=\"comment\">// here i = 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li>虽然看似没毛病，但是我们改一下<code>func</code>，就会暴露问题，修改func如下： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;</span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">    ++v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li>修改<code>func</code>后再用4.2.2的代码运行就会报错，提示：“无法将一个右值引用绑定到左值上”，why？因为，在<code>main</code>中42虽然是右值，传入到<code>middle</code>后<code>t1</code>的类型也确实是<code>int&amp;&amp;</code>，但是<code>t1</code>本身作为具名变量，它是一个左值！而左值是无法与右值进行绑定的。</li>\r\n</ul>\r\n<h3 id=\"解决\">4.2.3 解决</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">f</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><code>forward</code>就是解决以上问题的关键</li>\r\n<li><code>42</code>传入<code>middle</code>后绑定到<code>t1</code>，此时t1类型是<code>int&amp;&amp;</code>（其中<code>T1</code>是<code>int</code>）。通过<code>forward&lt;T1&gt;(t1) -&gt; forward&lt;int&gt;(t1)</code>，将返回<code>int&amp;&amp;</code>成功传给func函数。这里你肯定有疑问，刚才不就是<code>int&amp;&amp;</code>？你绕一大圈子是不是耍人？其实不然，之前的那个啊叫named rvalue，有名字，传参时被当成左值！现在通过<code>forward</code>返回的是无名字的真正的右值，从而右值得到了保留！</li>\r\n<li><code>i</code>传入<code>middle</code>后绑定到<code>t2</code>，此时t2类型为<code>int&amp; &amp;&amp;</code>（其中<code>T2</code>是<code>int&amp;</code>，why？因为<code>T2</code>如果是<code>int</code>，那么就变成<code>int&amp;&amp; t2 = i</code>，会导致右值绑定一个左值从而报错！）经过引用折叠变为<code>int&amp;</code>.通过<code>forward&lt;T2&gt;(t2) -&gt; forward&lt;int&amp;&gt;(t2)</code>，将返回一个<code>int&amp; &amp;</code>，折叠后变为<code>int&amp;</code>，左值也得到了保留！</li>\r\n</ul>\r\n<h2 id=\"应用泛型工厂函数\">4.3 应用：泛型工厂函数</h2>\r\n<p>利用forward可以实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>…  Args&gt;</span></span><br><span class=\"line\"><span class=\"function\">T* <span class=\"title\">Instance</span><span class=\"params\">(Args&amp;&amp;… args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">T</span>(std::forward&lt;Args &gt;(args)…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> - 这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。</p>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<ul>\r\n<li><a href=\"https://www.cnblogs.com/qicosmos/p/4283455.html#:~:text=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%98%AFC,%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E3%80%82\">博客园qicosmos(江南)</a></li>\r\n<li><a href=\"https://www.guodong.plus/2020/0314-132811/\">Dong's Blog</a></li>\r\n</ul>\r\n","tags":["C/C++"]},{"title":"子集组合排列","url":"/2022/03/20/%E5%AD%90%E9%9B%86%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97/","content":"<h1 id=\"零.-子集组合和排列问题汇总\">零. 子集、组合和排列问题汇总</h1>\r\n<ul>\r\n<li>组合问题和子集问题是等价的</li>\r\n<li>参考<a href=\"https://labuladong.gitee.io/algo/4/30/110/\">labuladong</a>和优秀题解</li>\r\n</ul>\r\n<h1 id=\"一.-子集问题\">一. 子集问题</h1>\r\n<h2 id=\"子集划分\">78 <a href=\"https://leetcode-cn.com/problems/subsets/\">子集划分</a></h2>\r\n<h3 id=\"子集扩张\">1.1 子集扩张</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;(<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">        <span class=\"type\">int</span> last = nums.<span class=\"built_in\">back</span>(); nums.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; sub = <span class=\"built_in\">subsets</span>(nums);</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = sub.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;sz; ++i)&#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; tmp = sub[i];</span><br><span class=\"line\">            tmp.<span class=\"built_in\">push_back</span>(last);</span><br><span class=\"line\">            sub.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯1\">1.2 回溯1</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        cur.<span class=\"built_in\">push_back</span>(nums[pos]);</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, pos+<span class=\"number\">1</span>);</span><br><span class=\"line\">        cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, pos+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯2\">1.3 回溯2(★)</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">traceback</span>(nums, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"子集划分ⅱ\">90 <a href=\"https://leetcode-cn.com/problems/subsets-ii/\">子集划分Ⅱ</a></h2>\r\n<ol type=\"1\">\r\n<li>两条值相同的相邻树枝会产生重复，如果<strong>一个节点</strong>有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历（不能让队员越权）</li>\r\n<li><strong>“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。</strong> 我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。（注意：这里的同一树层指的是由同一个父节点引出的子节点，叔伯的子节点可以用相同下一个值，比如下图[1]接2和[2]接2，都可以用2；但是[1]接2就不能接2'了！）</li>\r\n</ol>\r\n<figure>\r\n<img src=\"https://labuladong.gitee.io/algo/images/排列组合/9.jpeg\" alt=\"labuladong图示 LC-90\" /><figcaption aria-hidden=\"true\">labuladong图示 LC-90</figcaption>\r\n</figure>\r\n<h3 id=\"回溯1-1\">2.1 回溯1</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(<span class=\"type\">bool</span> choosePre, <span class=\"type\">int</span> pos, vector&lt;<span class=\"type\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos == nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">false</span>, cur + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 要在 [选] 之前执行，要在 [不选] 之后执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!choosePre &amp;&amp; pos &gt; <span class=\"number\">0</span> &amp;&amp; nums[pos - <span class=\"number\">1</span>] == nums[pos]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        cur.<span class=\"built_in\">push_back</span>(nums[pos]);</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">true</span>, pos + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">        cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">false</span>, <span class=\"number\">0</span>, nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯2-1\">2.2 回溯2(★)</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// i从pos开始，天然可以判定同一父节点的子节点们不会重复</span></span><br><span class=\"line\">            <span class=\"comment\">// 即只让重复段的第一个节点的树向下生长</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i从0开始，无法确定pos-1位置是否使用过，需要</span></span><br><span class=\"line\">            <span class=\"comment\">// 借助一个used数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; pos &amp;&amp; nums[i] == nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 要排序</span></span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯2易读版利用used判断树层重复\">2.3 回溯2（易读版利用used判断树层重复）</h3>\r\n<p>也可用used数组来简化理解，<code>nums[i]</code>与<code>nums[i-1]</code>相等，且<code>nums[i-1]</code>没有使用的情况下，表明重复了，因为只有在<code>nums[i-1]</code>用过之后才会不用，而<code>nums[i-1]</code>之前用过，其后的子树是已经加入到结果了，即可跳过当前点 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = pos; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// used[i-1] == true，说明同一树支nums[i-1]使用过</span></span><br><span class=\"line\">            <span class=\"comment\">// used[i-1] == false，说明同一树层nums[i-1]使用过</span></span><br><span class=\"line\">            <span class=\"comment\">// 而我们要对同一树层使用过的元素进行跳过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; !used[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(nums, i + <span class=\"number\">1</span>, used);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 去重需要排序</span></span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\r\n<h1 id=\"二.-组合问题\">二. 组合问题</h1>\r\n<h2 id=\"组合总数\">39 <a href=\"https://leetcode-cn.com/problems/combination-sum/\">组合总数</a></h2>\r\n<h3 id=\"回溯\">1.1 回溯</h3>\r\n<p>nums中的每个数字可以多次使用 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i, target-nums[i]); <span class=\"comment\">// 依旧传入i</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"组合总数ⅱ\">2. 40 <a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">组合总数Ⅱ</a></h2>\r\n<p>nums中的每个数字在每个组合中只能使用一次 &amp;&amp; 解集不能包含重复的组合。</p>\r\n<p>说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 candidates 中所有和为 target 的子集。</p>\r\n<h3 id=\"回溯1-2\">2.1 回溯1</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target, <span class=\"type\">bool</span> preUsed)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos &gt;= nums.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>; <span class=\"comment\">// 不能放前面</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[pos] &gt; target) <span class=\"keyword\">return</span>; <span class=\"comment\">// 剪枝：当前和后面的不可能会选</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, pos+<span class=\"number\">1</span>, target, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos&gt;<span class=\"number\">0</span> &amp;&amp; nums[pos<span class=\"number\">-1</span>] == nums[pos] &amp;&amp; !preUsed) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        cur.<span class=\"built_in\">push_back</span>(nums[pos]);</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, pos+<span class=\"number\">1</span>, target - nums[pos], <span class=\"literal\">true</span>);</span><br><span class=\"line\">        cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯2-2\">2.2 回溯2(★)</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;pos &amp;&amp; nums[i<span class=\"number\">-1</span>] == nums[i]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 值相同的树枝，只遍历第一条，防止重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; nums[i]) <span class=\"keyword\">return</span>; <span class=\"comment\">// 剪枝：当前和后面的不可能会选</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i+<span class=\"number\">1</span>, target-nums[i]);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"三.-排列问题\">三. 排列问题</h1>\r\n<h2 id=\"全排列\">1. 46 <a href=\"https://leetcode-cn.com/problems/permutations/\">全排列</a></h2>\r\n<p>不含重复数字的数组：nums，经典回溯 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permute</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"全排列ⅱ\">2. 47 <a href=\"https://leetcode-cn.com/problems/permutations-ii/\">全排列Ⅱ</a></h2>\r\n<p>含有重复数字的数组：nums</p>\r\n<h3 id=\"哈希有意思\">2.1 哈希（有意思）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; hash, vector&lt;<span class=\"type\">int</span>&gt;&amp; cur, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == n)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;::iterator itr=hash.<span class=\"built_in\">begin</span>(); itr!=hash.<span class=\"built_in\">end</span>(); ++itr)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(itr-&gt;second)&#123;</span><br><span class=\"line\">                --itr-&gt;second;</span><br><span class=\"line\">                cur.<span class=\"built_in\">push_back</span>(itr-&gt;first);</span><br><span class=\"line\">                <span class=\"built_in\">traceback</span>(hash, cur, n);</span><br><span class=\"line\">                cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                ++itr-&gt;second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permuteUnique</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; hash;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> e: nums) ++hash[e];</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(hash, cur, nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"回溯跟子集问题2.3很像\">2.2 回溯(跟子集问题2.3很像)</h3>\r\n<p>当出现重复元素时，比如输入 nums = [1,2,2',2'']，2' 只有在 2 已经被使用的情况下才会被选择，2'' 只有在 2' 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// i从0开始，固定相同的元素在排列中的相对位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>] &amp;&amp; !used[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permuteUnique</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 必须排序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法"]},{"title":"字符串匹配","url":"/2022/04/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","content":"<h1 id=\"bfbrute-force算法\">BF(Brute Force)算法</h1>\r\n<ul>\r\n<li>BF是最符合人类直觉的字符串匹配算法，但是主串的下标<code>i</code>经常要往回走，无法利用已匹配信息，效率不够好 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bruteForce</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// i和j都是非负数，所以可以和无符号直接比较</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; t.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; p.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t[i] == p[j]) &#123;</span><br><span class=\"line\">            ++i; ++j;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            i = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">            j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"kmp算法\">KMP算法</h1>\r\n<ul>\r\n<li>思想：“利用已部分匹配的信息，保持<code>i</code>指针不回溯，通过修改<code>j</code>指针，让模式串尽量移动到有效的位置”</li>\r\n<li>定义<code>next</code>数组： <code>next[j] = d</code> 表示当 <code>t[i] != p[j]</code> 时，<code>j</code>下一次匹配的位置。注意到，下标从0开始，<code>d</code>值实际上是下标<code>j</code>前的<strong>最长前后缀子串</strong>的<strong>长度</strong></li>\r\n<li>求取<code>next</code>的过程本身就是<code>p</code>串与自己匹配的过程\r\n<ol type=\"1\">\r\n<li>当 <code>p[i]==p[j]</code> ，则 <code>p[++i] = ++j</code></li>\r\n<li>当 <code>p[i]!=p[j]</code> ，则利用前面已求得的<code>next</code>数组，<code>j=next[j]</code> ；直到无法找到，此时 <code>j=-1</code> ，自动进入第一个<code>if</code>语句，此时<code>i</code>往后走一步，妙 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// !!! i &lt; n 则会在下面越界，因为0已经求过了，循环只会进行n-1次</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || p[i] == p[j]) &#123;</span><br><span class=\"line\">            ++i, ++j;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; next = <span class=\"built_in\">getNext</span>(p);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = t.<span class=\"built_in\">size</span>(), m = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// !!! j可以为负数，和无符号比较会转换为无符号比较法(南辕北辙)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || t[i] == p[j]) &#123;</span><br><span class=\"line\">            ++i; ++j;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ol></li>\r\n</ul>\r\n<h1 id=\"kmp之next优化\">KMP之Next优化</h1>\r\n<ul>\r\n<li>比如<code>[ A B A B ]</code>这个串，按照上面所述KMP得到的结果是<code>[-1, 0, 0, 1]</code>，然而，例如匹配的是<code>[ A B A B D E]</code>，在下标为<code>3</code>处失败了，<code>next</code>指导去下标<code>1</code>处继续匹配，但是，下标<code>1</code>和下标<code>3</code>都是<code>B</code>，没有必要再进行比较了。诸如此类的例子还有<code>[ A A A A B]</code>，用上述KMP得到的<code>next</code>是<code>[-1, 0, 1, 2, 3]</code></li>\r\n<li>方法就是在 <code>++i, ++j</code> 后加一步判断，本来直接 <code>next[i]=j</code> 但是如果 <code>p[i]==p[j]</code> 则如果以后匹配 <code>p[i]</code> 失败，则匹配 <code>p[j]</code> 肯定也失败啊，所以如果两者相等，直接 <code>next[i] = next[j]</code> 。此时的结果对于<code>[ A B A B ]</code>产生的是<code>[-1, 0, -1, 0]</code>；对于<code>[ A A A A B]</code>产生的是<code>[-1, -1, -1, -1, 3]</code></li>\r\n<li>加三行代码就行了 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || p[i] == p[j]) &#123;</span><br><span class=\"line\">            ++i, ++j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p[i] == p[j]) <span class=\"comment\">// new </span></span><br><span class=\"line\">                next[i] = next[j]; <span class=\"comment\">// new </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">// new</span></span><br><span class=\"line\">                next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; next = <span class=\"built_in\">getNext</span>(p);</span><br><span class=\"line\">    <span class=\"type\">int</span> n = t.<span class=\"built_in\">size</span>(), m = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || t[i] == p[j]) &#123;</span><br><span class=\"line\">            ++i; ++j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            j = next[j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"参考资料\">参考资料</h1>\r\n<ul>\r\n<li>博客园博主：<a href=\"https://www.cnblogs.com/dusf/p/kmp.html\">sofu6</a></li>\r\n</ul>\r\n","tags":["算法","特殊"]},{"title":"带限制的最短路","url":"/2022/09/07/%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF/","content":"<p><a href=\"https://leetcode.cn/problems/cheapest-flights-within-k-stops/\">带限制的最短路</a></p>\r\n<h2 id=\"错误示例dijkstra\">错误示例（Dijkstra）</h2>\r\n<p>全局的dist记录着最短距离，但它并未记录是几跳获得的。例如，到达终点的前一跳，从<code>X-&gt;dst</code>，我的代码中只限制了到达<code>X</code>最多k+1跳，此时更新了<code>dist[X]</code>，当更新到<code>dst</code>时，利用的<code>dist[X]</code>是经过k跳的<code>X</code>作为跳板，则结果是经过了<code>k+2</code>跳，超出了限制，因此结果必然是错误的。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Item</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> node, skip, dis;</span><br><span class=\"line\">    <span class=\"built_in\">Item</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c):<span class=\"built_in\">node</span>(a),<span class=\"built_in\">skip</span>(b),<span class=\"built_in\">dis</span>(c)&#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Item&amp; R) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;dis &gt; R.dis;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; flights, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">g</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : flights) g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(&#123; e[<span class=\"number\">1</span>], e[<span class=\"number\">2</span>] &#125;);</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INF)</span></span>;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        priority_queue&lt;Item, vector&lt;Item&gt;, greater&lt;Item&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">emplace</span>(src, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> node = cur.node;</span><br><span class=\"line\">            <span class=\"type\">int</span> dis = cur.dis;</span><br><span class=\"line\">            <span class=\"type\">int</span> skip = cur.skip;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skip &gt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : g[node]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> w_node = e.first;</span><br><span class=\"line\">                <span class=\"type\">int</span> w_weight = e.second;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dist[w_node] &gt; dist[node] + w_weight) &#123;</span><br><span class=\"line\">                    dist[w_node] = dist[node] + w_weight;</span><br><span class=\"line\">                    pq.<span class=\"built_in\">emplace</span>(w_node, skip + <span class=\"number\">1</span>, dist[w_node]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[dst];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"再次尝试dijkstra完全没必要\">再次尝试Dijkstra（完全没必要）</h2>\r\n<p>需要扔掉dist，在自定义的结构体中保存dis的值，另外，每次出堆的元素的邻接节点不用判断，全部加入堆。</p>\r\n<p>值得注意的是，由于k的限制存在，堆在这道题完全没有作用，反而会有副作用：</p>\r\n<ul>\r\n<li>假如，题目要求k=0，并且答案经过的这条直接相邻的边权值巨高，则堆会将该方法引向歧途</li>\r\n<li>抑或是k的限制，根本不存在答案，需要返回-1，但是由于不加判断，堆会不停进元素，导致死循环</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Item</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> node, skip, dis;</span><br><span class=\"line\">    <span class=\"built_in\">Item</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c):<span class=\"built_in\">node</span>(a),<span class=\"built_in\">skip</span>(b),<span class=\"built_in\">dis</span>(c)&#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Item&amp; R) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;dis &gt; R.dis;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; flights, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">g</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : flights) g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(&#123; e[<span class=\"number\">1</span>], e[<span class=\"number\">2</span>] &#125;);</span><br><span class=\"line\">        priority_queue&lt;Item, vector&lt;Item&gt;, greater&lt;Item&gt;&gt; pq;</span><br><span class=\"line\">        pq.<span class=\"built_in\">emplace</span>(src, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> node = cur.node;</span><br><span class=\"line\">            <span class=\"type\">int</span> dis = cur.dis;</span><br><span class=\"line\">            <span class=\"type\">int</span> skip = cur.skip;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == dst) <span class=\"keyword\">return</span> dis;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (skip &gt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : g[node]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> w_node = e.first;</span><br><span class=\"line\">                <span class=\"type\">int</span> w_weight = e.second;</span><br><span class=\"line\">                <span class=\"comment\">// 不管，全部加入队列</span></span><br><span class=\"line\">                pq.<span class=\"built_in\">emplace</span>(w_node, skip + <span class=\"number\">1</span>, dis + w_weight);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bellman邻接矩阵\">bellman(邻接矩阵)</h2>\r\n<p><strong>Bellman Ford 核心操作需要遍历所有的边</strong></p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bf</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; g, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = g.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(g.size(), INF)</span></span>;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(dist)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                    dist[j] = <span class=\"built_in\">min</span>(dist[j], tmp[i] + g[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[dst];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; flights, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, INF));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) g[i][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : flights) g[e[<span class=\"number\">0</span>]][e[<span class=\"number\">1</span>]] = e[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">bf</span>(g, src, dst, k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret == INF ? <span class=\"number\">-1</span> : ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bellmanflights本身就是边\">bellman(flights本身就是边)</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bf</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; edg, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = edg.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(edg.size(), INF)</span></span>;</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k--) &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(dist)</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : edg) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> x = e[<span class=\"number\">0</span>], y = e[<span class=\"number\">1</span>], w = e[<span class=\"number\">2</span>];</span><br><span class=\"line\">                    dist[y] = <span class=\"built_in\">min</span>(dist[y], tmp[x] + w);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[dst];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; flights, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"built_in\">bf</span>(flights, src, dst, k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret == INF ? <span class=\"number\">-1</span> : ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"bfs\">BFS</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> INF = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findCheapestPrice</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; flights, <span class=\"type\">int</span> src, <span class=\"type\">int</span> dst, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt;&gt; <span class=\"built_in\">g</span>(n);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : flights) g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(&#123; e[<span class=\"number\">1</span>], e[<span class=\"number\">2</span>] &#125;);</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INF)</span></span>;</span><br><span class=\"line\">        queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(src);</span><br><span class=\"line\">        dist[src] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>() &amp;&amp; k-- &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(dist)</span></span>; <span class=\"comment\">// 保留上一时刻的快照</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; ++i) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> cur = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; w : g[cur]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dist[w.first] &gt; tmp[cur] + w.second) &#123; <span class=\"comment\">// dist!</span></span><br><span class=\"line\">                        dist[w.first] = tmp[cur] + w.second;</span><br><span class=\"line\">                        q.<span class=\"built_in\">push</span>(w.first); <span class=\"comment\">// 放到if里面（发生更新时才添加元素）</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist[dst] == INF ? <span class=\"number\">-1</span> : dist[dst];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","tags":["算法","图"]},{"title":"并查集","url":"/2022/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"<h1 id=\"并查集\">并查集</h1>\r\n<ul>\r\n<li>一般用于快速判断两个元素是否同属于一个集合</li>\r\n<li>数组形式表示树结构</li>\r\n<li>插入元素会被映射到从0开始的顺序整数中</li>\r\n</ul>\r\n<h1 id=\"实现技巧\">实现技巧</h1>\r\n<ul>\r\n<li>路径压缩：在find时，通过递归并返回找到的祖宗节点并赋值，可以达成find后降低树高的功效</li>\r\n<li>按秩归并：在unite时，其中一方会挂在另一方的门下，所以希望“小的挂到大的上面”，以此来产生结果高度更小的树，有两种方式：\r\n<ul>\r\n<li>高度：树高：S[Root]=-树高，代码多一步判断：即：<a href=\"https://github.com/fkjkkll/My-Algorithm/blob/master/3.3%20tree(3)/3.4%20并查集-按秩归并-高度.jpg\">两个树相同高度时，增加树高</a></li>\r\n<li>数目（推荐）：S[Root]=-元素个数。子孙节点数目，可以通过利用根节点来达成，根节点之前是-1，现在改为-n，其中n是包含根节点的整个树的节点数目</li>\r\n</ul></li>\r\n</ul>\r\n<h1 id=\"lc.990\"><a href=\"https://leetcode.cn/problems/satisfiability-of-equality-equations/\">LC.990</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UF</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">UF</span>(<span class=\"type\">int</span> _n) :<span class=\"built_in\">count</span>(_n), <span class=\"built_in\">parent</span>(_n, <span class=\"number\">-1</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> count; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> class1 = <span class=\"built_in\">find</span>(a);</span><br><span class=\"line\">        <span class=\"type\">int</span> class2 = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> class1 == class2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> class1 = <span class=\"built_in\">find</span>(a);</span><br><span class=\"line\">        <span class=\"type\">int</span> class2 = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (class1 == class2)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[class1] &lt; parent[class2]) &#123; <span class=\"comment\">// 按秩归并</span></span><br><span class=\"line\">            parent[class1] += parent[class2];</span><br><span class=\"line\">            parent[class2] = class1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            parent[class2] += parent[class1];</span><br><span class=\"line\">            parent[class1] = class2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        --count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent[pos] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[pos] = <span class=\"built_in\">find</span>(parent[pos]); <span class=\"comment\">// 路径压缩</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> count;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// leetcode 990</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">equationsPossible</span><span class=\"params\">(vector&lt;string&gt;&amp; equations)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">UF <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; equations.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (equations[i][<span class=\"number\">1</span>] == <span class=\"string\">&#x27;=&#x27;</span>) &#123;</span><br><span class=\"line\">                a.<span class=\"built_in\">unite</span>(equations[i][<span class=\"number\">0</span>] - <span class=\"number\">97</span>, equations[i][<span class=\"number\">3</span>] - <span class=\"number\">97</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; equations.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (equations[i][<span class=\"number\">1</span>] == <span class=\"string\">&#x27;!&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (a.<span class=\"built_in\">isConnected</span>(equations[i][<span class=\"number\">0</span>] - <span class=\"number\">97</span>, equations[i][<span class=\"number\">3</span>] - <span class=\"number\">97</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","tags":["算法","特殊","树"]},{"title":"拓扑排序和二分图","url":"/2022/09/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E5%9B%BE/","content":"<h2 id=\"拓扑排序有向图\">1 拓扑排序（有向图）</h2>\r\n<h3 id=\"课程表ⅱ\"><a href=\"https://leetcode.cn/problems/course-schedule-ii/\">课程表Ⅱ</a></h3>\r\n<h4 id=\"bfs易理解\">1.1 BFS（易理解）</h4>\r\n<p>创建一个表示入度的数组，初始将入度为0的节点加入队列，后续依次弹出队列，每次弹出node，减小node指向的节点的入度，入度为0的加入队列，直到队列为空，结果需要判定出队列的节点数和图的总节点数相同，不同则代表有循环</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findOrder</span><span class=\"params\">(<span class=\"type\">int</span> numCourses, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(numCourses);</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inDegree</span><span class=\"params\">(numCourses)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : prerequisites) &#123;</span><br><span class=\"line\">            g[e[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            ++inDegree[e[<span class=\"number\">0</span>]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; ret;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; ++i)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (inDegree[i] == <span class=\"number\">0</span>) q.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> node = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(node);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : g[node]) &#123;</span><br><span class=\"line\">                --inDegree[e];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (inDegree[e] == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret.<span class=\"built_in\">size</span>() == numCourses ? ret : <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"dfs\">1.2 DFS</h4>\r\n<p><strong>后序遍历的结果进行反转，就是拓扑排序的结果</strong></p>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.jpg\" alt=\"后序遍历与拓扑排序\" /><figcaption aria-hidden=\"true\">后序遍历与拓扑排序</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// visited用来减少计算量</span></span><br><span class=\"line\"><span class=\"comment\">// used用来判断成环</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; visited; <span class=\"comment\">// 不重置</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; used; <span class=\"comment\">// 每次递归，回溯重置</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; postOrder;</span><br><span class=\"line\">    <span class=\"comment\">// 判断有环，顺便记录下后序遍历的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isCircle</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; g, <span class=\"type\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (used[node]) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 有环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[node]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 优化速度（防止同一个连通集重复计算）</span></span><br><span class=\"line\">        visited[node] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        used[node] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : g[node])</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCircle</span>(g, e)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 有环直接返回</span></span><br><span class=\"line\">        postOrder.<span class=\"built_in\">push_back</span>(node); <span class=\"comment\">// 后序遍历位置（递归后面）</span></span><br><span class=\"line\">        used[node] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findOrder</span><span class=\"params\">(<span class=\"type\">int</span> numCourses, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(numCourses);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : prerequisites) g[e[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        visited.<span class=\"built_in\">resize</span>(numCourses, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        used.<span class=\"built_in\">resize</span>(numCourses, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; ++i)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isCircle</span>(g, i)) <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(); <span class=\"comment\">// 有环直接返回</span></span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(postOrder.<span class=\"built_in\">begin</span>(), postOrder.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> postOrder;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"二分图无向图\">2 二分图（无向图?）</h2>\r\n<p>图的节点只有两种颜色：红和蓝，相同颜色不能相邻，判断是否是二分图，可有两种方法：DFS和BFS</p>\r\n<h3 id=\"可能的二分法\"><a href=\"https://leetcode.cn/problems/possible-bipartition/\">可能的二分法</a></h3>\r\n<h4 id=\"dfs-1\">2.1 DFS</h4>\r\n<p>注意visited不要重置 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; visited;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; color;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">core</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; g, <span class=\"type\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        visited[node] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : g[node]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[e]) &#123;</span><br><span class=\"line\">                color[e] = !color[node];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">core</span>(g, e) == <span class=\"literal\">false</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (color[e] == color[node])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : dislikes) &#123;</span><br><span class=\"line\">            g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            g[e[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        color.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">core</span>(g, i) == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h4 id=\"bfs\">2.2 BFS</h4>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; visited;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">bool</span>&gt; color;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">core</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; g, <span class=\"type\">int</span> node)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(node);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!q.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> cur = q.<span class=\"built_in\">front</span>(); q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            visited[cur] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : g[cur]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!visited[e]) &#123;</span><br><span class=\"line\">                    color[e] = !color[cur];</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (color[e] == color[cur])</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">possibleBipartition</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">g</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : dislikes) &#123;</span><br><span class=\"line\">            g[e[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            g[e[<span class=\"number\">1</span>]].<span class=\"built_in\">push_back</span>(e[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        color.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">core</span>(g, i) == <span class=\"literal\">false</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考\">参考</h2>\r\n<ol type=\"1\">\r\n<li><a href=\"https://labuladong.github.io/algo/2/22/52/\">二分图判定算法</a></li>\r\n<li><a href=\"https://labuladong.github.io/algo/2/22/51/\">环检测及拓扑排序算法</a></li>\r\n</ol>\r\n","tags":["算法","特殊","排序","图"]},{"title":"字符串相乘","url":"/2022/03/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","content":"<h1 id=\"字符串相乘\">43 <a href=\"https://leetcode-cn.com/problems/multiply-strings/\">字符串相乘</a></h1>\r\n<p><em>两数A位和B位，相加后位数最大为<code>max(A, B)+1</code>；相乘后最大位数为<code>A+B</code></em></p>\r\n<h3 id=\"常规法\">1.1 常规法</h3>\r\n<p>将两个串的指针位置<code>m</code>和<code>n</code>、进位<code>c</code>统一放入while循环，代码就会很<strong>优美</strong>。 代码可以继续优化速度存储：addtion函数改为原地相加，但是会破坏代码的逻辑性，就不改了。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">addtion</span><span class=\"params\">(string&amp; num1, string&amp; num2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = num1.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>, n = num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        string ret;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m&gt;=<span class=\"number\">0</span> || n&gt;=<span class=\"number\">0</span> || c)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = m&gt;=<span class=\"number\">0</span> ? num1[m]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> b = n&gt;=<span class=\"number\">0</span> ? num2[n]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> s = a + b + c;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + s % <span class=\"number\">10</span>);</span><br><span class=\"line\">            c = s / <span class=\"number\">10</span>;</span><br><span class=\"line\">            --m, --n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(ret.<span class=\"built_in\">begin</span>(), ret.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 反转</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num1==<span class=\"string\">&quot;0&quot;</span> || num2==<span class=\"string\">&quot;0&quot;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        string res = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 记录表示每次乘完左移的0的个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> m = num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> n = num1.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> b = num2[m] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"function\">string <span class=\"title\">ret</span><span class=\"params\">(cnt, <span class=\"string\">&#x27;0&#x27;</span>)</span></span>; <span class=\"comment\">// 初始化&quot;左移&quot;0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n&gt;=<span class=\"number\">0</span> || c)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> a = n&gt;=<span class=\"number\">0</span> ? num1[n]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">                <span class=\"type\">int</span> s = a * b + c;</span><br><span class=\"line\">                ret.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + s % <span class=\"number\">10</span>);</span><br><span class=\"line\">                c = s / <span class=\"number\">10</span>;</span><br><span class=\"line\">                --n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(ret.<span class=\"built_in\">begin</span>(), ret.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 反转</span></span><br><span class=\"line\">            res = <span class=\"built_in\">addtion</span>(res, ret);</span><br><span class=\"line\">            --m, ++cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"优化竖式-lc高赞很难想到啊\">1.2 优化竖式 (LC高赞)(很难想到啊)</h3>\r\n<p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/LC-43-字符串相乘-1.png\" alt=\"说明图\" /> num1[i] x num2[j] 的结果为 tmp(位数为两位，\"0x\",\"xy\"的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = num1.<span class=\"built_in\">size</span>(), n = num2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">temp</span><span class=\"params\">(m+n, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 数组哦</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=m<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=n<span class=\"number\">-1</span>; j&gt;=<span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> cur = (num1[i]-<span class=\"string\">&#x27;0&#x27;</span>) * (num2[j]-<span class=\"string\">&#x27;0&#x27;</span>) + temp[i+j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                temp[i+j+<span class=\"number\">1</span>] = cur % <span class=\"number\">10</span>; <span class=\"comment\">// 存储计算结果低位 =</span></span><br><span class=\"line\">                temp[i+j] += cur / <span class=\"number\">10</span>; <span class=\"comment\">// 存储计算结果高位 +=</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        string ret; ret.<span class=\"built_in\">reserve</span>(m+n);</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&lt;temp.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 去掉前缀0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp[i] != <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&lt;temp.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 放入字符串</span></span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">char</span>(temp[i] + <span class=\"string\">&#x27;0&#x27;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法"]},{"title":"数据库小知识（持续更新）","url":"/2022/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"<h2 id=\"缓存雪崩\">1. 缓存雪崩：</h2>\r\n<p>布隆过滤器(1970)、分布式锁</p>\r\n<p>比如说双十一某宝，redis缓存中key大面积失效，导致某宝直接和数据库进行沟通，把请求直接打到数据库 解决方法：</p>\r\n<ol type=\"1\">\r\n<li>随机初始化缓存失效时间，让其不要在同一时间失效</li>\r\n<li>redis一般都是集群部署，我们把热点key放到不同的节点上去，让热点的缓存平均的分布在不同的redis节点上</li>\r\n<li>最暴力的方法：不设置缓存的失效时间，让它永远不失效，或者跑定时任务，让它定时刷这个缓存让其不失效</li>\r\n</ol>\r\n<h2 id=\"缓存穿透\">2. 缓存穿透：</h2>\r\n<p>指缓存与数据库中都没有所要请求的数据：比如请求id=-1的数据，redis没有，直接打到数据库，数据库返回空。大量的这种请求导致数据库繁忙（数据库的主键从0开始递增，没有负数） 解决方法：</p>\r\n<ol type=\"1\">\r\n<li>每次无论数据库查出什么结果，是空还是有值，都会缓存到redis里面。</li>\r\n<li>把对面IP拉黑</li>\r\n<li>对参数合法性做检测</li>\r\n<li>使用布隆过滤器（好方法）</li>\r\n</ol>\r\n<h2 id=\"缓存击穿\">3. 缓存击穿：</h2>\r\n<p>比如说某宝，某个商品秒杀(该key事先存入redis缓存)，大量用户抢购，但是某时刻该redis缓存到达失效时间失效了，一瞬间大量该key的请求打到数据库上</p>\r\n<ol type=\"1\">\r\n<li>让这个缓存永远不过期（不好）</li>\r\n<li>分布式锁：失效时某个查询数据库，然后加锁，其他的查询就不能查询数据库了，就先睡几毫米然后重新去redis里面查（好方法，实现方式有互斥锁、zookeeper、redis）</li>\r\n<li>（雪崩是多key失效，击穿是单key）</li>\r\n</ol>\r\n<h2 id=\"布隆过滤器\">4. 布隆过滤器</h2>\r\n<p>插入时利用多个hash函数映射到一串二进制数组中，从0置1；查询时，多个hash对应的二进制位置必须都是1才能证明该数据存在</p>\r\n<p>改造加强版：布谷鸟过滤器</p>\r\n<p>优点：</p>\r\n<ol type=\"1\">\r\n<li>二进制数组组成的数据，占用空间很小</li>\r\n<li>插入和查询的速度很快</li>\r\n<li>保密性很好</li>\r\n</ol>\r\n<p>缺点：</p>\r\n<ol type=\"1\">\r\n<li>很难做删除操作</li>\r\n<li>存在误判的情况（解决不了，只能减少出现的概率）</li>\r\n</ol>\r\n<p>存在就再去查一次数据库，误判也没关系；但不存在，那就是真的不存在。性能也比每次都查询数据库好得多。</p>\r\n<p>代码中可以设置误判率，但是设置太小，性能速度就变得太差了（要增大布隆过滤器二进制数组的大小以及要采用更多的hash函数）</p>\r\n<h2 id=\"索引如何查到真实数据的\">5. 索引如何查到真实数据的</h2>\r\n<p>InnoDB是聚簇索引（即将索引和数据放在一个文件里） MyISAM是非聚簇索引</p>\r\n<h3 id=\"innodb\">innodb</h3>\r\n<ul>\r\n<li>主索引树和辅助索引树</li>\r\n<li>主索引树：以主键id位key，叶子节点直接存储数据记录（一行）</li>\r\n</ul>\r\n<h3 id=\"辅助索引树\">辅助索引树：</h3>\r\n<p>例如<code>select * from user_info where user_name = 'Jim'</code>会创建以user_name为key的索引树。其叶子节点存储的是主键key，拿到key后再去主索引树去查找相应的数据（即，回表查询）</p>\r\n<h3 id=\"myisam\">MyISAM</h3>\r\n<p>无论是主键索引还是普通索引，查找数据的流程都是一样的，叶子节点存储的是数据的物理地址，拿到地址后再去内存或磁盘获得数据</p>\r\n<h3 id=\"延伸话题\">延伸话题</h3>\r\n<p>1、<a href=\"https://www.jianshu.com/p/8991cbca3854\">为什么不要使用select *，而是尽量用覆盖索引</a></p>\r\n<h2 id=\"索引为什么会失效\">6. 索引为什么会失效</h2>\r\n<p>索引失效主要针对联合索引。联合索引在B+树上的排序是按照字典序，即第一个字段、第二个字段...比如说(a, b)，只有a相同下，b才是有序的；如果a有多个值，那b基本上就无序了<code>(1, 1)(1, 2)(1, 3)(1, 4)(2, 1)(2, 2)(2, 3)(2, 4)...</code></p>\r\n<h3 id=\"最佳左前缀法则\">最佳左前缀法则</h3>\r\n<p><code>EXPLAIN SELECT * from test_user where a = 1 and b = 1</code></p>\r\n<h3 id=\"范围查找的右边它索引会失效\">范围查找的右边它索引会失效：</h3>\r\n<p><code>EXPLAIN SELECT * from test_user where a&gt;1 and b=1</code></p>\r\n<h3 id=\"like会失效\">like会失效</h3>\r\n<p><code>EXPLAIN SELECT * from test_user where a like \"1%\"</code> - \"1%\": 查找以1开头的数据 - \"%1\": 查找以1结尾的数据 - \"%1%\": 查找任意位置有1的数据</p>\r\n<h2 id=\"为什么采用b树索引\">7. 为什么采用B+树索引</h2>\r\n<h3 id=\"hash索引\">hash索引：</h3>\r\n<ol type=\"1\">\r\n<li>虽然单次的访问很快，但是是无序的，如果采用hash索引的话，无法进行范围查找以及排序操作</li>\r\n<li>存在hash碰撞问题，速度就慢下来了。</li>\r\n</ol>\r\n<h3 id=\"平衡二叉树索引\">平衡二叉树索引：</h3>\r\n<ol type=\"1\">\r\n<li>随着树深增加，查找速度逐渐变慢</li>\r\n<li>致命缺点：每次都是一个一个查找，不好进行范围查找</li>\r\n</ol>\r\n<h3 id=\"b树索引\">B树索引：</h3>\r\n<ol type=\"1\">\r\n<li>虽然解决了树高问题，但是依旧不好进行范围查找 （优点一个结点多放几个值，树可以变矮，虽然有内部查找，即一个节点内进行顺序查找的情况存在，但是内部可以理解为内存比较，不同节点可以理解为磁盘IO，内存比较就可以忽略不计了！）</li>\r\n</ol>\r\n<h3 id=\"b树索引-1\">B+树索引：</h3>\r\n<ol type=\"1\">\r\n<li>解决了范围查找问题</li>\r\n<li>最下层 [叶子节点] 采用链表的方式顺序排序，上面的 [非叶子节点] 只存储索引key，不存储数据value，因此也不会浪费很多空间，[叶子结点] 既存key也存value(数据地址)</li>\r\n<li>排序的时候要使用索引排序，因为已经排序好了，按照索引排序就不会产生文件的排序</li>\r\n</ol>\r\n","tags":["Others"]},{"title":"数组指针与指针数组","url":"/2021/09/12/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","content":"<h2 id=\"数组指针和指针数组\">数组指针和指针数组</h2>\r\n<p><code>s</code>的类型是二维数组，但是其本身也是一个一维指针（数组指针），其静态类型是<code>char(*)[10]</code>，每次移动是10个char长度也就是10字节。其解引用后静态类型是<code>char*</code>，每次移动是1个char长度也就是1字节。</p>\r\n<p>值得注意的是，类似函数指针，<code>s、*s、&amp;s</code>其值都是一样的，都是该二维数组首个元素的地址，因此不能将数组名当成是一个值为元素首地址的常规变量！因为永远无法取得其地址。</p>\r\n<p>因此，下面代码中将<code>s</code>赋值给双重指针<code>ps</code>是完全错误的；双重指针要经过两次间接跳转访问元素：比如<code>ps</code>的值为<code>0x0000ff33</code>，<code>*ps</code>首先跳转到该位置后取其值，比如说那个地址的值为<code>0x0000eedd</code>，将<code>*ps</code>当成字符串输出时，会再次跳转到地址为<code>0x0000eedd</code>的位置取出char，完全乱了。</p>\r\n<p><strong>而作为对比，数组指针解引用不会跳转，只会修改其步幅跨度</strong> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s[][<span class=\"number\">10</span>] = &#123; <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;bbb&quot;</span>, <span class=\"string\">&quot;ccc&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">char</span>** ps = (<span class=\"type\">char</span>**)s;</span><br><span class=\"line\">cout &lt;&lt; (<span class=\"keyword\">decltype</span>(*s))*ps &lt;&lt; endl;    <span class=\"comment\">// OK 强行改变了类型</span></span><br><span class=\"line\">cout &lt;&lt; *(<span class=\"built_in\">char</span>(*)[<span class=\"number\">10</span>])ps &lt;&lt; endl;    <span class=\"comment\">// OK 强行改变了类型</span></span><br><span class=\"line\">cout &lt;&lt; (<span class=\"built_in\">char</span>(&amp;)[<span class=\"number\">10</span>])*ps &lt;&lt; endl;    <span class=\"comment\">// OK 强行改变了类型</span></span><br><span class=\"line\">cout &lt;&lt; *ps &lt;&lt; endl;                <span class=\"comment\">// ERROR! 两次跳转乱了</span></span><br></pre></td></tr></table></figure></p>\r\n<p>这里<code>s</code>是一个指针数组(确定类型要从内而外，从右向左)，因此可以将其赋给双重指针，他们取char都要经过两次跳转。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* s[] = &#123; <span class=\"string\">&quot;aaa&quot;</span>, <span class=\"string\">&quot;bbb&quot;</span>, <span class=\"string\">&quot;ccc&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">char</span>** ps = (<span class=\"type\">char</span>**)s;</span><br><span class=\"line\">cout &lt;&lt; *ps &lt;&lt; endl;    <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure></p>\r\n","tags":["C/C++"]},{"title":"旋转数组二分","url":"/2022/03/21/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86/","content":"<h2 id=\"寻找峰值\">1 <a href=\"https://leetcode-cn.com/problems/find-peak-element/\">寻找峰值</a></h2>\r\n<p>找到任意一个峰值，你可以假设 nums[-1] = nums[n] = -∞ 。</p>\r\n<h3 id=\"二分法不怎么优雅\">1.1 二分法（不怎么优雅）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; nums[m<span class=\"number\">-1</span>]&gt;nums[m])</span><br><span class=\"line\">                r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m+<span class=\"number\">1</span>&lt;nums.<span class=\"built_in\">size</span>() &amp;&amp; nums[m+<span class=\"number\">1</span>]&gt;nums[m])</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 永远不会走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二分法优雅\">1.2 二分法（优雅）</h3>\r\n<p><strong>其实只要搞清楚我们「二分」什么内容，根本不会存在说用哪种方式才能写过的情况。</strong> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 这里m+1不会越界，因为l &lt;= m &lt; r，所以m-1是可能越界的，m+1必然不会越界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[m+<span class=\"number\">1</span>])</span><br><span class=\"line\">                r = m;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"搜索旋转排序数组无重复\">2 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">搜索旋转排序数组（无重复）</a></h2>\r\n<h3 id=\"二分法有点丑但好理解\">2.1 二分法（有点丑，但好理解）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 因为如果就俩数，除以二肯定l == m, r == m+1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] == nums[m])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r &lt; n &amp;&amp; nums[r] == target) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[l] &lt; nums[m])&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[m]) </span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 右边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"二分法优雅与l比较\">2.2 二分法（优雅）（与l比较）</h3>\r\n<ul>\r\n<li><strong>牢记：左区间是[l, m]，右区间是(m+1, r]，所以“左区间正常”包含等号</strong></li>\r\n<li>由于前一步 <code>if(nums[m] == target) return m;</code> 已经判定了<code>nums[m] != target</code>，所以后面对target和nums[m]的比较<strong>不带等号</strong> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] &lt;= nums[m])&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[m]) </span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 右边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"与r比较\">2022.08.10（与r比较）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while等号和不等号</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> vectorr&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] &lt; arr[r])&#123; <span class=\"comment\">// 右边正常（互不相同所以没等于）</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[l] == target ? l : <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] &lt; arr[r])&#123; <span class=\"comment\">// 右边正常（互不相同所以没等于）</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"寻找旋转排序数组中的最小值无重复\">3 <a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">寻找旋转排序数组中的最小值（无重复）</a></h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/LC-153.png\" alt=\"图解\" /><figcaption aria-hidden=\"true\">图解</figcaption>\r\n</figure>\r\n<h3 id=\"二分法\">3.1 二分法</h3>\r\n<ul>\r\n<li>如上图所示，如果每次以<code>nums[l] &lt; nums[m]</code>为条件虽然可以认定左区间是单调的，但是就全局最小值而言无法区分图1和图2的；但是以<code>nums[m] &lt; nums[r]</code>可以认定右区间单调，且可以区分所有最小值情况。一定要理解二分时收缩区间的含义。</li>\r\n<li>不能动不动<code>l = m + 1</code>，<code>r = m - 1</code>这种大起大和的方式，因为目的是求极值而不是target，target不等于的时候，某一边确实可以跳；但是求极值时，例如下面代码中<code>r = m</code>，因为不确定<code>nums[m]</code>是不是极值，所以不能写成<code>r = m - 1</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &lt; nums[r])</span><br><span class=\"line\">                r = m; <span class=\"comment\">// 注意</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<blockquote>\r\n<p>为什么左右不对称？为什么比较mid与right而不比较mid与left？能不能通过比较mid与left来解决问题？<br> 左右不对称的原因是：这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。<br> 为什么比较mid与right而不比较mid与left？具体原因前面已经分析过了，简单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。<br> 那么能不能通过比较mid与left来解决问题？能，转换思路，不直接找最小值，而是先找最大值，最大值偏右，可以通过比较mid与left来找到最大值，最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）。<br></p>\r\n</blockquote>\r\n<h2 id=\"寻找旋转排序数组中的最小值-ii有重复\">4 <a href=\"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/\">寻找旋转排序数组中的最小值 II（有重复）</a></h2>\r\n<h3 id=\"二分\">4.1 二分</h3>\r\n<p>由于相等时无法确认二分的方向，所以选择慎重地小幅度收缩1步 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] &lt; arr[r]) r = m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[m] &gt; arr[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> --r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"栈二分\">4.2 栈+二分</h3>\r\n<p>由于相等时无法确认二分的方向，所以用栈保存下来可能的区间，留作继续二分 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">        stk.<span class=\"built_in\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        stk.<span class=\"built_in\">push</span>(arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> l=<span class=\"number\">0</span>, r=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stk.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            r = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            l = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(arr[m] == arr[r])&#123;</span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(l);</span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(m<span class=\"number\">-1</span>);</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[m] &lt; arr[r])&#123;</span><br><span class=\"line\">                    r = m;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(arr[m] &gt; arr[r])&#123;</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l &lt;= r) <span class=\"comment\">// !</span></span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, arr[r]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法","特殊"]},{"title":"最长有效括号","url":"/2022/03/19/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","content":"<h1 id=\"最长有效括号\">32 <a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\">最长有效括号</a></h1>\r\n<h2 id=\"方法1动态规划\">方法1：动态规划</h2>\r\n<h3 id=\"错误1\">1.1 错误1</h3>\r\n<p><strong>无法解决诸如<code>(())</code>的问题。</strong> 要考虑到当前碰到右括号后，前面的是左括号还是右括号，然后分别进行处理</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>]; <span class=\"comment\">// BUG</span></span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"错误2\">1.2 错误2</h3>\r\n<p><strong>无法解决诸如<code>()(())</code>的问题。</strong></p>\r\n<ol type=\"1\">\r\n<li><code>*****()</code> 好解决直接 <code>dp[i] += dp[i-2];</code></li>\r\n<li><code>*****))</code> 需要额外判断找到与当前右括号<code>i</code>对应的左括号<code>t</code>，然后<code>t</code>的左边要继续判断</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span> &amp;&amp; i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;)&#x27;</span>) dp[i] += dp[i<span class=\"number\">-1</span>]; <span class=\"comment\">// 这里要继续修改</span></span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"正确答案\">1.3 正确答案</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span> &amp;&amp; i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                    dp[i] += dp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-dp[i]&gt;=<span class=\"number\">0</span>) <span class=\"comment\">//添加这里</span></span><br><span class=\"line\">                        dp[i] += dp[i-dp[i]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"官方的dplc官方elegant\">1.4 官方的DP（LC官方）(Elegant)</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 只有以&#x27;)&#x27;结尾的才有效</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i<span class=\"number\">-2</span> &lt; <span class=\"number\">0</span>) dp[i] = <span class=\"number\">2</span>; <span class=\"comment\">// 防止越界</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span>; <span class=\"comment\">// 转移函数</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span>; <span class=\"comment\">// 转移函数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        dp[i] += dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"方法2栈lc官方\">方法2：栈（LC官方）</h2>\r\n<p>保持栈底元素为当前已经遍历过的元素中 <strong>「最后一个没有被匹配的右括号的下标」</strong> 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">        stk.<span class=\"built_in\">push</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) stk.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(stk.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// 更新「最后一个没有被匹配的右括号的下标」</span></span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    res = <span class=\"built_in\">max</span>(res, i-stk.<span class=\"built_in\">top</span>()); <span class=\"comment\">// 以i结尾的有效性括号长度</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"方法3贪心lc官方\">方法3：贪心（LC官方）</h2>\r\n<p>利用两个计数器<code>l和r</code>，从左到右遍历字符串，遇到左括号则<code>l加1</code>，遇到右括号则<code>r加1</code>；当<code>l和r</code>相等时更新最长长度，当<code>r&gt;l时将l和r置0</code></p>\r\n<p>这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p>\r\n<p>解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：当<code>r&lt;l时将l和r置0</code>。</p>\r\n<p>这样我们就能涵盖所有情况从而求解出答案。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;s.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ++r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l == r) res = <span class=\"built_in\">max</span>(res, l + r);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r &gt; l) l = r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = r = <span class=\"number\">0</span>; <span class=\"comment\">// 重置！</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=s.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ++r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l == r) res = <span class=\"built_in\">max</span>(res, l + r);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; r) l = r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法","动态规划"]},{"title":"最长子序列子数组","url":"/2022/03/20/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E6%95%B0%E7%BB%84/","content":"<h1 id=\"最长公共子序列\">1143 <a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">最长公共子序列</a></h1>\r\n<ul>\r\n<li><strong>子序列是可以不连续的</strong></li>\r\n<li><strong>dp[i][j]的含义是text1[:i]和text2[:j]最长公共子序列，这个最长公共子序列不一定包含text1[i]和text2[j]</strong></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = text1.<span class=\"built_in\">size</span>(), n = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// 多一行一列</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// 别忘了坐标偏移</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i][j] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"最长重复子数组\">718 <a href=\"https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/\">最长重复子数组</a></h1>\r\n<ul>\r\n<li><strong>子数组是连续的</strong></li>\r\n<li><strong>dp[i][j]的含义是以nums1[i]结尾的nums1[:i]和以nums2[j]结尾的nums2[:j]的最长重复子数组</strong> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = nums1.<span class=\"built_in\">size</span>(), n = nums2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums1[i<span class=\"number\">-1</span>] == nums2[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">max</span>(ret, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"错误1\">错误1</h2>\r\n<p>如果里面写成这样： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums1[i<span class=\"number\">-1</span>] == nums2[j<span class=\"number\">-1</span>]) dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> dp[i][j] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[m][n];</span><br></pre></td></tr></table></figure> 则是处理非连续的“数组子序列”，对于<code>[0,1,1,1,1]和[1,0,1,0,1]</code>给出的答案是3，但是正确答案应该是2 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  <span class=\"number\">1</span>   *<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  <span class=\"number\">2</span>   *<span class=\"number\">2</span>  <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br></pre></td></tr></table></figure> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"错误2\">错误2</h2>\r\n<p>如果里面写成这样： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][j] == <span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]), dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">ret = <span class=\"built_in\">max</span>(ret, dp[i][j]);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> ret;</span><br></pre></td></tr></table></figure> 则属于<strong>彻底混淆</strong>了自己对于dp数组的定义，一定要是<strong>以nums1[i]结尾</strong>的子数组和<strong>以nums1[j]结尾</strong>的子数组的最长子数组，对于<code>[1,0,0,0,1]和[1,0,0,1,1]</code>给出的答案是4，但是正确答案应该是3 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">2</span>  <span class=\"number\">3</span>   *<span class=\"number\">3</span>  <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">4</span></span><br></pre></td></tr></table></figure> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   <span class=\"number\">1</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">3</span>   <span class=\"number\">2</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法","动态规划"]},{"title":"树状数组","url":"/2022/08/21/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"<h2 id=\"需求\">需求</h2>\r\n<ul>\r\n<li>随机修改数组中一个数字</li>\r\n<li>求前缀和</li>\r\n<li>以上操作需要频繁操作</li>\r\n</ul>\r\n<h2 id=\"预备知识lowbit\">预备知识：lowbit</h2>\r\n<p>lowbit指数字的二进制最低位1及后续0取出后的数字 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &amp; -a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 例如:10：<code>1010 &amp; 0110 = 0010</code>，即10的lowbit为2。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">x</th>\r\n<th style=\"text-align: center;\">1</th>\r\n<th style=\"text-align: center;\">2</th>\r\n<th style=\"text-align: center;\">3</th>\r\n<th style=\"text-align: center;\">4</th>\r\n<th style=\"text-align: center;\">5</th>\r\n<th style=\"text-align: center;\">6</th>\r\n<th style=\"text-align: center;\">7</th>\r\n<th style=\"text-align: center;\">8</th>\r\n<th style=\"text-align: center;\">9</th>\r\n<th style=\"text-align: center;\">10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">lowbit(x)</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">2</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p><em>注意：0不存在lowbit，所以数组的下标需要右偏移一位（使用时偏移或初始化多1位）</em></p>\r\n<h2 id=\"树状数组\">树状数组</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.gif\" alt=\"树状数组\" /><figcaption aria-hidden=\"true\">树状数组</figcaption>\r\n</figure>\r\n<ul>\r\n<li>tarr从1开始，arr从0开始</li>\r\n<li>树状数组的每一个元素<code>tarr[i]</code>：其值为<code>a[j]+...a[i-1]+a[i-1]</code>，其中连加的项总共<code>lowbit(i)</code>个</li>\r\n<li>在树状数组中，为什么需要寻找其父节点？有两个用处：1、初始化树状数组。2、修改某个数同时修改其祖上一系列树状数组的值。对于<code>tarr[i]</code>而言，其直接父节点即为<code>tarr[i + lowbit(i)]</code>，通过这种方式逐步向上迭代，即可探寻祖上一条链</li>\r\n<li>对于给定数组：<code>arr = [1,3,2,6,4,1]</code>，可得其对应的树状数组：<code>tarr = [1, 1+3, 2, 1+3+2+6, 4, 4+1] -&gt; [1, 4, 2, 12, 4, 5]</code></li>\r\n<li>求和时，例如<code>sum(idx=13)</code>\r\n<ul>\r\n<li>先得到<code>res += tarr[13]</code>，随后<code>idx -= lowbit(idx)</code>，此时<code>idx==12</code></li>\r\n<li>再得到<code>res += tarr[12]</code>，随后<code>idx -= lowbit(12)</code>，此时<code>idx==8</code></li>\r\n<li>再得到<code>res += tarr[8]</code>，随后<code>idx -= lowbit(8)</code>，此时<code>idx==0</code>结束循环</li>\r\n<li>最终，<code>res = tarr[13] + tarr[12] + tarr[8] = (arr[12]) + (arr[8]+...+arr[11]) + (arr[0]+...+arr[7])</code></li>\r\n</ul></li>\r\n<li>总之，对于树状数组<code>tarr</code>\r\n<ul>\r\n<li><code>idx += lowbit(idx)</code>是为了寻找祖上，修改和初始化用到</li>\r\n<li><code>idx -= lowbit(idx)</code>是为了求和</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"代码\">代码</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TreeArr</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">TreeArr</span>(vector&lt;<span class=\"type\">int</span>&gt; arr) :<span class=\"built_in\">arr</span>(arr), <span class=\"built_in\">tarr</span>(arr.<span class=\"built_in\">size</span>()+<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化树状数组，arr中的每个元素被加到其祖上所有节点中</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">size_t</span> idx = i + <span class=\"number\">1</span>; <span class=\"comment\">// 偏移1位</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (idx &lt; tarr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                tarr[idx] += arr[i];</span><br><span class=\"line\">                idx += <span class=\"built_in\">lowbit</span>(idx);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> diff = val - arr[i];</span><br><span class=\"line\">        <span class=\"type\">size_t</span> idx = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 修改时也要修改其祖上所有节点 + lowbit(idx)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (idx &lt; tarr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            tarr[idx] += diff;</span><br><span class=\"line\">            idx += <span class=\"built_in\">lowbit</span>(idx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[i] = val; <span class=\"comment\">// 勿忘</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> idx = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 求和时则是 - lowbit(idx)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (idx &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res += tarr[idx];</span><br><span class=\"line\">            idx -= <span class=\"built_in\">lowbit</span>(idx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getRange</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">getSum</span>(r) - <span class=\"built_in\">getSum</span>(l - <span class=\"number\">1</span>); <span class=\"comment\">//!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a &amp; -a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; tarr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考\">参考</h2>\r\n<ol type=\"1\">\r\n<li><a href=\"https://baijiahao.baidu.com/s?id=1734883051625102971&amp;wfr=spider&amp;for=pc\">什么是树状数组？让这个12岁年轻人为你讲解</a></li>\r\n<li><a href=\"https://www.jianshu.com/p/7cd5ad2f449a\">数据结构：树状数组</a></li>\r\n<li><a href=\"https://leetcode.cn/problems/range-sum-query-mutable/submissions/\">307. 区域和检索 - 数组可修改</a></li>\r\n<li><a href=\"https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/bao-li-jie-fa-fen-zhi-si-xiang-shu-zhuang-shu-zu-b/\">剑指 Offer 51. 数组中的逆序对</a></li>\r\n<li><a href=\"https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/\">315. 计算右侧小于当前元素的个数</a></li>\r\n</ol>\r\n","tags":["算法","特殊","树"]},{"title":"生成树","url":"/2022/07/20/%E7%94%9F%E6%88%90%E6%A0%91/","content":"<h1 id=\"prim从一颗小树长大\"><a href=\"https://leetcode.cn/problems/min-cost-to-connect-all-points/\">Prim</a>：从一颗小树长大</h1>\r\n<p>思路和Dijkstra基本一致，唯一不同就是dist记录的是与集合的距离而非与起点的距离 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Leetcode 1584 连接所有点的最小费用</span></span><br><span class=\"line\"><span class=\"comment\">// points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 求坐标轴上这几个点的最小生成树的路径和</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span>&#123; <span class=\"comment\">// 用来在优先队列里用</span></span><br><span class=\"line\">    <span class=\"type\">int</span> node;</span><br><span class=\"line\">    <span class=\"type\">int</span> dis;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Node&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;dis &gt; ano.dis;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minCostConnectPoints</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = points.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 节点数</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">graph</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, INT_MAX));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123; <span class=\"comment\">// 建图</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; ++j)&#123;</span><br><span class=\"line\">                graph[i][j] = <span class=\"built_in\">abs</span>(points[i][<span class=\"number\">0</span>]-points[j][<span class=\"number\">0</span>]) + <span class=\"built_in\">abs</span>(points[i][<span class=\"number\">1</span>]-points[j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                graph[j][i] = graph[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">        pq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;)); <span class=\"comment\">// 从0开始， 0到0的距离是0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!pq.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            Node cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 跟Dijkstra一样，但人家遇到终点直接可以break</span></span><br><span class=\"line\">            <span class=\"comment\">// 因为采用优先队列的方式，队列里会有重复，第一次接触的肯定是最优解，后面</span></span><br><span class=\"line\">            <span class=\"comment\">// 重复的都是大于最优解的，直接跳过，或者你用一个数组，存储对应节点最优dist</span></span><br><span class=\"line\">            <span class=\"comment\">// 每次存储比较取最小值，但是空间浪费太大了，不如这样好</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[cur.node] == <span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            dist[cur.node] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ret += cur.dis;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dist[i] &gt; graph[cur.node][i])&#123;</span><br><span class=\"line\">                    dist[i] = graph[cur.node][i];</span><br><span class=\"line\">                    pq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(&#123;i, graph[cur.node][i]&#125;));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h1 id=\"kruskal\"><a href=\"https://leetcode.cn/problems/min-cost-to-connect-all-points/\">Kruskal</a></h1>\r\n<p>利用并查集的思想 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Leetcode 1584 连接所有点的最小费用</span></span><br><span class=\"line\"><span class=\"comment\">// points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 求坐标轴上这几个点的最小生成树的路径和</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UFSet</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">UFSet</span>(<span class=\"type\">int</span> _n):<span class=\"built_in\">count</span>(_n), <span class=\"built_in\">parent</span>(_n, <span class=\"number\">-1</span>)&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> count;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unite</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> f1 = <span class=\"built_in\">find</span>(a);</span><br><span class=\"line\">        <span class=\"type\">int</span> f2 = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f1 == f2) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parent[f1] &lt; parent[f2])&#123;</span><br><span class=\"line\">            parent[f1] += parent[f2];</span><br><span class=\"line\">            parent[f2] = f1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            parent[f2] += parent[f1];</span><br><span class=\"line\">            parent[f1] = f2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        -- count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isConnected</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(a) == <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parent[pos] &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent[pos] = <span class=\"built_in\">find</span>(parent[pos]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> count; <span class=\"comment\">// 连通集的个数</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; parent;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> from;</span><br><span class=\"line\">    <span class=\"type\">int</span> to;</span><br><span class=\"line\">    <span class=\"type\">int</span> weight;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Edge&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;weight &gt; ano.weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 都不用建图，直接把边放进去就行了</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minCostConnectPoints</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = points.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">UFSet <span class=\"title\">ufs</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;i; ++j)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> weight = <span class=\"built_in\">abs</span>(points[i][<span class=\"number\">0</span>]-points[j][<span class=\"number\">0</span>]) + <span class=\"built_in\">abs</span>(points[i][<span class=\"number\">1</span>]-points[j][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Edge</span>(&#123;i, j, weight&#125;));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!pq.<span class=\"built_in\">empty</span>() &amp;&amp; cnt&lt;n<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            Edge cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ufs.<span class=\"built_in\">isConnected</span>(cur.from, cur.to) == <span class=\"literal\">false</span>)&#123; <span class=\"comment\">// from和to是图节点名，这里直接以points顺序的下标来表示</span></span><br><span class=\"line\">                ufs.<span class=\"built_in\">unite</span>(cur.from, cur.to);</span><br><span class=\"line\">                res += cur.weight;</span><br><span class=\"line\">                ++cnt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","tags":["算法","树"]},{"title":"目标检测SSD","url":"/2021/11/23/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BSSD/","content":"<blockquote>\r\n<p><strong>目标检测SSD</strong></p>\r\n</blockquote>\r\n<h3 id=\"锚框的长和宽\">1. 锚框的长和宽</h3>\r\n<h4 id=\"书上代码解析\">1.1 书上代码解析</h4>\r\n<p>s指的是长宽的缩放比例而非面积的缩放比例，比如s=0.5，则面积就是原图像的0.5^2=0.25倍。r是宽高比，指的是将原图像归一化为正方形后截取的锚框的宽高比；或者说是在原图像的宽高比基础上乘以r，才是锚框的宽高比。锚框的实际宽高比即<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.798ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.298ex\" height=\"2.398ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -707.2 2341.7 1060\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mi\" transform=\"translate(220,394) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(269.5,-345) scale(0.707)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><rect width=\"706.3\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mo\" transform=\"translate(1168.5,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1890.7,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container></span>。之所以r=1时你看到的是方形，之后会解释。 由此，可得以下方程组 <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -2.281ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"20.994ex\" height=\"5.693ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1508.2 9279.5 2516.3\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7B\" d=\"M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z\"></path></g><g data-mml-node=\"mtable\" transform=\"translate(750,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,674.2)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1374.8,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msub\" transform=\"translate(2097,0)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(3387.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(4443.1,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(502,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(5570.9,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6293.1,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(7231.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(7953.5,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-546.1)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"msub\" transform=\"translate(220,457.1) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"msub\" transform=\"translate(269.5,-345) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><rect width=\"1015\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mo\" transform=\"translate(1532.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mfrac\" transform=\"translate(2588.5,0)\"><g data-mml-node=\"mi\" transform=\"translate(220,394) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(269.5,-345) scale(0.707)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><rect width=\"706.3\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mo\" transform=\"translate(3757,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4479.3,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(9279.5,0) translate(0 250)\"></g></g></g></g></svg></mjx-container></span> 解得 <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -2.148ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"17.226ex\" height=\"5.428ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1449.5 7614 2399\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7B\" d=\"M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z\"></path></g><g data-mml-node=\"mtable\" transform=\"translate(750,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,600)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1430.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2486.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3177.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3899.6,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(4837.8,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(5560,0)\"><g transform=\"translate(853,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-17)\"><path data-c=\"221A\" d=\"M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z\"></path></g><rect width=\"451\" height=\"60\" x=\"853\" y=\"723\"></rect></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-693)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1290.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2346.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3037.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3759.6,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(4335.6,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msqrt\" transform=\"translate(4835.6,0)\"><g transform=\"translate(853,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-17)\"><path data-c=\"221A\" d=\"M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z\"></path></g><rect width=\"451\" height=\"60\" x=\"853\" y=\"723\"></rect></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(7614,0) translate(0 250)\"></g></g></g></g></svg></mjx-container></span> <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.452ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.161ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3165.1 950\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(1152.6,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">和</text></g><g data-mml-node=\"msub\" transform=\"translate(2152.6,0)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>分别处以w和h进行归一化，可得 <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -2.148ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"13.47ex\" height=\"5.428ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1449.5 5953.6 2399\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7B\" d=\"M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z\"></path></g><g data-mml-node=\"mtable\" transform=\"translate(750,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,600)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1430.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2486.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3177.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(3899.6,0)\"><g transform=\"translate(853,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-17)\"><path data-c=\"221A\" d=\"M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z\"></path></g><rect width=\"451\" height=\"60\" x=\"853\" y=\"723\"></rect></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-693)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1290.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2346.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(2815.1,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msqrt\" transform=\"translate(3315.1,0)\"><g transform=\"translate(853,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-17)\"><path data-c=\"221A\" d=\"M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z\"></path></g><rect width=\"451\" height=\"60\" x=\"853\" y=\"723\"></rect></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(5953.6,0) translate(0 250)\"></g></g></g></g></svg></mjx-container></span> 而在代码中我们可以看到：</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">w0 = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),</span><br><span class=\"line\">                   sizes[0] * torch.sqrt(ratio_tensor[1:])))\\</span><br><span class=\"line\">                   * in_height / in_width</span><br><span class=\"line\">h0 = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),</span><br><span class=\"line\">                   sizes[0] / torch.sqrt(ratio_tensor[1:])))</span><br></pre></td></tr></table></figure>\r\n<p>先不看<code>in_height / in_width</code>。上面解得的归一化后的公式与代码所写的一模一样。代码中的<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.375ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.608ex\" height=\"1.377ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -443 1152.6 608.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>和<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.375ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.291ex\" height=\"1.945ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 1012.6 859.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>就是锚框归一化后的宽高（此时消除了原图像w和h的影响，可以认为，r所代表的宽高比就是此时锚框的宽高比，r=1时，是一个正方形锚框，也即此时<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.375ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.608ex\" height=\"1.377ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -443 1152.6 608.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>和<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.375ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.291ex\" height=\"1.945ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 1012.6 859.6\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>的值是一样的）。但是呢，由于我们显示的时候需要乘以图像的实际宽高所以，乘后的锚框实际宽高比就不是1了，所以才要乘以<code>in_height / in_width</code>，作用就是抵消乘以实际图像长宽后r会改变的问题，当然这样做存粹是为了显示方便（也让你误以为r是指锚框的宽高比），带来的副作用就是，锚框的实际面积就不再是原始图像的<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.023ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.049ex\" height=\"1.909ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 905.6 843.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(502,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g></g></g></svg></mjx-container></span>。<code>(￣ε(#￣)。</code></p>\r\n<p>由于实际在我们进行目标检测时，特征图长和宽都是相同的，比如(19, 19)、(7, 7)，所以<code>in_height / in_width</code>恒等于1，因此对于实际的使用并不会带来副作用。但此时，如果要将锚框显示出来，归一化后的锚框再乘以图像实际长宽后，所显示的锚框的长宽比会改变。如下图所示，特征图宽高是(1, 1)，当r=1，s=0.5时，最终锚框的宽高比并不是r=1，而是<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.798ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"5.298ex\" height=\"2.398ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -707.2 2341.7 1060\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mi\" transform=\"translate(220,394) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(269.5,-345) scale(0.707)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><rect width=\"706.3\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mo\" transform=\"translate(1168.5,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1890.7,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container></span>。即上述代码中<code>in_height / in_width</code>这部分失效了。好消息是，面积是原图的<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.023ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.049ex\" height=\"1.909ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -833.9 905.6 843.9\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msup\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(502,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g></g></g></svg></mjx-container></span>，又符合定义了。<code>\\(￣︶￣\\))</code></p>\r\n<p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/目标检测SSD-图1.png\"></p>\r\n<h4 id=\"尝试的改动\">1.2 尝试的改动</h4>\r\n<p>所以如果r宽高比的定义按照**原图像的宽高比*r<strong>来定义，那么沐神的代码和书上的公式在</strong>实际使用<strong>时都是没问题的。只是将这个函数作用于特征图</strong>宽高不相同<strong>的实例时（比如为了给观众显示方便，直接作用上面这幅图像），会产生一丢丢歧义：此时的r的定义居然又变回了</strong>锚框的宽高比**。</p>\r\n<p>我们可以尝试来重新定义宽高比r（s定义不变），直接<strong>认定它代表锚框的宽高比</strong>，会有如下公式： <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -2.281ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"20.994ex\" height=\"5.693ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1508.2 9279.5 2516.3\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7B\" d=\"M618 -943L612 -949H582L568 -943Q472 -903 411 -841T332 -703Q327 -682 327 -653T325 -350Q324 -28 323 -18Q317 24 301 61T264 124T221 171T179 205T147 225T132 234Q130 238 130 250Q130 255 130 258T131 264T132 267T134 269T139 272T144 275Q207 308 256 367Q310 436 323 519Q324 529 325 851Q326 1124 326 1154T332 1205Q369 1358 566 1443L582 1450H612L618 1444V1429Q618 1413 616 1411L608 1406Q599 1402 585 1393T552 1372T515 1343T479 1305T449 1257T429 1200Q425 1180 425 1152T423 851Q422 579 422 549T416 498Q407 459 388 424T346 364T297 318T250 284T214 264T197 254L188 251L205 242Q290 200 345 138T416 3Q421 -18 421 -48T423 -349Q423 -397 423 -472Q424 -677 428 -694Q429 -697 429 -699Q434 -722 443 -743T465 -782T491 -816T519 -845T548 -868T574 -886T595 -899T610 -908L616 -910Q618 -912 618 -928V-943Z\"></path></g><g data-mml-node=\"mtable\" transform=\"translate(750,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,737.8)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"msub\" transform=\"translate(220,457.1) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"msub\" transform=\"translate(269.5,-345) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><rect width=\"1015\" height=\"60\" x=\"120\" y=\"220\"></rect></g><g data-mml-node=\"mo\" transform=\"translate(1532.8,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2588.5,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-758.2)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1374.8,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msub\" transform=\"translate(2097,0)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(3387.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"msup\" transform=\"translate(4443.1,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(502,363) scale(0.707)\"><path data-c=\"32\" d=\"M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(5570.9,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(6293.1,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(7231.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(7953.5,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(9279.5,0) translate(0 250)\"></g></g></g></g></svg></mjx-container></span> 解得 <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -3.144ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"20.793ex\" height=\"7.419ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1889.5 9190.4 3279\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\" transform=\"translate(0 -0.5)\"><path data-c=\"7B\" d=\"M661 -1243L655 -1249H622L604 -1240Q503 -1190 434 -1107T348 -909Q346 -897 346 -499L345 -98L343 -82Q335 3 287 87T157 223Q146 232 145 236Q144 240 144 250Q144 265 145 268T157 278Q242 333 288 417T343 583L345 600L346 1001Q346 1398 348 1410Q379 1622 600 1739L622 1750H655L661 1744V1727V1721Q661 1712 661 1710T657 1705T648 1700T630 1690T602 1668Q589 1659 574 1643T531 1593T484 1508T459 1398Q458 1389 458 1001Q458 614 457 605Q441 435 301 316Q254 277 202 251L250 222Q260 216 301 185Q443 66 457 -104Q458 -113 458 -501Q458 -888 459 -897Q463 -944 478 -988T509 -1060T548 -1114T580 -1149T602 -1167Q620 -1183 634 -1192T653 -1202T659 -1207T661 -1220V-1226V-1243Z\"></path></g><g data-mml-node=\"mtable\" transform=\"translate(806,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,920.5)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1430.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2486.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3177.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(3899.6,0)\"><g transform=\"translate(853,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(938.2,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1660.4,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2458.7,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3180.9,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,109)\"><path data-c=\"221A\" d=\"M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z\"></path></g><rect width=\"3631.9\" height=\"60\" x=\"853\" y=\"849\"></rect></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-823)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1290.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2346.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3037.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(3759.6,0)\"><g transform=\"translate(1020,0)\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mrow\" transform=\"translate(220,394) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(716,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1216,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(694.1,-345) scale(0.707)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><rect width=\"1467.1\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g><g data-mml-node=\"mo\" transform=\"translate(0,83.5)\"><path data-c=\"221A\" d=\"M1001 1150Q1017 1150 1020 1132Q1020 1127 741 244L460 -643Q453 -650 436 -650H424Q423 -647 423 -645T421 -640T419 -631T415 -617T408 -594T399 -560T385 -512T367 -448T343 -364T312 -259L203 119L138 41L111 67L212 188L264 248L472 -474L983 1140Q988 1150 1001 1150Z\"></path></g><rect width=\"1707.1\" height=\"60\" x=\"1020\" y=\"1173.5\"></rect></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(9190.4,0) translate(0 250)\"></g></g></g></g></svg></mjx-container></span> <span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.452ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"7.161ex\" height=\"2.149ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3165.1 950\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(1152.6,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">和</text></g><g data-mml-node=\"msub\" transform=\"translate(2152.6,0)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g></g></g></svg></mjx-container></span>分别处以w和h进行归一化，可得 <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -3.19ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16.58ex\" height=\"7.511ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -1910 7328.3 3320\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\"><path data-c=\"23A7\" d=\"M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z\" transform=\"translate(0,1011)\"></path><path data-c=\"23A9\" d=\"M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z\" transform=\"translate(0,-511)\"></path><path data-c=\"23A8\" d=\"M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z\" transform=\"translate(0,0)\"></path><svg width=\"889\" height=\"41\" y=\"1060\" x=\"0\" viewBox=\"0 7.2 889 41\"><path data-c=\"23AA\" d=\"M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z\" transform=\"scale(1,0.202)\"></path></svg><svg width=\"889\" height=\"41\" y=\"-601\" x=\"0\" viewBox=\"0 7.2 889 41\"><path data-c=\"23AA\" d=\"M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z\" transform=\"scale(1,0.202)\"></path></svg></g><g data-mml-node=\"mtable\" transform=\"translate(889,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,616.5)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(749,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1430.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2486.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3177.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(3899.6,0)\"><g transform=\"translate(1020,0)\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mrow\" transform=\"translate(220,394) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(576,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1076,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(506.7,-345) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><rect width=\"1279.8\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g><g data-mml-node=\"mo\" transform=\"translate(0,83.5)\"><path data-c=\"221A\" d=\"M1001 1150Q1017 1150 1020 1132Q1020 1127 741 244L460 -643Q453 -650 436 -650H424Q423 -647 423 -645T421 -640T419 -631T415 -617T408 -594T399 -560T385 -512T367 -448T343 -364T312 -259L203 119L138 41L111 67L212 188L264 248L472 -474L983 1140Q988 1150 1001 1150Z\"></path></g><rect width=\"1519.8\" height=\"60\" x=\"1020\" y=\"1173.5\"></rect></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-1054.7)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mn\" transform=\"translate(609,-150) scale(0.707)\"><path data-c=\"30\" d=\"M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1290.3,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2346.1,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3037.3,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"msqrt\" transform=\"translate(3759.6,0)\"><g transform=\"translate(1020,0)\"><g data-mml-node=\"mfrac\"><g data-mml-node=\"mi\" transform=\"translate(506.7,394) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mrow\" transform=\"translate(220,-345) scale(0.707)\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(451,0)\"><path data-c=\"2217\" d=\"M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(951,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g><rect width=\"1279.8\" height=\"60\" x=\"120\" y=\"220\"></rect></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-5.3)\"><path data-c=\"221A\" d=\"M263 249Q264 249 315 130T417 -108T470 -228L725 302Q981 837 982 839Q989 850 1001 850Q1008 850 1013 844T1020 832V826L741 243Q645 43 540 -176Q479 -303 469 -324T453 -348Q449 -350 436 -350L424 -349L315 -96Q206 156 205 156L171 130Q138 104 137 104L111 130L263 249Z\"></path></g><rect width=\"1519.8\" height=\"60\" x=\"1020\" y=\"784.7\"></rect></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(7328.3,0) translate(0 250)\"></g></g><g data-mml-node=\"mspace\" transform=\"translate(7328.3,0)\"></g></g></g></svg></mjx-container></span> 这样定义的话，就要求<code>multibox_prior()</code>函数要传入原图像的长度和宽度。 下面实验验证，不论特征图的长宽怎么变，r和s的定义都是一致的。</p>\r\n<p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/目标检测SSD-图2.png\"></p>\r\n<h3 id=\"锚框偏移\">2. 锚框偏移</h3>\r\n<p>假设<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.666ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.926ex\" height=\"2.498ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -810 851.3 1104.2\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mover\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(266.3,16) translate(-250 0)\"><path data-c=\"5E\" d=\"M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z\"></path></g></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-150) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g></g></g></svg></mjx-container></span>是某个标签目标，<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.357ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.916ex\" height=\"1.927ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 847 851.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,-150) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></g></g></svg></mjx-container></span>是某个anchor，边框回归与Faster-RCNN类似 回归的偏移相对的是<span class=\"math inline\"><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.357ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.916ex\" height=\"1.927ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 847 851.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"msub\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,-150) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></g></g></svg></mjx-container></span>的中点和宽高(cx, cy, w, h) <span class=\"math display\"><mjx-container class=\"MathJax\" jax=\"SVG\" display=\"true\"><svg style=\"vertical-align: -5.854ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"21.917ex\" height=\"12.839ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -3087.4 9687.2 5674.8\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mo\"><path data-c=\"23A7\" d=\"M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z\" transform=\"translate(0,2188.4)\"></path><path data-c=\"23A9\" d=\"M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z\" transform=\"translate(0,-1688.4)\"></path><path data-c=\"23A8\" d=\"M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z\" transform=\"translate(0,0)\"></path><svg width=\"889\" height=\"1218.4\" y=\"1060\" x=\"0\" viewBox=\"0 214.7 889 1218.4\"><path data-c=\"23AA\" d=\"M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z\" transform=\"scale(1,5.992)\"></path></svg><svg width=\"889\" height=\"1218.4\" y=\"-1778.4\" x=\"0\" viewBox=\"0 214.7 889 1218.4\"><path data-c=\"23AA\" d=\"M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z\" transform=\"scale(1,5.992)\"></path></svg></g><g data-mml-node=\"mtable\" transform=\"translate(889,0)\"><g data-mml-node=\"mtr\" transform=\"translate(0,2277.4)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msubsup\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mover\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(266.3,16) translate(-250 0)\"><path data-c=\"5E\" d=\"M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z\"></path></g></g></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1548.4,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2604.2,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(2993.2,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(4486.1,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(5486.3,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(553,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D465\" d=\"M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(553,-292.2) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(6799.9,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(7188.9,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msubsup\" transform=\"translate(7688.9,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,363) scale(0.707)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,-292.2) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,787.2)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msubsup\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mover\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(266.3,16) translate(-250 0)\"><path data-c=\"5E\" d=\"M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z\"></path></g></g></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,498.6) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D466\" d=\"M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-293.8) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1490.4,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(2546.2,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(2935.2,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,498.6) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D466\" d=\"M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-293.8) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(4370.1,0)\"><path data-c=\"2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(5370.3,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(553,498.6) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D466\" d=\"M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(553,-293.8) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(6626,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(7015,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msubsup\" transform=\"translate(7515,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,363) scale(0.707)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(553,-292.2) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-660.8)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msubsup\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mover\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(266.3,16) translate(-250 0)\"><path data-c=\"5E\" d=\"M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z\"></path></g></g></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1650.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2706,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3004,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3489,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3966,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(4355,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(5727.5,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msubsup\" transform=\"translate(6227.5,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(553,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(553,-292.2) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(7643,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g><g data-mml-node=\"mtr\" transform=\"translate(0,-2151)\"><g data-mml-node=\"mtd\"><g data-mml-node=\"msubsup\"><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mover\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(266.3,16) translate(-250 0)\"><path data-c=\"5E\" d=\"M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z\"></path></g></g></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(1551.2,0)\"><path data-c=\"3D\" d=\"M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2607,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2905,0)\"><path data-c=\"1D45C\" d=\"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3390,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mo\" transform=\"translate(3867,0)\"><path data-c=\"28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path></g><g data-mml-node=\"msubsup\" transform=\"translate(4256,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(510,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(510,-292.2) scale(0.707)\"><path data-c=\"1D457\" d=\"M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z\"></path></g></g><g data-mml-node=\"TeXAtom\" data-mjx-texclass=\"ORD\" transform=\"translate(5529.5,0)\"><g data-mml-node=\"mo\"><path data-c=\"2F\" d=\"M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z\"></path></g></g><g data-mml-node=\"msubsup\" transform=\"translate(6029.5,0)\"><g data-mml-node=\"mi\"><path data-c=\"1D451\" d=\"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z\"></path></g><g data-mml-node=\"TeXAtom\" transform=\"translate(553,363) scale(0.707)\" data-mjx-texclass=\"ORD\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g></g><g data-mml-node=\"mi\" transform=\"translate(553,-292.2) scale(0.707)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(7346,0)\"><path data-c=\"29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path></g></g></g></g><g data-mml-node=\"mo\" transform=\"translate(9687.2,0) translate(0 250)\"></g></g><g data-mml-node=\"mspace\" transform=\"translate(9687.2,0)\"></g></g></g></svg></mjx-container></span> 解释：</p>\r\n<ul>\r\n<li>激活的锚框（即给分配了某gt的正样本），其与某gt的IOU肯定不低，则其x、y、w、h也肯定差不大，这是前提</li>\r\n<li>x、y：做差后分布于零点对称，除以锚框宽或高起到归一化作用，值分布变窄</li>\r\n<li>w、h：做除法后用log，可近似线性，且使得结果的分布呈现零点对称，使得网络回归更简单</li>\r\n</ul>\r\n","tags":["目标检测"]},{"title":"线段树","url":"/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"<h2 id=\"需求\">需求</h2>\r\n<ul>\r\n<li>数组区间内经常发生修改，但是又要频繁求得区间的各类统计信息例如最大值、最小值、区间和等等。</li>\r\n<li>对于一个数组频繁求区间和和修改的情况下：\r\n<ul>\r\n<li>普通操作：修改：O(1)；区间和：O(n)</li>\r\n<li>前缀和：修改：O(n)；区间和：O(1)</li>\r\n<li>线段树：修改：O(nlogn)；区间和：O(nlogn)</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"线段树\">线段树</h2>\r\n<ul>\r\n<li>将数组以二分的形式建成一棵二叉树，叶子节点为数组的值，非叶子节点保存相应的统计信息。这棵树近似完全二叉树的结构，所以可以用数组来构建</li>\r\n<li>下面所列举的代码只需要改变给<code>tree[node]</code>赋值相关代码即可实现求最大值、最小值、区间和，肥肠方便</li>\r\n<li><a href=\"https://leetcode.cn/problems/range-sum-query-mutable/\">307. 区域和检索 - 数组可修改</a></li>\r\n</ul>\r\n<h2 id=\"数组版\">1、数组版</h2>\r\n<ul>\r\n<li>粗略而言，数组版线段树的大小初始化为4N即可</li>\r\n<li>这里<code>_buildTree, _update, _sumRange</code>都传入了参数<code>int start, int end</code>。是通过形参来维护每个树节点的管理范围，事实上，也可以创建一个<code>tree.shape == (3, 4N)</code>的线段树，第一行是统计信息，第二三行是范围起点和终点，代码可见<a href=\"#数组版v2\">数组版v2</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums):<span class=\"built_in\">arr</span>(nums), <span class=\"built_in\">tree</span>(arr.<span class=\"built_in\">size</span>()*<span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        _buildTree(<span class=\"number\">0</span>, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        _update(<span class=\"number\">0</span>, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, index, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(<span class=\"number\">0</span>, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">void</span> _buildTree(<span class=\"type\">int</span> node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            tree[node] = arr[start];</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        _buildTree(node_left, start, mid);</span><br><span class=\"line\">        _buildTree(node_right, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        tree[node] = tree[node_left] + tree[node_right];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> _update(<span class=\"type\">int</span> node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            arr[idx] = val;</span><br><span class=\"line\">            tree[node] = val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &lt;= mid) _update(node_left, start, mid, idx, val);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> _update(node_right, mid + <span class=\"number\">1</span>, end, idx, val);</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        tree[node] = tree[node_left] + tree[node_right]; <span class=\"comment\">// 修改路径上的值，类似树状数组的寻祖</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> _sumRange(<span class=\"type\">int</span> node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; end || r &lt; start) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 不在区间内</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt;= l &amp;&amp; end &lt;= r) <span class=\"keyword\">return</span> tree[node];</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(node_left, start, mid, l, r) + _sumRange(node_right, mid + <span class=\"number\">1</span>, end, l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; tree;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"真建树\">2、真建树</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start;</span><br><span class=\"line\">    <span class=\"type\">int</span> end;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TNode* left;</span><br><span class=\"line\">    TNode* right;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        tree = _buildTree(nums, <span class=\"number\">0</span>, nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        _update(tree, index, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(tree, left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    TNode* _buildTree(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r) &#123;</span><br><span class=\"line\">        TNode* p = <span class=\"keyword\">new</span> TNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) &#123;</span><br><span class=\"line\">            p-&gt;val = arr[l];</span><br><span class=\"line\">            p-&gt;left = p-&gt;right = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            p-&gt;left = _buildTree(arr, l, m);</span><br><span class=\"line\">            p-&gt;right = _buildTree(arr, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">            p-&gt;val = p-&gt;left-&gt;val + p-&gt;right-&gt;val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p-&gt;start = l; p-&gt;end = r;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">void</span> _update(TNode* root, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = root-&gt;start, end = root-&gt;end;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            root-&gt;val = val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &lt;= mid) _update(root-&gt;left, idx, val);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> _update(root-&gt;right, idx, val);</span><br><span class=\"line\">        root-&gt;val = root-&gt;left-&gt;val + root-&gt;right-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> _sumRange(TNode* root, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = root-&gt;start, end = root-&gt;end;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; end || r &lt; start) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 不在区间内</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt;= l &amp;&amp; end &lt;= r) <span class=\"keyword\">return</span> root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(root-&gt;left, l, r) + _sumRange(root-&gt;right, l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TNode* tree;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"数组版v2\">3、数组版v2</h2>\r\n<ul>\r\n<li>效率相较于v1是低了，占用内存也高了~ <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums):<span class=\"built_in\">arr</span>(nums), <span class=\"built_in\">tree</span>(<span class=\"number\">3</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(arr.<span class=\"built_in\">size</span>() * <span class=\"number\">4</span>)) &#123;</span><br><span class=\"line\">        _buildTree(<span class=\"number\">0</span>, <span class=\"number\">0</span>, arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        _update(<span class=\"number\">0</span>, index, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(<span class=\"number\">0</span>, left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">void</span> _buildTree(<span class=\"type\">int</span> node, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            tree[<span class=\"number\">0</span>][node] = arr[start];</span><br><span class=\"line\">            tree[<span class=\"number\">1</span>][node] = start; <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">            tree[<span class=\"number\">2</span>][node] = end; <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        _buildTree(node_left, start, mid);</span><br><span class=\"line\">        _buildTree(node_right, mid + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        tree[<span class=\"number\">0</span>][node] = tree[<span class=\"number\">0</span>][node_left] + tree[<span class=\"number\">0</span>][node_right];</span><br><span class=\"line\">        tree[<span class=\"number\">1</span>][node] = start; <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">        tree[<span class=\"number\">2</span>][node] = end; <span class=\"comment\">// 赋值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">void</span> _update(<span class=\"type\">int</span> node, <span class=\"type\">int</span> idx, <span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = tree[<span class=\"number\">1</span>][node], end = tree[<span class=\"number\">2</span>][node];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) &#123;</span><br><span class=\"line\">            arr[idx] = val;</span><br><span class=\"line\">            tree[<span class=\"number\">0</span>][node] = val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (idx &lt;= mid) _update(node_left, idx, val);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> _update(node_right, idx, val);</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        tree[<span class=\"number\">0</span>][node] = tree[<span class=\"number\">0</span>][node_left] + tree[<span class=\"number\">0</span>][node_right]; <span class=\"comment\">// 修改路径上的值，类似树状数组的寻祖</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> _sumRange(<span class=\"type\">int</span> node, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> start = tree[<span class=\"number\">1</span>][node], end = tree[<span class=\"number\">2</span>][node];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; end || r &lt; start) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 不在区间内</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt;= l &amp;&amp; end &lt;= r) <span class=\"keyword\">return</span> tree[<span class=\"number\">0</span>][node];</span><br><span class=\"line\">        <span class=\"type\">int</span> node_left = node * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> node_right = node * <span class=\"number\">2</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这里可以改为求最大值、最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _sumRange(node_left, l, r) + _sumRange(node_right, l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; tree;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h2 id=\"参考\">参考</h2>\r\n<ol type=\"1\">\r\n<li><a href=\"https://www.bilibili.com/video/BV1cb411t7AM?from=search&amp;seid=18283713629507376570&amp;spm_id_from=333.337.0.0&amp;vd_source=5def309c50dba10ca2a52c71628df16d\">正月点灯笼</a></li>\r\n</ol>\r\n","tags":["算法","特殊","树"]},{"title":"线程安全智能指针","url":"/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"<h1 id=\"线程安全的share指针\">线程安全的share指针</h1>\r\n<h2 id=\"代码部分\">1. 代码部分</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Counter</span>(): <span class=\"built_in\">m_Counter</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">Counter</span>(<span class=\"type\">const</span> Counter&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    Counter&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Counter&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">Counter</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123; m_Counter = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_Counter; &#125;</span><br><span class=\"line\">    <span class=\"type\">void</span> <span class=\"keyword\">operator</span>++() &#123; m_Counter++; &#125;</span><br><span class=\"line\">    <span class=\"type\">void</span> <span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) &#123; m_Counter++; &#125;</span><br><span class=\"line\">    <span class=\"type\">void</span> <span class=\"keyword\">operator</span>--() &#123; m_Counter--; &#125;</span><br><span class=\"line\">    <span class=\"type\">void</span> <span class=\"keyword\">operator</span>--(<span class=\"type\">int</span>) &#123; m_Counter--; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> m_Counter&#123;&#125;; <span class=\"comment\">// 花括号也可以初始化</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SharedPtr</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SharedPtr</span><span class=\"params\">(T *ptr = <span class=\"literal\">nullptr</span>)</span>: // explicit</span></span><br><span class=\"line\"><span class=\"function\">        pData(ptr),</span></span><br><span class=\"line\"><span class=\"function\">        pCounter(new Counter()),</span></span><br><span class=\"line\"><span class=\"function\">        pMutex(new std::mutex)</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">SharedPtr</span>(<span class=\"type\">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class=\"line\">        pData = sp.pData;</span><br><span class=\"line\">        pCounter = sp.pCounter;</span><br><span class=\"line\">        pMutex = sp.pMutex;</span><br><span class=\"line\">        <span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    SharedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pData != sp.pData) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">subCount</span>();</span><br><span class=\"line\">            pData = sp.pData;</span><br><span class=\"line\">            pCounter = sp.pCounter;</span><br><span class=\"line\">            pMutex = sp.pMutex;</span><br><span class=\"line\">            <span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T* <span class=\"keyword\">operator</span>-&gt;() &#123; <span class=\"keyword\">return</span> pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>*() &#123; <span class=\"keyword\">return</span> *pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">T* <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> pCounter-&gt;<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">SharedPtr</span>() &#123; <span class=\"built_in\">subCount</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        pMutex-&gt;<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        ++(*pCounter);</span><br><span class=\"line\">        pMutex-&gt;<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">subCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">bool</span> deleteflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        pMutex-&gt;<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        --(*pCounter);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pCounter-&gt;<span class=\"built_in\">get</span>() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> pCounter;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> pData;</span><br><span class=\"line\">            deleteflag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pMutex-&gt;<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (deleteflag == <span class=\"literal\">true</span>) <span class=\"keyword\">delete</span> pMutex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T *pData;</span><br><span class=\"line\">    std::mutex *pMutex;</span><br><span class=\"line\">    Counter *pCounter;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">SharedPtr&lt;MyClass&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> MyClass())</span></span>;</span><br><span class=\"line\">    SharedPtr&lt;MyClass&gt; p2 = p;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考资料\">2. 参考资料</h2>\r\n<ul>\r\n<li><a href=\"https://blog.csdn.net/songguangfan/article/details/121974538\">1. 线程安全智能指针</a></li>\r\n<li><a href=\"https://www.cnblogs.com/WindSun/p/11444429.html\">2. 智能指针</a></li>\r\n</ul>\r\n","tags":["C/C++"]},{"title":"背包问题","url":"/2022/06/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"<h1 id=\"背包\">01背包</h1>\r\n<p>经典动态规划问题，输入重量数组weight、价值数组value和背包可承载的最大重量整数maxW <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">knapsack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; weight, vector&lt;<span class=\"type\">int</span>&gt;&amp; value, <span class=\"type\">int</span> maxW)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 物品数目</span></span><br><span class=\"line\">        <span class=\"type\">int</span> kinds = weight.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// dp数组初始化为二维数组</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(kinds + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(maxW + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 状态一：可选的目标：0个可选，前一个可选、前两个可选、前三个可选，以此类推（与找零钱不同，物品不能重复选）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> c = <span class=\"number\">1</span>; c &lt;= kinds; c++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 状态二：当前的可承载重量，0、1、2...maxW</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> w = <span class=\"number\">1</span>; w &lt;= maxW; w++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 该物品太大以至于当前重量超标：下标越界，直接赋值为“没有该物品时的最优答案”</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (w - weight[c - <span class=\"number\">1</span>] &lt; <span class=\"number\">0</span>) </span><br><span class=\"line\">                    dp[c][w] = dp[c - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">                <span class=\"comment\">// 比较，“不选择该物品”和“选择该物品”时，哪个价值大</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[c][w] = <span class=\"built_in\">max</span>(dp[c - <span class=\"number\">1</span>][w], dp[c - <span class=\"number\">1</span>][w - weight[c - <span class=\"number\">1</span>]] + value[c - <span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[kinds][maxW];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h1 id=\"完全背包\"><a href=\"https://leetcode.cn/problems/coin-change-2/\">完全背包</a></h1>\r\n<h3 id=\"标准dp\">标准DP</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = coins.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(n+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(amount+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">// base case 这里也可以只dp[0][0]=1，但下面的二重循环的j必须从0开始了</span></span><br><span class=\"line\">        <span class=\"comment\">// 从含义上来说，还是在这里初始化一列全1比较符合定义</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> s = <span class=\"number\">0</span>; s&lt;=n; ++s)</span><br><span class=\"line\">            dp[s][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=amount; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(coins[i<span class=\"number\">-1</span>] &gt; j)</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"comment\">// dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]];一个数字之差就变成不可重复选取了</span></span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j] + dp[i][j-coins[i<span class=\"number\">-1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"压缩一下\">压缩一下</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = coins.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(amount+<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=amount; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(coins[i<span class=\"number\">-1</span>] &lt;= j)</span><br><span class=\"line\">                    dp[j] = dp[j] + dp[j-coins[i<span class=\"number\">-1</span>]]; <span class=\"comment\">// 由于需要用到当前行更新的值，正好不用倒过来了，和下面子集背包压缩做对比</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"子集背包\"><a href=\"https://leetcode.cn/problems/partition-equal-subset-sum/\">子集背包</a></h1>\r\n<h3 id=\"标准dp-1\">标准DP</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子集背包问题</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// sum(A1) == sum(A2) -&gt; target = sum(A)/2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canPartition</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : nums) sum += e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">2</span>) <span class=\"comment\">// 和必须是偶数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> target = sum &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">dp</span>(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(target + <span class=\"number\">1</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// 用布尔</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= target; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &gt; j)</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i - <span class=\"number\">1</span>][j - nums[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][target] &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"压缩一下-1\">压缩一下</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子集背包问题</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// sum(A1) == sum(A2) -&gt; target = sum(A)/2</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canPartition</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : nums) sum += e;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">2</span>) <span class=\"comment\">// 和必须是偶数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> target = sum &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(target + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>; <span class=\"comment\">// 用布尔</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = target; j &gt;= <span class=\"number\">0</span>; j--) &#123; <span class=\"comment\">// 必须从后往前，不然会覆盖之前的数据</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i - <span class=\"number\">1</span>] &gt; j)</span><br><span class=\"line\">                    dp[j] = dp[j];</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    dp[j] = dp[j] || dp[j - nums[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[target] &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://labuladong.github.io/algo/3/27/\">labuladong</a></p>\r\n","tags":["算法","动态规划"]},{"title":"计算器","url":"/2022/04/05/%E8%AE%A1%E7%AE%97%E5%99%A8/","content":"<h1 id=\"功能说明\">功能说明</h1>\r\n<ul>\r\n<li>实现+、-、*、/、括号的整数运算</li>\r\n<li>实现处理多余空格</li>\r\n</ul>\r\n<h1 id=\"实现1更高效\">实现1（更高效）</h1>\r\n<ul>\r\n<li>用引用<code>l</code>指针的方式逐步处理 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span>&amp; l)</span> </span>&#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> sign = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; l &lt; n; ++l) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> c = s[l];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c)) </span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// if(c == &#x27; &#x27;) continue是不对的，因为l=n-1时一定要最后来一次</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((!<span class=\"built_in\">isdigit</span>(c) &amp;&amp; c != <span class=\"string\">&#x27; &#x27;</span>) || l == n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span>) </span><br><span class=\"line\">                num = <span class=\"built_in\">core</span>(s, ++l); <span class=\"comment\">// 理解这种递归思想很重要</span></span><br><span class=\"line\">            <span class=\"type\">int</span> prev;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (sign) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(-num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">                prev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(prev * num);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">                prev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(prev / num);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sign = c;</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span>) </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stk.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        ret += stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">caculator</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">core</span>(s, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"实现2更优雅\">实现2（更优雅）</h1>\r\n<ul>\r\n<li>由于需要不停<code>pop</code>首部，所以采用<code>deque</code>代替移动的<code>l</code>，更优雅 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(deque&lt;<span class=\"type\">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> sign = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> c = s[<span class=\"number\">0</span>]; s.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c))</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((!<span class=\"built_in\">isdigit</span>(c) &amp;&amp; c != <span class=\"string\">&#x27; &#x27;</span>) || s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">                num = <span class=\"built_in\">core</span>(s);</span><br><span class=\"line\">            <span class=\"type\">int</span> prev;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> (sign) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(-num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">                prev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(prev * num);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">                prev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(prev / num);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sign = c;</span><br><span class=\"line\">            num = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!stk.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        ret += stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">caculator</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">    deque&lt;<span class=\"type\">char</span>&gt; dq;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : s) dq.<span class=\"built_in\">push_back</span>(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">core</span>(dq);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"参考\">参考</h1>\r\n<ul>\r\n<li>labuladong的算法小抄</li>\r\n</ul>\r\n","tags":["算法","特殊"]},{"title":"设计模式-工厂模式","url":"/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"工厂模式\">1 工厂模式</h2>\r\n<ul>\r\n<li>父类决定实例的生成方式，但并不决定所要生成具体的类，具体处理全部交给子类处理。 将生成实例的框架与具体的实例类解耦。</li>\r\n<li>在软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化</li>\r\n<li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FileSplitter.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ISplitter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">ISplitter</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多个具体的文件分割器</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BinarySplitter</span> : <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TxtSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PictureSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VideoSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MainForm.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainForm</span> : <span class=\"keyword\">public</span> Form&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Button1_Click</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 抽象依赖* ptr = new 具体依赖(); 违背依赖倒置原则，这样肯定不行的！</span></span><br><span class=\"line\">        ISplitter * splitter = <span class=\"keyword\">new</span> <span class=\"built_in\">BinarySplitter</span>(); <span class=\"comment\">//依赖具体类</span></span><br><span class=\"line\">        splitter-&gt;<span class=\"built_in\">split</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"工厂模式-1\">3 工厂模式</h2>\r\n<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类</p>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg\" alt=\"工厂模式\" /><figcaption aria-hidden=\"true\">工厂模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ---- 抽象基类 ----</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ISplitter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">ISplitter</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---- 工厂基类 ----</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SplitterFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ISplitter* <span class=\"title\">CreateSplitter</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">SplitterFactory</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  ---- 具体类 ----</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BinarySplitter</span> : <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TxtSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PictureSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VideoSplitter</span>: <span class=\"keyword\">public</span> ISplitter&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ---- 具体工厂 ----</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BinarySplitterFactory</span>: <span class=\"keyword\">public</span> SplitterFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ISplitter* <span class=\"title\">CreateSplitter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">BinarySplitter</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TxtSplitterFactory</span>: <span class=\"keyword\">public</span> SplitterFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ISplitter* <span class=\"title\">CreateSplitter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TxtSplitter</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PictureSplitterFactory</span>: <span class=\"keyword\">public</span> SplitterFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ISplitter* <span class=\"title\">CreateSplitter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">PictureSplitter</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">VideoSplitterFactory</span>: <span class=\"keyword\">public</span> SplitterFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ISplitter* <span class=\"title\">CreateSplitter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">VideoSplitter</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 虽然具体工厂总会在某个地方new出来，但是MainForm没有具体类的依赖了，变化的地方被赶出去了（变化没法消灭），猫被关进笼子里</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainForm</span> : <span class=\"keyword\">public</span> Form&#123;</span><br><span class=\"line\">    SplitterFactory*  factory; <span class=\"comment\">// 工厂</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MainForm</span>(SplitterFactory*  factory)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;factory=factory;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Button1_Click</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ISplitter * splitter = factory-&gt;<span class=\"built_in\">CreateSplitter</span>(); <span class=\"comment\">// 形式上叫“多态new”</span></span><br><span class=\"line\">        splitter-&gt;<span class=\"built_in\">split</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">4 总结</h2>\r\n<ul>\r\n<li>Factory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。</li>\r\n<li>Factory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</li>\r\n<li>Factory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法/参数相同。</li>\r\n</ul>\r\n<h2 id=\"参考\">5 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-单例模式","url":"/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"单例模式\">单例模式</h2>\r\n<h3 id=\"静态函数变量版本\">0、静态函数变量版本</h3>\r\n<p>利用C++特性 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SingleTon</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> T&amp; <span class=\"title\">GetInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> T ins;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ins;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">SingleTon</span>(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    SingleTon&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> SingleTon&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">SingleTon</span>() &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SingleTon</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> : <span class=\"keyword\">public</span> SingleTon&lt;Apple&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> SingleTon&lt;Apple&gt;; <span class=\"comment\">// 友元</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Apple</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Apple</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Orange</span> : <span class=\"keyword\">public</span> SingleTon&lt;Orange&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> SingleTon&lt;Orange&gt;; <span class=\"comment\">// 友元</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Orange</span>() &#123;</span><br><span class=\"line\">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Orange</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Apple::<span class=\"built_in\">GetInstance</span>().<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cout &lt;&lt; &amp;Apple::<span class=\"built_in\">GetInstance</span>() &lt;&lt; endl;</span><br><span class=\"line\">    Apple::<span class=\"built_in\">GetInstance</span>().<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    cout &lt;&lt; &amp;Apple::<span class=\"built_in\">GetInstance</span>() &lt;&lt; endl;</span><br><span class=\"line\">    Orange::<span class=\"built_in\">GetInstance</span>().<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    Orange::<span class=\"built_in\">GetInstance</span>().<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"普通版本高并发效率不足安全\">1、普通版本（高并发效率不足）（安全）</h3>\r\n<ul>\r\n<li>在类中添加一个私有静态成员单例实例的指针。</li>\r\n<li>声明一个公有静态构建方法用于获取单例实例的指针。</li>\r\n<li>在静态方法中实现\"延迟初始化\"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li>\r\n<li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li>\r\n<li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"type\">const</span> string&amp; val) : <span class=\"built_in\">data</span>(val) &#123;&#125; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Singleton</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"type\">static</span> Singleton* _instance; <span class=\"comment\">// 静态：实例的指针</span></span><br><span class=\"line\">    <span class=\"type\">static</span> mutex _mutex;</span><br><span class=\"line\">    string data; <span class=\"comment\">// 代表类内的资源</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Singleton</span>(<span class=\"type\">const</span> Singleton&amp; another) = <span class=\"keyword\">delete</span>; <span class=\"comment\">// 禁止拷贝构造</span></span><br><span class=\"line\">    Singleton&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Singleton&amp; another) = <span class=\"keyword\">delete</span>; <span class=\"comment\">// 禁止赋值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> Singleton* <span class=\"title\">getInstance</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; val)</span></span>; <span class=\"comment\">// 静态：获取实例</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; endl; &#125; <span class=\"comment\">// 测试</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态成员需要在类外定义</span></span><br><span class=\"line\">Singleton* Singleton::_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">mutex Singleton::_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(_mutex)</span></span>; <span class=\"comment\">// 出作用域自动释放</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_instance == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        _instance = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Singleton* a = Singleton::<span class=\"built_in\">getInstance</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">    a-&gt;<span class=\"built_in\">show</span>(); <span class=\"comment\">// &quot;aaa&quot; ok</span></span><br><span class=\"line\">    Singleton* b = Singleton::<span class=\"built_in\">getInstance</span>(<span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\">    b-&gt;<span class=\"built_in\">show</span>(); <span class=\"comment\">// &quot;aaa&quot; ok</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h3 id=\"双检查锁有隐患\">2、双检查锁（有隐患）</h3>\r\n<p>reorder问题：通常new通常有三步：1、分配一块内存空间；2、执行构造器；3、返回指针； 但是由于编译器有时会进行优化，执行顺序变为132：即分配空间后先返回指针，再执行构造器 这样就会到来危险，比如线程A执行new，132，3执行完；线程B发现m_instance非空返回，然后外部直接用这个指针会出错 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双检查锁，但由于内存读写reorder不安全（不安全）</span></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m_instance==<span class=\"literal\">nullptr</span>)&#123; <span class=\"comment\">// 第一次检查，主要解决性能问题，毕竟读操作不需要上锁</span></span><br><span class=\"line\">        Lock lock;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_instance == <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 第二次检查，解决核心问题：只能new单个</span></span><br><span class=\"line\">            m_instance = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m_instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h3 id=\"双检查锁安全\">3、双检查锁（安全）</h3>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//C++ 11版本之后的跨平台实现 (volatile)（安全）</span></span><br><span class=\"line\">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class=\"line\">std::mutex Singleton::m_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Singleton* tmp = m_instance.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">    std::<span class=\"built_in\">atomic_thread_fence</span>(std::memory_order_acquire); <span class=\"comment\">// 获取内存fence</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(m_mutex)</span></span>;</span><br><span class=\"line\">        tmp = m_instance.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            tmp = <span class=\"keyword\">new</span> Singleton;</span><br><span class=\"line\">            std::<span class=\"built_in\">atomic_thread_fence</span>(std::memory_order_release); <span class=\"comment\">// 释放内存fence</span></span><br><span class=\"line\">            m_instance.<span class=\"built_in\">store</span>(tmp, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"参考资料\">参考资料</h2>\r\n<ul>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/catalog\">Refactoring.Guru</a></li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-抽象工厂","url":"/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","content":"<h2 id=\"抽象工厂模式\">1 抽象工厂模式</h2>\r\n<ul>\r\n<li>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。</li>\r\n<li>如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</li>\r\n<li>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeDAO</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;EmployeeDO&gt; <span class=\"title\">GetEmployees</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        SqlConnection* connection = <span class=\"keyword\">new</span> <span class=\"built_in\">SqlConnection</span>(); <span class=\"comment\">// 耦合</span></span><br><span class=\"line\">        connection-&gt;<span class=\"built_in\">ConnectionString</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        SqlCommand* command = <span class=\"keyword\">new</span> <span class=\"built_in\">SqlCommand</span>(); <span class=\"comment\">// 耦合</span></span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">CommandText</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">SetConnection</span>(connection);</span><br><span class=\"line\"></span><br><span class=\"line\">        SqlDataReader* reader = command-&gt;<span class=\"built_in\">ExecuteReader</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (reader-&gt;<span class=\"built_in\">Read</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"尝试简单工厂模式\">3 尝试简单工厂模式</h2>\r\n<p>系列对象的关联性丢失，产生大量类，代码臃肿不堪 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先尝试用简单工厂模式解决...</span></span><br><span class=\"line\"><span class=\"comment\">// 数据库访问有关的基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBConnection</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBConnectionFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBConnection* <span class=\"title\">CreateDBConnection</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBCommand</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBCommandFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBCommand* <span class=\"title\">CreateDBCommand</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBDataReader</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBDataReaderFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBDataReader* <span class=\"title\">CreateDataReader</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持SQL Server</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlConnection</span>: <span class=\"keyword\">public</span> IDBConnection&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlConnectionFactory</span>:<span class=\"keyword\">public</span> IDBConnectionFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlCommand</span>: <span class=\"keyword\">public</span> IDBCommand&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlCommandFactory</span>:<span class=\"keyword\">public</span> IDBCommandFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlDataReader</span>: <span class=\"keyword\">public</span> IDataReader&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlDataReaderFactory</span>:<span class=\"keyword\">public</span> IDBDataReaderFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持Oracle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleConnection</span>: <span class=\"keyword\">public</span> IDBConnection&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleConnectionFactory</span>: <span class=\"keyword\">public</span> IDBConnectionFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleCommand</span>: <span class=\"keyword\">public</span> IDBCommand&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleCommandFactory</span>: publc IDBCommandFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleDataReader</span>: <span class=\"keyword\">public</span> IDataReader&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleDataReaderFactory</span>: <span class=\"keyword\">public</span> IDBDataReaderFactory&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeDAO</span>&#123;</span><br><span class=\"line\">    IDBConnectionFactory* dbConnectionFactory;</span><br><span class=\"line\">    IDBCommandFactory* dbCommandFactory;</span><br><span class=\"line\">    IDBDataReaderFactory* dataReaderFactory;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;EmployeeDO&gt; <span class=\"title\">GetEmployees</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        IDBConnection* connection = dbConnectionFactory-&gt;<span class=\"built_in\">CreateDBConnection</span>();</span><br><span class=\"line\">        connection-&gt;<span class=\"built_in\">ConnectionString</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        IDBCommand* command = dbCommandFactory-&gt;<span class=\"built_in\">CreateDBCommand</span>();</span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">CommandText</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">SetConnection</span>(connection); <span class=\"comment\">//关联性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        IDBDataReader* reader = command-&gt;<span class=\"built_in\">ExecuteReader</span>(); <span class=\"comment\">//关联性</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (reader-&gt;<span class=\"built_in\">Read</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"抽象工厂family-factory\">4 抽象工厂（family factory）</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg\" alt=\"抽象工厂模式\" /><figcaption aria-hidden=\"true\">抽象工厂模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// family factory</span></span><br><span class=\"line\"><span class=\"comment\">// 数据库访问有关的基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBConnection</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBCommand</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBDataReader</span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抽象工厂基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IDBFactory</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBConnection* <span class=\"title\">CreateDBConnection</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBCommand* <span class=\"title\">CreateDBCommand</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBDataReader* <span class=\"title\">CreateDataReader</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持SQL Server</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlConnection</span>: <span class=\"keyword\">public</span> IDBConnection&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlCommand</span>: <span class=\"keyword\">public</span> IDBCommand&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlDataReader</span>: <span class=\"keyword\">public</span> IDBDataReader&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// SQL工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SqlDBFactory</span>:<span class=\"keyword\">public</span> IDBFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBConnection* <span class=\"title\">CreateDBConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SqlConnection</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBCommand* <span class=\"title\">CreateDBCommand</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SqlCommand</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBDataReader* <span class=\"title\">CreateDataReader</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">SqlDataReader</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持Oracle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleConnection</span>: <span class=\"keyword\">public</span> IDBConnection&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleCommand</span>: <span class=\"keyword\">public</span> IDBCommand&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleDataReader</span>: <span class=\"keyword\">public</span> IDBDataReader&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Oracle工厂</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OracleDBFactory</span>: <span class=\"keyword\">public</span> IDBFactory&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBConnection* <span class=\"title\">CreateDBConnection</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">OracleConnection</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBCommand* <span class=\"title\">CreateDBCommand</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">OracleCommand</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> IDBDataReader* <span class=\"title\">CreateDataReader</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">OracleDataReader</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EmployeeDAO</span>&#123;</span><br><span class=\"line\">    IDBFactory* dbFactory; <span class=\"comment\">// 抽象工厂指针</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;EmployeeDO&gt; <span class=\"title\">GetEmployees</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        IDBConnection* connection = dbFactory-&gt;<span class=\"built_in\">CreateDBConnection</span>();</span><br><span class=\"line\">        connection-&gt;<span class=\"built_in\">ConnectionString</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        IDBCommand* command = dbFactory-&gt;<span class=\"built_in\">CreateDBCommand</span>();</span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">CommandText</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">        command-&gt;<span class=\"built_in\">SetConnection</span>(connection); <span class=\"comment\">//关联性</span></span><br><span class=\"line\"></span><br><span class=\"line\">        IDBDataReader* reader = command-&gt;<span class=\"built_in\">ExecuteReader</span>(); <span class=\"comment\">//关联性</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (reader-&gt;<span class=\"built_in\">Read</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// ...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">5 总结</h2>\r\n<ul>\r\n<li>如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。</li>\r\n<li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。</li>\r\n<li>Abstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。（新系列数据库：OK；新方法IDBMethod：NO！）</li>\r\n</ul>\r\n<h2 id=\"参考\">6 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-模板方法模式","url":"/2022/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"模板方法模式\">1 模板方法模式</h2>\r\n<ul>\r\n<li>模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</li>\r\n<li>在父类中定义处理流程的框架，在子类中实现具体处理</li>\r\n<li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。</li>\r\n<li>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//程序库开发人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Library</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step5</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//应用程序开发人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Application</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Step2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step4</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Library <span class=\"title\">lib</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Application <span class=\"title\">app</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    lib.<span class=\"built_in\">Step1</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (app.<span class=\"built_in\">Step2</span>())&#123;</span><br><span class=\"line\">        lib.<span class=\"built_in\">Step3</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">        app.<span class=\"built_in\">Step4</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    lib.<span class=\"built_in\">Step5</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"模板方法\">3 模板方法</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.jpg\" alt=\"模板方法模式\" /><figcaption aria-hidden=\"true\">模板方法模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//程序库开发人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Library</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//稳定 template method，要求Run方法稳定</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">Step1</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Step2</span>()) &#123; <span class=\"comment\">// 支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class=\"line\">            <span class=\"built_in\">Step3</span>(); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">Step4</span>(); <span class=\"comment\">// 支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">Step5</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Library</span>()&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这些步骤一般单独调用没意义，所以设为protected</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step1</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 稳定</span></span><br><span class=\"line\">        <span class=\"comment\">//.....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step3</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">// 稳定</span></span><br><span class=\"line\">        <span class=\"comment\">//.....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Step5</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 稳定</span></span><br><span class=\"line\">        <span class=\"comment\">//.....</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">Step2</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// 变化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Step4</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>; <span class=\"comment\">// 变化</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//应用程序开发人员</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Application</span> : <span class=\"keyword\">public</span> Library &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">Step2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... 子类重写实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Step4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//... 子类重写实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Library* pLib = <span class=\"keyword\">new</span> <span class=\"built_in\">Application</span>();</span><br><span class=\"line\">    lib-&gt;<span class=\"built_in\">Run</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> pLib;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">4 总结</h2>\r\n<ul>\r\n<li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。</li>\r\n<li>除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。</li>\r\n<li>在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。</li>\r\n</ul>\r\n<h2 id=\"参考\">5 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-状态模式","url":"/2022/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"状态模式\">1 状态模式</h2>\r\n<ul>\r\n<li>在软件构建过程中，某些对象的状态如果改变，其行为也会随之改变，比如文档处于只读状态，其支持的行为和读写状态支持的行为可能完全不同</li>\r\n<li>允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为</li>\r\n<li>用类表示状态，通过切换类改变对象状态</li>\r\n<li>跟Strategy模式很像，区别是：状态模式采用单例模式，抽象类包含指向下一个状态的指针</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">NetworkState</span>&#123;</span><br><span class=\"line\">    Network_Open,</span><br><span class=\"line\">    Network_Close,</span><br><span class=\"line\">    Network_Connect</span><br><span class=\"line\">    <span class=\"comment\">// 假设未来有新状态：Network_Wait，怎么办？</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NetworkProcessor</span>&#123;</span><br><span class=\"line\">    NetworkState state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == Network_Open)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//**********</span></span><br><span class=\"line\">            state = Network_Close;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == Network_Close)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//..........</span></span><br><span class=\"line\">            state = Network_Connect;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == Network_Connect)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//$$$$$$$$$$</span></span><br><span class=\"line\">            state = Network_Open;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (state == Network_Open)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//**********</span></span><br><span class=\"line\">            state = Network_Connect;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == Network_Close)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//..........</span></span><br><span class=\"line\">            state = Network_Open;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (state == Network_Connect)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//$$$$$$$$$$</span></span><br><span class=\"line\">            state = Network_Close;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"状态v1\">3 状态v1</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg\" alt=\"状态模式\" /><figcaption aria-hidden=\"true\">状态模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把以前的枚举类型转换为抽象基类</span></span><br><span class=\"line\"><span class=\"comment\">// 再把以前的所有操作，作为状态对象的行为</span></span><br><span class=\"line\"><span class=\"comment\">// 最后再塞一个状态对像的指针</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NetworkState</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    NetworkState* pNext; <span class=\"comment\">// next指针</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">Operation3</span><span class=\"params\">()</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">NetworkState</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OpenState</span>: <span class=\"keyword\">public</span> NetworkState&#123;</span><br><span class=\"line\">    <span class=\"type\">static</span> NetworkState* m_instance; <span class=\"comment\">// 存放该类唯一实例的指针</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> NetworkState* <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">// 单例模式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_instance == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            m_instance = <span class=\"keyword\">new</span> <span class=\"built_in\">OpenState</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// **********</span></span><br><span class=\"line\">        pNext = CloseState::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ..........</span></span><br><span class=\"line\">        pNext = ConnectState::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// $$$$$$$$$$</span></span><br><span class=\"line\">        pNext = OpenState::<span class=\"built_in\">getInstance</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CloseState</span>: <span class=\"keyword\">public</span> NetworkState&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConnectionState</span>: <span class=\"keyword\">public</span> NetworkState&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以非常方便的添加扩展</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">WaitState</span>: <span class=\"keyword\">public</span> NetworkState&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NetworkProcessor</span>&#123;</span><br><span class=\"line\">    NetworkState* pState;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NetworkProcessor</span>(NetworkState* pState)&#123; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;pState = pState;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        pState-&gt;<span class=\"built_in\">Operation1</span>(); <span class=\"comment\">// 多态调用</span></span><br><span class=\"line\">        pState = pState-&gt;pNext; <span class=\"comment\">// 精妙</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        pState-&gt;<span class=\"built_in\">Operation2</span>(); <span class=\"comment\">// 多态调用</span></span><br><span class=\"line\">        pState = pState-&gt;pNext; <span class=\"comment\">// 精妙</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Operation3</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        pState-&gt;<span class=\"built_in\">Operation3</span>(); <span class=\"comment\">// 多态调用</span></span><br><span class=\"line\">        pState = pState-&gt;pNext; <span class=\"comment\">// 精妙</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"状态v2可执行\">4 状态v2（可执行）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IContext</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IState</span> &#123; <span class=\"comment\">// 某版直接包含IContext指针</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">IState</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doColock</span><span class=\"params\">(IContext *ctx, <span class=\"type\">int</span> hour)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doUse</span><span class=\"params\">(IContext *ctx)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doAlarm</span><span class=\"params\">(IContext *ctx)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doPhone</span><span class=\"params\">(IContext *ctx)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IContext</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">enum class</span> <span class=\"title class_\">ActionType</span> &#123;</span><br><span class=\"line\">        Use,</span><br><span class=\"line\">        Alarm,</span><br><span class=\"line\">        Phone</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">IContext</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doAction</span><span class=\"params\">(ActionType actionType)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">setClock</span><span class=\"params\">(<span class=\"type\">int</span> hour)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">stateChange</span><span class=\"params\">(IState *state)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">callSecurityCenter</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">recoderLog</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DayState</span> : <span class=\"keyword\">public</span> IState&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> DayState &amp;<span class=\"title\">GetInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> DayState s;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doColock</span><span class=\"params\">(IContext *ctx, <span class=\"type\">int</span> hour)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doUse</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span></span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">recoderLog</span>(<span class=\"string\">&quot;Day use &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doAlarm</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span></span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">callSecurityCenter</span>(<span class=\"string\">&quot;Day alarm&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doPhone</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span></span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">callSecurityCenter</span>(<span class=\"string\">&quot;Day phone&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">DayState</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"built_in\">DayState</span>(<span class=\"type\">const</span> DayState &amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"built_in\">DayState</span>(DayState &amp;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    DayState &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> DayState &amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    DayState &amp;<span class=\"keyword\">operator</span>=(DayState &amp;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">DayState</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NightState</span> : <span class=\"keyword\">public</span> IState &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> NightState &amp;<span class=\"title\">GetInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">static</span> NightState s;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doColock</span><span class=\"params\">(IContext *ctx, <span class=\"type\">int</span> hour)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doUse</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">callSecurityCenter</span>(<span class=\"string\">&quot;Night use &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doAlarm</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">callSecurityCenter</span>(<span class=\"string\">&quot;Night alarm&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doPhone</span><span class=\"params\">(IContext *ctx)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">recoderLog</span>(<span class=\"string\">&quot;Night phone&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">NightState</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NightState</span>(<span class=\"type\">const</span> NightState &amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NightState</span>(NightState &amp;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    NightState &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> NightState &amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    NightState &amp;<span class=\"keyword\">operator</span>=(NightState &amp;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NightState</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">DayState::doColock</span><span class=\"params\">(IContext *ctx, <span class=\"type\">int</span> hour)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hour &lt; <span class=\"number\">9</span> || hour &gt;= <span class=\"number\">17</span>) &#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">stateChange</span>(&amp;NightState::<span class=\"built_in\">GetInstance</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">NightState::doColock</span><span class=\"params\">(IContext *ctx, <span class=\"type\">int</span> hour)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hour &gt;= <span class=\"number\">9</span> &amp;&amp; hour &lt; <span class=\"number\">17</span>) &#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">stateChange</span>(&amp;DayState::<span class=\"built_in\">GetInstance</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SafeFrame</span> : <span class=\"keyword\">public</span> IContext&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SafeFrame</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">setClock</span><span class=\"params\">(<span class=\"type\">int</span> hour)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">doAction</span><span class=\"params\">(ActionType actionType)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">stateChange</span><span class=\"params\">(IState *state)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">callSecurityCenter</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">recoderLog</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    IState *m_state;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">SafeFrame::<span class=\"built_in\">SafeFrame</span>() : <span class=\"built_in\">m_state</span>(&amp;DayState::<span class=\"built_in\">GetInstance</span>()) &#123;&#125; <span class=\"comment\">// 初始化白天</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SafeFrame::setClock</span><span class=\"params\">(<span class=\"type\">int</span> hour)</span></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;now timw is &quot;</span> &lt;&lt; hour &lt;&lt; std::endl;</span><br><span class=\"line\">    m_state-&gt;<span class=\"built_in\">doColock</span>(<span class=\"keyword\">this</span>, hour);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SafeFrame::doAction</span><span class=\"params\">(ActionType actionType)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (actionType)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ActionType::Alarm:</span><br><span class=\"line\">        m_state-&gt;<span class=\"built_in\">doAlarm</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ActionType::Phone:</span><br><span class=\"line\">        m_state-&gt;<span class=\"built_in\">doPhone</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ActionType::Use:</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        m_state-&gt;<span class=\"built_in\">doUse</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SafeFrame::stateChange</span><span class=\"params\">(IState *state)</span></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class=\"line\">    m_state = state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SafeFrame::callSecurityCenter</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SafeFrame::recoderLog</span><span class=\"params\">(<span class=\"type\">const</span> std::string &amp;msg)</span></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    IContext *ctx = <span class=\"keyword\">new</span> SafeFrame;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">24</span>; ++i) &#123;</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">setClock</span>(i);</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">doAction</span>(IContext::ActionType::Use);</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">doAction</span>(IContext::ActionType::Phone);</span><br><span class=\"line\">        ctx-&gt;<span class=\"built_in\">doAction</span>(IContext::ActionType::Alarm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ctx;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">5 总结</h2>\r\n<ul>\r\n<li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。</li>\r\n<li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。</li>\r\n<li>如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。</li>\r\n</ul>\r\n<h2 id=\"参考\">6 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-策略模式","url":"/2022/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"策略模式\">1 策略模式</h2>\r\n<ul>\r\n<li>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。</li>\r\n<li>将算法与其它部分分离开，只定义与算法相关的接口，然后在程序中以委托的方式来使用。使用委托这种弱关联关系可以很方便地整体替换算法。程序运行过程中也可以替换算法</li>\r\n<li>策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">TaxBase</span> &#123;</span><br><span class=\"line\">    CN_Tax,</span><br><span class=\"line\">    US_Tax,</span><br><span class=\"line\">    DE_Tax,</span><br><span class=\"line\">    FR_Tax <span class=\"comment\">//更改：新添加</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SalesOrder</span>&#123;</span><br><span class=\"line\">    TaxBase tax;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">CalculateTax</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tax == CN_Tax)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//CN***********</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tax == US_Tax)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//US***********</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tax == DE_Tax)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//DE***********</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (tax == FR_Tax)&#123;  <span class=\"comment\">//更改</span></span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//....</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"策略v1\">3 策略v1</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg\" alt=\"策略模式\" /><figcaption aria-hidden=\"true\">策略模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽象基类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TaxStrategy</span>&#123; <span class=\"comment\">// 一般就放一个方法，当然也会放几个相关的方法，但是一般方法数都不多</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">Calculate</span><span class=\"params\">(<span class=\"type\">const</span> Context&amp; context)</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">TaxStrategy</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CNTax</span> : <span class=\"keyword\">public</span> TaxStrategy&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">Calculate</span><span class=\"params\">(<span class=\"type\">const</span> Context&amp; context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ***********</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">USTax</span> : <span class=\"keyword\">public</span> TaxStrategy&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">Calculate</span><span class=\"params\">(<span class=\"type\">const</span> Context&amp; context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ***********</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DETax</span> : <span class=\"keyword\">public</span> TaxStrategy&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">Calculate</span><span class=\"params\">(<span class=\"type\">const</span> Context&amp; context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ***********</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从而方便地进行扩展</span></span><br><span class=\"line\"><span class=\"comment\">// *********************************</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FRTax</span> : <span class=\"keyword\">public</span> TaxStrategy&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">double</span> <span class=\"title\">Calculate</span><span class=\"params\">(<span class=\"type\">const</span> Context&amp; context)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//.........</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SalesOrder</span>&#123; <span class=\"comment\">// 稳定</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    TaxStrategy* strategy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;strategy = strategyFactory-&gt;<span class=\"built_in\">NewStrategy</span>(); <span class=\"comment\">// 工厂模式</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">SalesOrder</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> <span class=\"keyword\">this</span>-&gt;strategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title\">CalculateTax</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"function\">Context <span class=\"title\">context</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"type\">double</span> val = strategy-&gt;<span class=\"built_in\">Calculate</span>(context); <span class=\"comment\">//多态调用</span></span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"策略v2可执行\">4 策略v2（可执行）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The Strategy interface declares operations common to all supported versions</span></span><br><span class=\"line\"><span class=\"comment\"> * of some algorithm.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * The Context uses this interface to call the algorithm defined by Concrete</span></span><br><span class=\"line\"><span class=\"comment\"> * Strategies.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Strategy</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Strategy</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> std::string <span class=\"title\">doAlgorithm</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; data)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The Context defines the interface of interest to clients.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Context</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The Context maintains a reference to one of the Strategy</span></span><br><span class=\"line\"><span class=\"comment\">     * objects. The Context does not know the concrete class of a strategy. It</span></span><br><span class=\"line\"><span class=\"comment\">     * should work with all strategies via the Strategy interface.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::unique_ptr&lt;Strategy&gt; strategy_;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Usually, the Context accepts a strategy through the constructor, but also</span></span><br><span class=\"line\"><span class=\"comment\">     * provides a setter to change it at runtime.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Context</span><span class=\"params\">(std::unique_ptr&lt;Strategy&gt; &amp;&amp;strategy = &#123;&#125;)</span> : strategy_(std::move(strategy)) &#123;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Usually, the Context allows replacing a Strategy object at runtime.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_strategy</span><span class=\"params\">(std::unique_ptr&lt;Strategy&gt; &amp;&amp;strategy)</span> </span>&#123;</span><br><span class=\"line\">        strategy_ = std::<span class=\"built_in\">move</span>(strategy);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * The Context delegates some work to the Strategy object instead of</span></span><br><span class=\"line\"><span class=\"comment\">     * implementing +multiple versions of the algorithm on its own.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">doSomeBusinessLogic</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (strategy_) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Context: Sorting data using the strategy (not sure how it&#x27;ll do it)\\n&quot;</span>;</span><br><span class=\"line\">            std::string result = strategy_-&gt;<span class=\"built_in\">doAlgorithm</span>(<span class=\"string\">&quot;aecbd&quot;</span>);</span><br><span class=\"line\">            std::cout &lt;&lt; result &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Context: Strategy isn&#x27;t set\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Concrete Strategies implement the algorithm while following the base Strategy</span></span><br><span class=\"line\"><span class=\"comment\"> * interface. The interface makes them interchangeable in the Context.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteStrategyA</span> : <span class=\"keyword\">public</span> Strategy &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">doAlgorithm</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; data)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::string <span class=\"title\">result</span><span class=\"params\">(data)</span></span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(std::<span class=\"built_in\">begin</span>(result), std::<span class=\"built_in\">end</span>(result));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConcreteStrategyB</span> : <span class=\"keyword\">public</span> Strategy &#123;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">doAlgorithm</span><span class=\"params\">(<span class=\"type\">const</span> std::string&amp; data)</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">std::string <span class=\"title\">result</span><span class=\"params\">(data)</span></span>;</span><br><span class=\"line\">        std::<span class=\"built_in\">sort</span>(std::<span class=\"built_in\">begin</span>(result), std::<span class=\"built_in\">end</span>(result), std::greater&lt;&gt;());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The client code picks a concrete strategy and passes it to the context. The</span></span><br><span class=\"line\"><span class=\"comment\"> * client should be aware of the differences between strategies in order to make</span></span><br><span class=\"line\"><span class=\"comment\"> * the right choice.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clientCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Context <span class=\"title\">context</span><span class=\"params\">(std::make_unique&lt;ConcreteStrategyA&gt;())</span></span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Client: Strategy is set to normal sorting.\\n&quot;</span>;</span><br><span class=\"line\">    context.<span class=\"built_in\">doSomeBusinessLogic</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Client: Strategy is set to reverse sorting.\\n&quot;</span>;</span><br><span class=\"line\">    context.<span class=\"built_in\">set_strategy</span>(std::<span class=\"built_in\">make_unique</span>&lt;ConcreteStrategyB&gt;());</span><br><span class=\"line\">    context.<span class=\"built_in\">doSomeBusinessLogic</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clientCode</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">5 总结</h2>\r\n<ul>\r\n<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li>\r\n<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。</li>\r\n<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。（单例模式）</li>\r\n</ul>\r\n<h2 id=\"参考\">6 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-观察者模式","url":"/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"观察者模式\">1 观察者模式</h2>\r\n<ul>\r\n<li>在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。</li>\r\n<li>定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</li>\r\n<li>观察对象的状态发生变化时，通知给观察者。 观察者模式适用于根据对象状态进行相应处理的场景。</li>\r\n</ul>\r\n<h2 id=\"问题\">2 问题</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FileSplitter.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSplitter</span>&#123;</span><br><span class=\"line\">    string m_filePath;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_fileNumber;</span><br><span class=\"line\">    ProgressBar* m_progressBar; <span class=\"comment\">// 不能应对变化，和具体某个平台的进度条绑死：例如UI进度条、无界面的Shell进度条等等</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">FileSplitter</span>(<span class=\"type\">const</span> string&amp; filePath, <span class=\"type\">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class=\"line\">        <span class=\"built_in\">m_filePath</span>(filePath), </span><br><span class=\"line\">        <span class=\"built_in\">m_fileNumber</span>(fileNumber),</span><br><span class=\"line\">        <span class=\"built_in\">m_progressBar</span>(progressBar)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.读取大文件</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.分批次向小文件中写入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"type\">float</span> progressValue = m_fileNumber;</span><br><span class=\"line\">            progressValue = (i + <span class=\"number\">1</span>) / progressValue;</span><br><span class=\"line\">            m_progressBar-&gt;<span class=\"built_in\">setValue</span>(progressValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MainForm.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainForm</span> : <span class=\"keyword\">public</span> Form&#123;</span><br><span class=\"line\">    TextBox* txtFilePath;</span><br><span class=\"line\">    TextBox* txtFileNumber;</span><br><span class=\"line\">    ProgressBar* progressBar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Button1_Click</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        string filePath = txtFilePath-&gt;<span class=\"built_in\">getText</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> number = <span class=\"built_in\">atoi</span>(txtFileNumber-&gt;<span class=\"built_in\">getText</span>().<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"function\">FileSplitter <span class=\"title\">splitter</span><span class=\"params\">(filePath, number, progressBar)</span></span>;</span><br><span class=\"line\">        splitter.<span class=\"built_in\">split</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"观察者v1\">3 观察者v1</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg\" alt=\"观察者模式\" /><figcaption aria-hidden=\"true\">观察者模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FileSplitter.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">FileSplitter</span>&#123;</span><br><span class=\"line\">    string m_filePath;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_fileNumber;</span><br><span class=\"line\">    List&lt;IProgress*&gt;  m_iprogressList; <span class=\"comment\">// 抽象通知机制，支持注册多个观察者！！！</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">FileSplitter</span>(<span class=\"type\">const</span> string&amp; filePath, <span class=\"type\">int</span> fileNumber) :</span><br><span class=\"line\">        <span class=\"built_in\">m_filePath</span>(filePath), </span><br><span class=\"line\">        <span class=\"built_in\">m_fileNumber</span>(fileNumber)&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">split</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.读取大文件</span></span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.分批次向小文件中写入</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...</span></span><br><span class=\"line\">            <span class=\"type\">float</span> progressValue = m_fileNumber;</span><br><span class=\"line\">            progressValue = (i + <span class=\"number\">1</span>) / progressValue;</span><br><span class=\"line\">            <span class=\"built_in\">onProgress</span>(progressValue); <span class=\"comment\">// 发送通知</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addIProgress</span><span class=\"params\">(IProgress* iprogress)</span></span>&#123; <span class=\"comment\">// 添加观察者</span></span><br><span class=\"line\">        m_iprogressList.<span class=\"built_in\">push_back</span>(iprogress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeIProgress</span><span class=\"params\">(IProgress* iprogress)</span></span>&#123; <span class=\"comment\">// 移除观察者</span></span><br><span class=\"line\">        m_iprogressList.<span class=\"built_in\">remove</span>(iprogress);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">onProgress</span><span class=\"params\">(<span class=\"type\">float</span> value)</span></span>&#123;</span><br><span class=\"line\">        List&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (itor != m_iprogressList.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">            (*itor)-&gt;<span class=\"built_in\">DoProgress</span>(value); <span class=\"comment\">//更新进度条</span></span><br><span class=\"line\">            itor++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MainForm.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IProgress</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">DoProgress</span><span class=\"params\">(<span class=\"type\">float</span> value)</span></span>=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">IProgress</span>()&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C++不推荐多继承，但是推荐的唯一一种多继承的形式是：一个主集成、其他都是接口或者抽象基类</span></span><br><span class=\"line\"><span class=\"comment\">// MainForm是观察者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MainForm</span> : <span class=\"keyword\">public</span> Form, <span class=\"keyword\">public</span> IProgress&#123;</span><br><span class=\"line\">    TextBox* txtFilePath;</span><br><span class=\"line\">    TextBox* txtFileNumber;</span><br><span class=\"line\">    ProgressBar* progressBar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Button1_Click</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        string filePath = txtFilePath-&gt;<span class=\"built_in\">getText</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> number = <span class=\"built_in\">atoi</span>(txtFileNumber-&gt;<span class=\"built_in\">getText</span>().<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        <span class=\"function\">FileSplitter <span class=\"title\">splitter</span><span class=\"params\">(filePath, number)</span></span>;</span><br><span class=\"line\">        splitter.<span class=\"built_in\">addIProgress</span>(<span class=\"keyword\">this</span>); <span class=\"comment\">// 订阅通知</span></span><br><span class=\"line\">        ConsoleNotifier cn; <span class=\"comment\">// 观察者二</span></span><br><span class=\"line\">        splitter.<span class=\"built_in\">addIProgress</span>(&amp;cn); <span class=\"comment\">// 订阅通知</span></span><br><span class=\"line\">        splitter.<span class=\"built_in\">split</span>();</span><br><span class=\"line\">        splitter.<span class=\"built_in\">removeIProgress</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">DoProgress</span><span class=\"params\">(<span class=\"type\">float</span> value)</span></span>&#123;</span><br><span class=\"line\">        progressBar-&gt;<span class=\"built_in\">setValue</span>(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一个观察者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ConsoleNotifier</span> : <span class=\"keyword\">public</span> IProgress &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">DoProgress</span><span class=\"params\">(<span class=\"type\">float</span> value)</span></span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;.&quot;</span>; <span class=\"comment\">// 无UI：打点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"观察者v2可执行\">4 观察者v2（可执行）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Header.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumGen</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumGenObserver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">NumGenObserver</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(NumGen *numGen)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumGen</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">NumGen</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addObserve</span><span class=\"params\">(NumGenObserver *observe)</span> </span>&#123;</span><br><span class=\"line\">        m_observeList.<span class=\"built_in\">push_back</span>(observe);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteObserve</span><span class=\"params\">(NumGenObserver *observe)</span> </span>&#123;</span><br><span class=\"line\">        m_observeList.<span class=\"built_in\">erase</span>(std::<span class=\"built_in\">remove</span>(m_observeList.<span class=\"built_in\">begin</span>(), m_observeList.<span class=\"built_in\">end</span>(), observe));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">notifyObverses</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> gen : m_observeList) &#123;</span><br><span class=\"line\">            gen-&gt;<span class=\"built_in\">update</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;NumGenObserver *&gt; m_observeList;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomNumGen</span> : <span class=\"keyword\">public</span> NumGen &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">getNumber</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_number;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; ++i) &#123;</span><br><span class=\"line\">            m_number = <span class=\"built_in\">m_dis</span>(m_gen);</span><br><span class=\"line\">            <span class=\"built_in\">notifyObverses</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::random_device m_rd;</span><br><span class=\"line\">    std::mt19937 m_gen&#123; <span class=\"built_in\">m_rd</span>() &#125;;</span><br><span class=\"line\">    std::uniform_int_distribution&lt;<span class=\"type\">int</span>&gt; m_dis&#123; <span class=\"number\">0</span>, <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_number&#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DigitObserver</span> : <span class=\"keyword\">public</span> NumGenObserver &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(NumGen *numGen)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;DigitObserver:&quot;</span>;</span><br><span class=\"line\">        std::cout &lt;&lt; numGen-&gt;<span class=\"built_in\">getNumber</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">milliseconds</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GraphObserver</span> : <span class=\"keyword\">public</span> NumGenObserver &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(NumGen *numGen)</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> num = numGen-&gt;<span class=\"built_in\">getNumber</span>();</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;GraphObserver:&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; num; ++i) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;*&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::cout &lt;&lt; std::endl;</span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">sleep_for</span>(std::chrono::<span class=\"built_in\">milliseconds</span>(<span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    NumGen *gen = <span class=\"keyword\">new</span> RandomNumGen;</span><br><span class=\"line\">    NumGenObserver *ob1 = <span class=\"keyword\">new</span> DigitObserver;</span><br><span class=\"line\">    NumGenObserver *ob2 = <span class=\"keyword\">new</span> GraphObserver;</span><br><span class=\"line\">    gen-&gt;<span class=\"built_in\">addObserve</span>(ob1);</span><br><span class=\"line\">    gen-&gt;<span class=\"built_in\">addObserve</span>(ob2);</span><br><span class=\"line\">    gen-&gt;<span class=\"built_in\">execute</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> gen;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ob1;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ob2;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"观察者v3配合模板更通用的观察者模式\">5 观察者v3（配合模板更通用的观察者模式）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> ObserverType&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Subject</span> &#123;</span><br><span class=\"line\">    vector&lt;ObserverType*&gt; _list;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 订阅</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">subscribe</span><span class=\"params\">(ObserverType* obs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">auto</span> itor = std::<span class=\"built_in\">find</span>(_list.<span class=\"built_in\">begin</span>(), _list.<span class=\"built_in\">end</span>(), obs);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_list.<span class=\"built_in\">end</span>() == itor) &#123;</span><br><span class=\"line\">            _list.<span class=\"built_in\">push_back</span>(obs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 取消订阅</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">unSubscribe</span><span class=\"params\">(ObserverType* obs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// erase配合remove</span></span><br><span class=\"line\">        _list.<span class=\"built_in\">erase</span>(std::<span class=\"built_in\">remove</span>(_list.<span class=\"built_in\">begin</span>(), _list.<span class=\"built_in\">end</span>(), obs));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发布</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> FuncType&gt;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">void</span> <span class=\"title\">publish</span><span class=\"params\">(FuncType func)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> obs : _list) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 调用回调函数，将obs作为一个参数传入</span></span><br><span class=\"line\">            <span class=\"built_in\">func</span>(obs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CatObserver接口 猫的观察者</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CatObserver</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">onMiaow</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">CatObserver</span>() &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Tom继承自Subject，模板参数CatObserver</span></span><br><span class=\"line\"><span class=\"comment\">// 这样Tom就可以订阅、发布对应类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Tom</span> : <span class=\"keyword\">public</span> Subject&lt;CatObserver&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">miaow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;喵&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"comment\">// 这里CatObserver的成员函数，所以第一个参数需要this指针，这里悬置-&gt;对应publish的object</span></span><br><span class=\"line\">        <span class=\"built_in\">publish</span>(std::<span class=\"built_in\">bind</span>(&amp;CatObserver::onMiaow, std::placeholders::_1));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Jerry继承自CatObserver，可以被订阅</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Jerry</span> : <span class=\"keyword\">public</span> CatObserver &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">onMiaow</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">RunAway</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">RunAway</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;那只笨又猫来了，快跑！&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Tom tom;</span><br><span class=\"line\">    Jerry jerry1, jerry2, jerry3;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拿一堆jerry去订阅tom的 猫叫 事件</span></span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry1);</span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry2);</span><br><span class=\"line\">    tom.<span class=\"built_in\">subscribe</span>(&amp;jerry3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    tom.<span class=\"built_in\">miaow</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>输出结果： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">喵</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br><span class=\"line\">那只笨又猫来了，快跑！</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"总结\">6 总结</h2>\r\n<ul>\r\n<li>使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。</li>\r\n<li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li>\r\n<li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li>\r\n<li>Observer模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。</li>\r\n</ul>\r\n<h2 id=\"参考\">7 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-迭代器模式","url":"/2022/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"迭代器模式\">1 迭代器模式</h2>\r\n<ul>\r\n<li>在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“诱明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。</li>\r\n<li>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示</li>\r\n<li>访问一个聚合对象的内容而无需暴露其内部实现；支持对聚合对象的多种遍历；为遍历不同的聚合结构提供统一的接口；健壮性考虑：遍历的同时更改迭代器所在聚合结构，会导致问题</li>\r\n<li><strong>该篇介绍的是基于面向对象的迭代器实现，但是C++泛型编程迭代器已经淘汰掉面向对象的迭代器，然而思想一样，技术更新而已</strong></li>\r\n</ul>\r\n<h2 id=\"迭代器v1\">2 迭代器v1</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg\" alt=\"迭代器模式\" /><figcaption aria-hidden=\"true\">迭代器模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">C++现在都是基于模板的迭代器，模板又称为编译时多态，速度肯定比虚函数的运行时多态要好很多</span></span><br><span class=\"line\"><span class=\"comment\">但是java、C#、PHP、Swift还是这种基于虚函数的迭代器（因为不支持编译时的模板机制）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Iterator</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">first</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> T&amp; <span class=\"title\">current</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCollection</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Iterator&lt;T&gt;* <span class=\"title\">GetIterator</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CollectionIterator</span> : <span class=\"keyword\">public</span> Iterator&lt;T&gt;&#123;</span><br><span class=\"line\">    MyCollection&lt;T&gt; mc;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CollectionIterator</span>(<span class=\"type\">const</span> MyCollection&lt;T&gt;&amp; c): <span class=\"built_in\">mc</span>(c)&#123; &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">first</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">T&amp; <span class=\"title\">current</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">MyAlgorithm</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    MyCollection&lt;<span class=\"type\">int</span>&gt; mc;</span><br><span class=\"line\">    Iterator&lt;<span class=\"type\">int</span>&gt;* iter = mc.<span class=\"built_in\">GetIterator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (iter-&gt;<span class=\"built_in\">first</span>(); !iter-&gt;<span class=\"built_in\">isDone</span>(); iter-&gt;<span class=\"built_in\">next</span>())&#123; <span class=\"comment\">// 多态</span></span><br><span class=\"line\">        cout &lt;&lt; iter-&gt;<span class=\"built_in\">current</span>() &lt;&lt; endl; <span class=\"comment\">// 多态</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"迭代器v2可执行\">3 迭代器v2（可执行）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * C++ has its own implementation of iterator that works with a different</span></span><br><span class=\"line\"><span class=\"comment\"> * generics containers defined by the standard library.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Iterator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> std::vector&lt;T&gt;::iterator iter_type;</span><br><span class=\"line\">    <span class=\"built_in\">Iterator</span>(U *p_data) : <span class=\"built_in\">m_p_data_</span>(p_data) &#123;</span><br><span class=\"line\">        m_it_ = m_p_data_-&gt;m_data_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">First</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        m_it_ = m_p_data_-&gt;m_data_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        m_it_++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">IsDone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (m_it_ == m_p_data_-&gt;m_data_.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">iter_type <span class=\"title\">Current</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_it_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    U *m_p_data_;</span><br><span class=\"line\">    iter_type m_it_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Generic Collections/Containers provides one or several methods for retrieving</span></span><br><span class=\"line\"><span class=\"comment\"> * fresh iterator instances, compatible with the collection class.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Container</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Iterator</span>&lt;T, Container&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Add</span><span class=\"params\">(T a)</span> </span>&#123;</span><br><span class=\"line\">        m_data_.<span class=\"built_in\">push_back</span>(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">Iterator&lt;T, Container&gt; *<span class=\"title\">CreateIterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Iterator</span>&lt;T, Container&gt;(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;T&gt; m_data_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Data</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Data</span>(<span class=\"type\">int</span> a = <span class=\"number\">0</span>) : <span class=\"built_in\">m_data_</span>(a) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_data</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123;</span><br><span class=\"line\">        m_data_ = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_data_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> m_data_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The client code may or may not know about the Concrete Iterator or Collection</span></span><br><span class=\"line\"><span class=\"comment\"> * classes, for this implementation the container is generic so you can used</span></span><br><span class=\"line\"><span class=\"comment\"> * with an int or with a custom class.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClientCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;__________Iterator with int__________&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    Container&lt;<span class=\"type\">int</span>&gt; cont;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">        cont.<span class=\"built_in\">Add</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Iterator&lt;<span class=\"type\">int</span>, Container&lt;<span class=\"type\">int</span>&gt;&gt; *it = cont.<span class=\"built_in\">CreateIterator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (it-&gt;<span class=\"built_in\">First</span>(); !it-&gt;<span class=\"built_in\">IsDone</span>(); it-&gt;<span class=\"built_in\">Next</span>()) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; *it-&gt;<span class=\"built_in\">Current</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Container&lt;Data&gt; cont2;</span><br><span class=\"line\">    <span class=\"function\">Data <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">100</span>)</span>, <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">1000</span>)</span>, <span class=\"title\">c</span><span class=\"params\">(<span class=\"number\">10000</span>)</span></span>;</span><br><span class=\"line\">    cont2.<span class=\"built_in\">Add</span>(a);</span><br><span class=\"line\">    cont2.<span class=\"built_in\">Add</span>(b);</span><br><span class=\"line\">    cont2.<span class=\"built_in\">Add</span>(c);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;__________Iterator with custom Class__________&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    Iterator&lt;Data, Container&lt;Data&gt;&gt; *it2 = cont2.<span class=\"built_in\">CreateIterator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (it2-&gt;<span class=\"built_in\">First</span>(); !it2-&gt;<span class=\"built_in\">IsDone</span>(); it2-&gt;<span class=\"built_in\">Next</span>()) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; it2-&gt;<span class=\"built_in\">Current</span>()-&gt;<span class=\"built_in\">data</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> it;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> it2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">ClientCode</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"迭代器v3可执行\">4 迭代器v3（可执行）</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Iterator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Iterator</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Item <span class=\"title\">next</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Aggregate</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Aggregate</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Iterator&lt;Item&gt; *<span class=\"title\">CreateIterator</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前置声明</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BookSelfIterator</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BookSelf</span> : <span class=\"keyword\">public</span> Aggregate&lt;Item&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BookSelf</span>(<span class=\"type\">int</span> maxSize) &#123;</span><br><span class=\"line\">        m_books.<span class=\"built_in\">resize</span>(maxSize, std::<span class=\"built_in\">string</span>(<span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">Iterator&lt;Item&gt;* <span class=\"title\">CreateIterator</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">BookSelfIterator</span>&lt;Item&gt;(<span class=\"keyword\">this</span>); <span class=\"comment\">// 传入this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">Item <span class=\"title\">GetBookAt</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_books.<span class=\"built_in\">at</span>(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">appendBoox</span><span class=\"params\">(<span class=\"type\">const</span> Item &amp;book)</span> </span>&#123;</span><br><span class=\"line\">        m_books.<span class=\"built_in\">emplace_back</span>(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(m_books.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::vector&lt;Item&gt; m_books;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Item</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BookSelfIterator</span> : <span class=\"keyword\">public</span> Iterator&lt;Item&gt; &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BookSelfIterator</span>(BookSelf&lt;Item&gt; *bookSelf) : <span class=\"built_in\">m_bookSelf</span>(bookSelf) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_bookSelf-&gt;<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span> &amp;&amp; m_currentIndex &lt; m_bookSelf-&gt;<span class=\"built_in\">length</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> Item <span class=\"title\">next</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        m_currentIndex++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_bookSelf-&gt;<span class=\"built_in\">GetBookAt</span>(m_currentIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    BookSelf&lt;Item&gt; *m_bookSelf;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_currentIndex = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Book</span>(<span class=\"type\">const</span> std::string &amp;name) : <span class=\"built_in\">m_name</span>(name) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> std::string &amp;<span class=\"title\">GetName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">BookSelf&lt;Book&gt; <span class=\"title\">container</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">    container.<span class=\"built_in\">appendBoox</span>(<span class=\"built_in\">Book</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;name1&quot;</span>)));</span><br><span class=\"line\">    container.<span class=\"built_in\">appendBoox</span>(<span class=\"built_in\">Book</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;name2&quot;</span>)));</span><br><span class=\"line\">    container.<span class=\"built_in\">appendBoox</span>(<span class=\"built_in\">Book</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;name3&quot;</span>)));</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> itor = container.<span class=\"built_in\">CreateIterator</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (itor-&gt;<span class=\"built_in\">hasNext</span>()) &#123;</span><br><span class=\"line\">        Book book = itor-&gt;<span class=\"built_in\">next</span>();</span><br><span class=\"line\">        cout &lt;&lt; book.<span class=\"built_in\">GetName</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> itor;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"总结\">5 总结</h2>\r\n<ul>\r\n<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</li>\r\n<li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>\r\n<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li>\r\n</ul>\r\n<h2 id=\"参考\">6 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"设计模式-适配器模式","url":"/2022/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"适配器模式\">1 适配器模式</h2>\r\n<ul>\r\n<li>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。</li>\r\n<li>将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li>\r\n</ul>\r\n<h2 id=\"适配器v1\">2 适配器v1</h2>\r\n<figure>\r\n<img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg\" alt=\"适配器模式\" /><figcaption aria-hidden=\"true\">适配器模式</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目标接口（新接口）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ITarget</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遗留接口（老接口）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">IAdaptee</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"type\">int</span> data)</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遗留类型</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">OldClass</span>: <span class=\"keyword\">public</span> IAdaptee&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"type\">int</span> data)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">bar</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象适配器（推荐）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Adapter</span>: <span class=\"keyword\">public</span> ITarget&#123; <span class=\"comment\">// 继承</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    IAdaptee* pAdaptee; <span class=\"comment\">// 组合（多态）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Adapter</span>(IAdaptee* pAdaptee)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;pAdaptee=pAdaptee;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> data=pAdaptee-&gt;<span class=\"built_in\">bar</span>();</span><br><span class=\"line\">        pAdaptee-&gt;<span class=\"built_in\">foo</span>(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类适配器（十分不推荐）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Adapter</span>: <span class=\"keyword\">public</span> ITarget, <span class=\"keyword\">protected</span> OldClass&#123; <span class=\"comment\">// 多继承（无复用性，绑死OldClass）</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    IAdaptee* pAdaptee = <span class=\"keyword\">new</span> <span class=\"built_in\">OldClass</span>(); <span class=\"comment\">// 老接口</span></span><br><span class=\"line\">    ITarget* pTarget = <span class=\"keyword\">new</span> <span class=\"built_in\">Adapter</span>(pAdaptee);</span><br><span class=\"line\">    pTarget-&gt;<span class=\"built_in\">process</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">stack</span>&#123; <span class=\"comment\">// STL中stack包含deque，看作是种适配器</span></span><br><span class=\"line\">    deqeue container;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">queue</span>&#123; <span class=\"comment\">// STL中queue包含deque，看作是种适配器</span></span><br><span class=\"line\">    deqeue container;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"适配器v2可执行\">3 适配器v2（可执行）</h2>\r\n<p>对象适配器（继承新+组合旧） <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// The Target defines the domain-specific interface used by the client code.</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Target</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Target</span>() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> std::string <span class=\"title\">Request</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Target: The default target&#x27;s behavior.&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The Adaptee contains some useful behavior, but its interface is incompatible</span></span><br><span class=\"line\"><span class=\"comment\"> * with the existing client code. The Adaptee needs some adaptation before the</span></span><br><span class=\"line\"><span class=\"comment\"> * client code can use it.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Adaptee</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">SpecificRequest</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;.eetpadA eht fo roivaheb laicepS&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span></span><br><span class=\"line\"><span class=\"comment\"> * interface.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Adapter</span> : <span class=\"keyword\">public</span> Target &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Adaptee *adaptee_;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Adapter</span>(Adaptee *adaptee) : <span class=\"built_in\">adaptee_</span>(adaptee) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">Request</span><span class=\"params\">()</span> <span class=\"type\">const</span> <span class=\"keyword\">override</span> </span>&#123;</span><br><span class=\"line\">        std::string to_reverse = <span class=\"keyword\">this</span>-&gt;adaptee_-&gt;<span class=\"built_in\">SpecificRequest</span>();</span><br><span class=\"line\">        std::<span class=\"built_in\">reverse</span>(to_reverse.<span class=\"built_in\">begin</span>(), to_reverse.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Adapter: (TRANSLATED) &quot;</span> + to_reverse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The client code supports all classes that follow the Target interface.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ClientCode</span><span class=\"params\">(<span class=\"type\">const</span> Target *target)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; target-&gt;<span class=\"built_in\">Request</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Client: I can work just fine with the Target objects:\\n&quot;</span>;</span><br><span class=\"line\">    Target *target = <span class=\"keyword\">new</span> Target;</span><br><span class=\"line\">    <span class=\"built_in\">ClientCode</span>(target);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\">    Adaptee *adaptee = <span class=\"keyword\">new</span> Adaptee;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Adaptee: &quot;</span> &lt;&lt; adaptee-&gt;<span class=\"built_in\">SpecificRequest</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n\\n&quot;</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Client: But I can work with it via the Adapter:\\n&quot;</span>;</span><br><span class=\"line\">    Adapter *adapter = <span class=\"keyword\">new</span> <span class=\"built_in\">Adapter</span>(adaptee);</span><br><span class=\"line\">    <span class=\"built_in\">ClientCode</span>(adapter);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> target;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> adaptee;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> adapter;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"总结\">4 总结</h2>\r\n<ul>\r\n<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用坏境要求不一致的情况\"，在遗留代码复用、类库迁移等方面非常有用。</li>\r\n<li>GoF-23定义了两种Adapter模式的实现结构∶对象适配器和类适配器。但类适配器采用“多继承\"的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li>\r\n<li>Adapter模式可以实现的非常寻活，不必拘泥于GoF-23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的</li>\r\n</ul>\r\n<h2 id=\"参考\">5 参考</h2>\r\n<ul>\r\n<li>《设计模式》 GoF</li>\r\n<li>李建忠设计模式</li>\r\n<li><a href=\"https://github.com/jaredtao/DesignPattern\">C++ 23种设计模式</a></li>\r\n<li><a href=\"https://refactoringguru.cn/design-patterns/cpp\">设计模式</a></li>\r\n</ul>\r\n","tags":["设计模式"]},{"title":"路径搜索","url":"/2022/04/07/%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2/","content":"<h1 id=\"辅助代码全局变量\">辅助代码（全局变量）</h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; node;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; G = &#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> row = (<span class=\"type\">int</span>)G.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"><span class=\"type\">int</span> col = (<span class=\"type\">int</span>)G[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">node S = &#123; <span class=\"number\">5</span>,<span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">node E = &#123; <span class=\"number\">5</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dir[] = &#123; <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span> &#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"dfs\">DFS</h1>\r\n<ul>\r\n<li><strong>DFS是无法找到最优路径的</strong>（理论上可以，但是复杂度巨高，如果是四个方向搜索的话，那么就是四叉树，高度是图中结点数，也就是说如果是10x10的图，那就是大约4^100复杂度）</li>\r\n<li>下面代码只表示找到任意一条路后直接返回 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">visited</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(col, <span class=\"literal\">false</span>));</span><br><span class=\"line\">vector&lt;node&gt; path;</span><br><span class=\"line\"><span class=\"type\">bool</span> END = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(node cur)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cur == E) </span><br><span class=\"line\">        END = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    visited[cur.first][cur.second] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    path.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span> &amp;&amp; !END; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ix = cur.first + dir[i];</span><br><span class=\"line\">        <span class=\"type\">int</span> iy = cur.second + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col || visited[ix][iy]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(&#123; ix, iy &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (END) <span class=\"keyword\">return</span>; <span class=\"comment\">// 保留路径</span></span><br><span class=\"line\">    path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    visited[cur.first][cur.second] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"bfs\">BFS</h1>\r\n<ul>\r\n<li>BFS是可以找到最优路径的，每次到某点的距离变小时就将其加入队列</li>\r\n<li><strong>不可以提前结束</strong>，无法确定是否能够通过后面的点来缩短到终点的距离 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    queue&lt;node&gt; qe;</span><br><span class=\"line\">    qe.<span class=\"built_in\">push</span>(S);</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">10000</span>));</span><br><span class=\"line\">    dist[S.first][S.second] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        node cur = qe.<span class=\"built_in\">front</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> ix = cur.first + dir[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> iy = cur.second + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[ix][iy] &gt; dist[cur.first][cur.second] + G[ix][iy]) &#123;</span><br><span class=\"line\">                dist[ix][iy] = dist[cur.first][cur.second] + G[ix][iy];</span><br><span class=\"line\">                qe.<span class=\"built_in\">emplace</span>(ix, iy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"dijkstra\">Dijkstra</h1>\r\n<ul>\r\n<li>每次弹出优先队列的都是确定下来的最优解，因此可以接触终点时直接<code>break</code>提前结束</li>\r\n<li>也不需要visited数组，因为遇到重复的x和y时，优先队列会依照priority排列，大的自动排到后面，由于接触到终点直接break，那些非最优的都没机会弹出队列。</li>\r\n<li>你可能会想到有没有这种可能绕一个大圈然后使得到达终点的距离进一步降低？其实不可能的，因为优先队列的贪心思想，反证法：如果之前已经将E弹出，后面又经过X到达E使得dist(E)降低；但是既然后面再弹出的X，那证明X的dist比之前第一次弹出的E的dist要大(优先队列先弹出dist小的)，那如何能使得经过X后让E的dist减小呢？矛盾！ <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">item</span>&#123; <span class=\"comment\">// 存放在优先队列的结构体</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"type\">int</span> priority;</span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> item&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;priority &gt; ano.priority;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    priority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">1000</span>)); <span class=\"comment\">// dist二维数组</span></span><br><span class=\"line\">    qe.<span class=\"built_in\">push</span>(&#123; S.first, S.second, <span class=\"number\">0</span> &#125;); <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    dist[S.first][S.second] = <span class=\"number\">0</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        item cur = qe.<span class=\"built_in\">top</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 找到后可以直接返回，这里贪心算法，确保是最优解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur.x == E.first &amp;&amp; cur.y == E.second) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> ix = cur.x + dir[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> iy = cur.y + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[ix][iy] &gt; cur.priority + G[ix][iy]) &#123;</span><br><span class=\"line\">                dist[ix][iy] = cur.priority + G[ix][iy];</span><br><span class=\"line\">                qe.<span class=\"built_in\">push</span>(&#123; ix, iy, dist[ix][iy] &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"a星\">A星</h1>\r\n<ul>\r\n<li>A星的思想是对Dijkstra的一点改进。首先BFS是没有方向的，Dijkstra是在BFS之上加入了贪心思想，但是同样没有方向，A星则是增加了终点方向的属性，并入到Dijkstra的优先级中，参与优先队列的弹出选择，对于能明确表明与终点距离的图问题来说，效果相当不错。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">item</span>&#123; <span class=\"comment\">// 存放在优先队列的结构体</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">    <span class=\"type\">int</span> p1; <span class=\"comment\">// 从起点到该点的 dist (与实际图权值相关，如果无权图则退化为曼哈顿距离)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> p2; <span class=\"comment\">// 从该点到终点的 [曼哈顿距离] </span></span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> item&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1 + p2 &gt; ano.p1 + ano.p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取曼哈顿距离的函数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> getP2 = [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;<span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(E.first - x) + <span class=\"built_in\">abs</span>(E.second - y); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">aStar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    priority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">1000</span>)); <span class=\"comment\">// dist二维数组</span></span><br><span class=\"line\">    qe.<span class=\"built_in\">push</span>(&#123; S.first, S.second, <span class=\"number\">0</span>, <span class=\"built_in\">getP2</span>(S.first, S.second)&#125;); <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    dist[S.first][S.second] = <span class=\"number\">0</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">        item cur = qe.<span class=\"built_in\">top</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 找到后可以直接返回，这里贪心算法，确保是最优解</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur.x == E.first &amp;&amp; cur.y == E.second) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> ix = cur.x + dir[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> iy = cur.y + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[ix][iy] &gt; cur.p1 + G[ix][iy]) &#123;</span><br><span class=\"line\">                dist[ix][iy] = cur.p1 + G[ix][iy];</span><br><span class=\"line\">                qe.<span class=\"built_in\">push</span>(&#123; ix, iy, dist[ix][iy], <span class=\"built_in\">getP2</span>(ix, iy) &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n","tags":["算法","图"]},{"title":"读者写者问题","url":"/2021/08/27/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/","content":"<blockquote>\r\n<p><strong>经典读者写者问题</strong></p>\r\n</blockquote>\r\n<h3 id=\"读者写者问题\">读者写者问题</h3>\r\n<h5 id=\"读者优先\">1、读者优先</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> readcount=<span class=\"number\">0</span>; </span><br><span class=\"line\">semaphore RCSignal=<span class=\"number\">1</span>, fileSrc=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// RCSignal readcount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// fileSrc 文件资源互斥量：实现读者优先</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读者进程：</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">    readcount++;    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readcount == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// reading is performed</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">    readcount--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readcount == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 写者进程：     </span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//writing is performed</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"built_in\">V</span>(fileSrc);</span><br></pre></td></tr></table></figure>\r\n<h5 id=\"写者优先\">2、写者优先</h5>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> readcount=<span class=\"number\">0</span>, writecount=<span class=\"number\">0</span>; </span><br><span class=\"line\">semaphore RCSignal=<span class=\"number\">1</span>, WCSignal=<span class=\"number\">1</span>, read=<span class=\"number\">1</span>, fileSrc;</span><br><span class=\"line\"><span class=\"comment\">// RCSignal readcount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// WCSignal writecount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// read 实现写者优先：拦截读者</span></span><br><span class=\"line\"><span class=\"comment\">// fileSrc 文件资源互斥量：保护剩余读者（拦截写者），以及写者唯一</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读者进程：</span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(read);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">        readcount++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(readcount == <span class=\"number\">1</span> ) </span><br><span class=\"line\">            <span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(read);</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// reading is performed</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">    readcount--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readcount == <span class=\"number\">0</span> )</span><br><span class=\"line\">        <span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写者进程：     </span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(WCSingal);</span><br><span class=\"line\">    writecount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writecount == <span class=\"number\">1</span> )</span><br><span class=\"line\">        <span class=\"built_in\">P</span>(read);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(WCSingal);</span><br><span class=\"line\"><span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"comment\">// writing is performed</span></span><br><span class=\"line\"><span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\"><span class=\"built_in\">P</span>(WCSingal);</span><br><span class=\"line\">    writecount --;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writecount == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"built_in\">V</span>(read);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(WCSingal); </span><br></pre></td></tr></table></figure>\r\n<h5 id=\"参考资料\">参考资料</h5>\r\n<p>https://www.bilibili.com/video/av21593625 https://blog.csdn.net/c1194758555/article/details/52805918 https://blog.csdn.net/william_munch/article/details/84256690 （有问题？）</p>\r\n","tags":["OS"]},{"title":"逆序对","url":"/2022/09/01/%E9%80%86%E5%BA%8F%E5%AF%B9/","content":"<h1 id=\"逆序对计算\"><a href=\"https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/\">逆序对计算</a></h1>\r\n<h2 id=\"归并排序\">1 归并排序</h2>\r\n<p>归并排序天然就可统计逆序对，在归并时有以下两种方式统计：</p>\r\n<p>当左侧当前指针指向位置的数字CUR较小时，本轮将其加入归并后的数组，注意到右数组当前指针左边的都是小于CUR的，但是他们位置却在其右侧，所以逆序对贡献为<code>l2-old_l2</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &lt;= b) &#123; <span class=\"comment\">// 这里包含等于 可以用全1数组模拟想想</span></span><br><span class=\"line\">    trr[p++] = arr[l1++];</span><br><span class=\"line\">    ret += (l2-old_l2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> </span><br><span class=\"line\">    trr[p++] = arr[l2++];</span><br></pre></td></tr></table></figure> 当右侧当前指针指向位置的数字CUR较小时，本轮将其加入归并后的数组，注意到左数组当前指针及其右边都是大于CUR的，但是他们的位置却在其左侧，所以逆序对的贡献为<code>old_l2 - l1</code> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a &lt;= b)  <span class=\"comment\">// 这里包含等于 可以用全1数组模拟想想</span></span><br><span class=\"line\">    trr[p++] = arr[l1++];</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    trr[p++] = arr[l2++];</span><br><span class=\"line\">    ret += (old_l2 - l1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure> 下面是完整代码 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l1, <span class=\"type\">int</span> r1, <span class=\"type\">int</span> l2, <span class=\"type\">int</span> r2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = l1, r = r2;</span><br><span class=\"line\">        <span class=\"type\">int</span> p = l1, old_l2 = l2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 &lt;= r1 || l2 &lt;= r2) &#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> a = l1 &lt;= r1 ? arr[l1] : LLONG_MAX;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"type\">long</span> b = l2 &lt;= r2 ? arr[l2] : LLONG_MAX;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt;= b) &#123; <span class=\"comment\">// !!!!! &lt;= 等于时也必须，不然右侧添加一堆等于的，再计算，结果肯定大了呀</span></span><br><span class=\"line\">                trr[p++] = arr[l1++];</span><br><span class=\"line\">                ret += (l2-old_l2); <span class=\"comment\">// 只需要在这里加上这句，收集逆序对</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                trr[p++] = arr[l2++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i)</span><br><span class=\"line\">            arr[i] = trr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">core</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(arr, trr, l, m);</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(arr, trr, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"built_in\">merge</span>(arr, trr, l, m, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(nums.size())</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(nums, trr, <span class=\"number\">0</span>, (<span class=\"type\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"离散化树状数组\">2 离散化+树状数组</h2>\r\n<p>树状数组可以非常方便进行区间统计和单点修改，对于原数组，我们从后往前遍历，依次将其加入树状数组（计数），并求其左侧（小于的）之前的所有已插入的数字的和，最终即可求得总的逆序对。然而，原数组的数值范围波动较大，不能直接用树状数组去记录，其间必有许多0表现出极大的稀疏性，因此需要对原数组进行离散化。所谓离散化，即将原数组映射到1~N的数据范围，让数据的范围全部聚集在一起，减少空间浪费，有利于树状数组发挥。因为在该问题中我们不关心数据的绝对大小，仅关心数据的相对大小，所以可以离散化。离散化需要借助偏向的二分查找进行。</p>\r\n<p>对于数组<code>[1,3,2,4,1]</code>，离散化后的结果是<code>1,4,3,5,1</code>，程序处理过程中树状数组的变化为（树状数组0位弃用）： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于原数组 [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">从后往前遍历 <span class=\"number\">1</span>-&gt;<span class=\"number\">5</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">1</span></span><br><span class=\"line\">X    [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]   ret = <span class=\"number\">0</span> 初始</span><br><span class=\"line\"><span class=\"number\">1</span>    [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]   ret = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">5</span>    [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]   ret = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3</span>    [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]   ret = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4</span>    [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]   ret = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">1</span>    [<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]   ret = <span class=\"number\">4</span></span><br><span class=\"line\">最终逆序对即为<span class=\"number\">4</span></span><br></pre></td></tr></table></figure> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 树状数组</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Trr</span> &#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; trr;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> a)</span> </span>&#123; <span class=\"keyword\">return</span> a &amp; -a; &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Trr</span>(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; arr) : <span class=\"built_in\">trr</span>(arr.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (t &lt; trr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                trr[t] += arr[i];</span><br><span class=\"line\">                t += <span class=\"built_in\">lowbit</span>(t);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123; <span class=\"comment\">// from 1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n) &#123;</span><br><span class=\"line\">            ret += trr[n];</span><br><span class=\"line\">            n -= <span class=\"built_in\">lowbit</span>(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> diff)</span> </span>&#123; <span class=\"comment\">// from 1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pos &lt; trr.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            trr[pos] += diff;</span><br><span class=\"line\">            pos += <span class=\"built_in\">lowbit</span>(pos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 离散化(nlogn)</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(nums)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : nums)</span><br><span class=\"line\">            e = <span class=\"built_in\">lower_bound</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>(), e) - tmp.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 树状数组统计逆序对(nlogn)</span></span><br><span class=\"line\">        <span class=\"function\">Trr <span class=\"title\">trr</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;(nums.size()))</span></span>; <span class=\"comment\">// 初始化全0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">            trr.<span class=\"built_in\">update</span>(nums[i], <span class=\"number\">1</span>);</span><br><span class=\"line\">            ret += trr.<span class=\"built_in\">query</span>(nums[i] - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"小记\">小记</h2>\r\n<ul>\r\n<li>已知的树状数组的两种用途\r\n<ul>\r\n<li>原数组的下标作为索引，进行区间统计和修改</li>\r\n<li>原数组的值作为下标，进行区间计数（本题）</li>\r\n</ul></li>\r\n</ul>\r\n","tags":["算法","特殊","树","排序"]},{"title":"链表去重","url":"/2022/03/20/%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","content":"<h1 id=\"删除排序链表中重复元素\">83 <a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\">删除排序链表中重复元素</a></h1>\r\n<h2 id=\"前序遍历\">前序遍历</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* ptr = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr &amp;&amp; head-&gt;val == ptr-&gt;val) ptr = ptr-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下面俩方式效果一样</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(ptr);</span><br><span class=\"line\">        <span class=\"comment\">// head-&gt;next = ptr;</span></span><br><span class=\"line\">        <span class=\"comment\">// deleteDuplicates(ptr);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"后续遍历\">后续遍历</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"comment\">// 有点像并查集里的路径压缩</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"迭代法\">迭代法</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) </span><br><span class=\"line\">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"迭代法双指针\">迭代法：双指针</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast-&gt;val != slow-&gt;val)&#123;</span><br><span class=\"line\">                slow-&gt;next = fast;</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似于数组去重，一模一样</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> slow = <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &lt; nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class=\"line\">                nums[++slow] = nums[fast];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++fast;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"删除排序链表中的重复元素ⅱ\">82 <a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\">删除排序链表中的重复元素Ⅱ</a></h1>\r\n<h2 id=\"递归\">递归</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> prev = INT_MAX;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head) prev = head-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head &amp;&amp; head-&gt;val == prev) <span class=\"comment\">// 如果要delete，在这里</span></span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head &amp;&amp; head-&gt;val &lt; prev) <span class=\"comment\">// 小于号很重要，因为是递增链表，防止prev更新旧值</span></span><br><span class=\"line\">            prev = head-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"递归2类似83后续遍历\">递归2(类似83后续遍历)</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> prev = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"comment\">// 有点像并查集里的路径压缩</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class=\"line\">            prev = head-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;val == prev)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"迭代\">迭代</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(INT_MAX, head);</span><br><span class=\"line\">        ListNode* ptr = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr)&#123;</span><br><span class=\"line\">            ListNode* cur = ptr-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur &amp;&amp; cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class=\"line\">                cur = cur-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur == ptr-&gt;next) <span class=\"comment\">// 下一步没重复，放心走</span></span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">// 有重复 cur必不为nullptr，否则就是没重复那步</span></span><br><span class=\"line\">                ptr-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","tags":["算法","特殊"]},{"title":"链表排序","url":"/2022/04/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","content":"<h1 id=\"插入排序\">1. 插入排序</h1>\r\n<ul>\r\n<li>只要注意每次判断比前面的大那就不需要回头</li>\r\n<li>否则需要从头找合适的位置 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">insertSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode dummy; dummy.next = head;</span><br><span class=\"line\">    ListNode* prev = head;</span><br><span class=\"line\">    ListNode* curr = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev-&gt;val &lt;= curr-&gt;val) &#123;</span><br><span class=\"line\">            prev = curr;</span><br><span class=\"line\">            curr = curr-&gt;next;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ListNode* t = &amp;dummy;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (t-&gt;next &amp;&amp; t-&gt;next-&gt;val &lt;= curr-&gt;val) t = t-&gt;next;</span><br><span class=\"line\">            prev-&gt;next = curr-&gt;next;</span><br><span class=\"line\">            curr-&gt;next = t-&gt;next;</span><br><span class=\"line\">            t-&gt;next = curr;</span><br><span class=\"line\">            curr = prev-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"归并排序\">2. 归并排序</h1>\r\n<ul>\r\n<li>不论是主递归还是merge都要求两个链表以nullptr结尾</li>\r\n<li>也就是在合适的地方断开</li>\r\n</ul>\r\n<h2 id=\"递归版本\">2.1 递归版本</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoList</span><span class=\"params\">(ListNode* p2a, ListNode* p2b)</span> </span>&#123;</span><br><span class=\"line\">    ListNode dummy;</span><br><span class=\"line\">    ListNode* ptr = &amp;dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p2a || p2b) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = p2a ? p2a-&gt;val : INT_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> b = p2b ? p2b-&gt;val : INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) &#123;</span><br><span class=\"line\">            ptr-&gt;next = p2a;</span><br><span class=\"line\">            p2a = p2a-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ptr-&gt;next = p2b;</span><br><span class=\"line\">            p2b = p2b-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ptr = ptr-&gt;next; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode* slow = head, *fast = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast) &#123; <span class=\"comment\">// 链表快慢指针有多种形式，要会灵活运用</span></span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast) fast = fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast) slow = slow-&gt;next; <span class=\"comment\">// if(fast)：slow指向第一个链表的最后一位结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode* head2 = slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">mergeTwoList</span>(<span class=\"built_in\">mergeSort</span>(head), <span class=\"built_in\">mergeSort</span>(head2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"非递归版本\">2.2 非递归版本</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoList</span><span class=\"params\">(ListNode* p2a, ListNode* p2b)</span> </span>&#123;</span><br><span class=\"line\">    ListNode dummy;</span><br><span class=\"line\">    ListNode* ptr = &amp;dummy;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p2a || p2b) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = p2a ? p2a-&gt;val : INT_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> b = p2b ? p2b-&gt;val : INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) &#123;</span><br><span class=\"line\">            ptr-&gt;next = p2a;</span><br><span class=\"line\">            p2a = p2a-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ptr-&gt;next = p2b;</span><br><span class=\"line\">            p2b = p2b-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ptr = ptr-&gt;next; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ListNode* ptr = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ptr) &#123; <span class=\"comment\">// 统计链表长度</span></span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">        ptr = ptr-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode dummy;</span><br><span class=\"line\">    dummy.next = head;</span><br><span class=\"line\">    ptr = &amp;dummy;</span><br><span class=\"line\">    ListNode* prev, *l, *r, *t, *next; <span class=\"comment\">// 屮，5个指针</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> w = <span class=\"number\">1</span>; w &lt; n; w &lt;&lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        prev = &amp;dummy;</span><br><span class=\"line\">        l = dummy.next;</span><br><span class=\"line\">        r = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第一个子链表的最后一个元素 注意：i从1开始</span></span><br><span class=\"line\">            t = l;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;</span><br><span class=\"line\">            r = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">                r = t-&gt;next;</span><br><span class=\"line\">                t-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第二个子链表的最后一个元素 注意：i从1开始</span></span><br><span class=\"line\">            t = r;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;</span><br><span class=\"line\">            next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">                next = t-&gt;next;</span><br><span class=\"line\">                t-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 合并子链表</span></span><br><span class=\"line\">            ListNode* ret = <span class=\"built_in\">mergeTwoList</span>(l, r);</span><br><span class=\"line\">            prev-&gt;next = ret;</span><br><span class=\"line\">            <span class=\"comment\">// prev指向合并后的子链表的最后一个元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (prev-&gt;next) prev = prev-&gt;next;</span><br><span class=\"line\">            l = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"快速排序\">3. 快速排序</h1>\r\n<ul>\r\n<li>其实对于链表，由于不需要额外空间，归并排序其实很优秀了；快速排序由于需要选取pivot，选的不好，会变成n^2，而归并排序是稳定的nlogn</li>\r\n<li>pivot的选取可以将中点节点移到链头充当pivot或者随机一个节点充当pivot，否则对于有序数列，会退化为n^2</li>\r\n<li>由于无法采用l和r两边向中间靠拢的方式划分集合，只能采用单边形式，所以遇到“窄数据”或者都是一样值（窄特例化），也会退化为n^2 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">quickSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = head-&gt;val;</span><br><span class=\"line\">    ListNode L, R;</span><br><span class=\"line\">    ListNode* l = &amp;L, *r = &amp;R;</span><br><span class=\"line\">    ListNode* ptr = head-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ptr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr-&gt;val &lt;= pivot) &#123;</span><br><span class=\"line\">            l-&gt;next = ptr;</span><br><span class=\"line\">            l = l-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            r-&gt;next = ptr;</span><br><span class=\"line\">            r = r-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ptr = ptr-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">    l = <span class=\"built_in\">quickSort</span>(L.next);</span><br><span class=\"line\">    r = <span class=\"built_in\">quickSort</span>(R.next);</span><br><span class=\"line\">    head-&gt;next = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!l) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode* t = l;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t-&gt;next) t = t-&gt;next;</span><br><span class=\"line\">    t-&gt;next = head;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li>取中间作为pivot <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">quickSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    ListNode* slow = head, *fast = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fast) &#123;</span><br><span class=\"line\">        fast = fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast) fast = fast-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fast) slow = slow-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode* newHead = slow-&gt;next;</span><br><span class=\"line\">    slow-&gt;next = newHead-&gt;next;</span><br><span class=\"line\">    newHead-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = newHead-&gt;val;</span><br><span class=\"line\">    ListNode L, R;</span><br><span class=\"line\">    ListNode* l = &amp;L, *r = &amp;R;</span><br><span class=\"line\">    ListNode* ptr = newHead-&gt;next;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ptr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr-&gt;val &lt;= pivot) &#123;</span><br><span class=\"line\">            l-&gt;next = ptr;</span><br><span class=\"line\">            l = l-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            r-&gt;next = ptr;</span><br><span class=\"line\">            r = r-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ptr = ptr-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">    r-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">    l = <span class=\"built_in\">quickSort</span>(L.next);</span><br><span class=\"line\">    r = <span class=\"built_in\">quickSort</span>(R.next);</span><br><span class=\"line\">    newHead-&gt;next = r;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!l) <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    ListNode* t = l;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t-&gt;next) t = t-&gt;next;</span><br><span class=\"line\">    t-&gt;next = newHead;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<h1 id=\"辅助代码\">4. 辅助代码</h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode* next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> _v = <span class=\"number\">0</span>) :<span class=\"built_in\">val</span>(_v), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">genList</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> range)</span> </span>&#123; <span class=\"comment\">// 数目， 分布范围</span></span><br><span class=\"line\">    ListNode dummy;</span><br><span class=\"line\">    ListNode* ptr = &amp;dummy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">rand</span>() % range;</span><br><span class=\"line\">        ListNode* tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(r);</span><br><span class=\"line\">        ptr-&gt;next = tmp;</span><br><span class=\"line\">        ptr = ptr-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">parseList</span><span class=\"params\">(ListNode* p, <span class=\"type\">bool</span> show=<span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(show) cout &lt;&lt; p-&gt;val &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">        p = p-&gt;next;</span><br><span class=\"line\">        ++cnt;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (show &amp;&amp; cnt / <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            ret += cnt;</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cout &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ret += cnt;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;总计:&quot;</span>&lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ListNode* ptr = <span class=\"built_in\">genList</span>(<span class=\"number\">1000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"built_in\">parseList</span>(ptr, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ptr = yourSort(ptr);</span></span><br><span class=\"line\">    <span class=\"built_in\">parseList</span>(ptr, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["算法","排序"]}]