[{"title":"树状数组","url":"/2022/08/21/树状数组/","content":"# 需求\n- 随机修改数组中一个数字\n- 求前缀和\n- 以上操作需要频繁操作\n\n# 预备知识\n## lowbit\nlowbit指数字的二进制最低位1及后续0取出后的数字\n```c++\nint lowbit(int a){\n    return a & -a;\n}\n```\n例如:10：`1010 & 0110 = 0010`，即10的lowbit为2。\n\n|x|1|2|3|4|5|6|7|8|9|10|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|lowbit(x)|1|2|1|4|1|2|1|8|1|2|\n\n*注意：0不存在lowbit，所以数组的下标需要右偏移一位（使用时偏移或初始化多1位）*\n\n# 树状数组\n\n![树状数组](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.gif)\n\n- tarr从1开始，arr从0开始\n- 树状数组的每一个元素`tarr[i]`：其值为`a[j]+...a[i-1]+a[i-1]`，其中连加的项总共`lowbit(i)`个\n- 在树状数组中，为什么需要寻找其父节点？有两个用处：1、初始化树状数组。2、修改某个数同时修改其祖上一系列树状数组的值。对于`tarr[i]`而言，其直接父节点即为`tarr[i + lowbit(i)]`，通过这种方式逐步向上迭代，即可探寻祖上一条链\n- 对于给定数组：`arr = [1,3,2,6,4,1]`，可得其对应的树状数组：`tarr = [1, 1+3, 2, 1+3+2+6, 4, 4+1] -> [1, 4, 2, 12, 4, 5]`\n- 求和时，例如`sum(idx=13)`\n  - 先得到`res += tarr[13]`，随后`idx -= lowbit(idx)`，此时`idx==12`\n  - 再得到`res += tarr[12]`，随后`idx -= lowbit(12)`，此时`idx==8`\n  - 再得到`res += tarr[8]`，随后`idx -= lowbit(8)`，此时`idx==0`结束循环\n  - 最终，`res = tarr[13] + tarr[12] + tarr[8] = (arr[12]) + (arr[8]+...+arr[11]) + (arr[0]+...+arr[7])`\n- 总之，对于树状数组`tarr`\n  - `idx += lowbit(idx)`是为了寻找祖上，修改和初始化用到\n  - `idx -= lowbit(idx)`是为了求和\n\n\n# 代码\n```c++\nclass TreeArr {\npublic:\n\tTreeArr(vector<int> arr) :arr(arr), tarr(arr.size()+1) {\n\t\t// 初始化树状数组，arr中的每个元素被加到其祖上所有节点中\n        for (size_t i = 0; i < arr.size(); ++i) {\n\t\t\tsize_t idx = i + 1; // 偏移1位\n\t\t\twhile (idx < tarr.size()) {\n\t\t\t\ttarr[idx] += arr[i];\n\t\t\t\tidx += lowbit(idx);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid update(int i, int val) {\n\t\tint diff = val - arr[i];\n\t\tsize_t idx = i + 1;\n        // 修改时也要修改其祖上所有节点 + lowbit(idx)\n\t\twhile (idx < tarr.size()) {\n\t\t\ttarr[idx] += diff;\n\t\t\tidx += lowbit(idx);\n\t\t}\n        arr[i] = val; // 勿忘\n\t}\n\n\tint getSum(int i) {\n\t\tint idx = i + 1;\n\t\tint res = 0;\n        // 求和时则是 - lowbit(idx)\n\t\twhile (idx > 0) {\n\t\t\tres += tarr[idx];\n\t\t\tidx -= lowbit(idx);\n\t\t}\n\t\treturn res;\n\t}\n\n\tint getRange(int l, int r) {\n\t\treturn getSum(r) - getSum(l - 1); //!\n\t}\n\n\n\tstatic int lowbit(int a) {\n\t\treturn a & -a;\n\t}\nprivate:\n\tvector<int> arr;\n\tvector<int> tarr;\n};\n```\n\n# 参考\n1. [什么是树状数组？让这个12岁年轻人为你讲解](https://baijiahao.baidu.com/s?id=1734883051625102971&wfr=spider&for=pc)\n2. [数据结构：树状数组](https://www.jianshu.com/p/7cd5ad2f449a)\n3. [力扣 307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/submissions/)","tags":["C/C++","算法","树"]},{"title":"const要点","url":"/2022/08/19/const要点/","content":"# const要点\n- C的const是虚假的，就是个只读量，只是说不能通过变量名进行修改，但是拿到指针就可修改；\n- C++的const会保险一些，会有类似符号表的东西；但是类内的const普通成员变量则依旧会被通过指针改变\n- 静态const和全局const虽然可以通过指针修改，编译时期可能不会报错，但是运行到那个地方就会报错\n- const只在编译期间保证常量被使用时的不变性，无法保证运行期间的行为。\n```c++\nclass A {\npublic:\n\tconst int val2 = 22;\n\tstatic int val3;\n\tstatic const int val4 = 44; // !\n};\nint A::val3 = 33;\nconst int val5 = 55;\nint val6 = 66;\nint main() {\n\tconst int val1 = 11;\n\tint* p1 = (int*)&val1; // 栈区，拿到地址随便改，但是符号表会覆盖\n\t*p1 = 1111;\n\tcout << &val1 << \" \" << val1 << endl;\n\tcout << p1 << \" \" << *p1 << endl;\n\tcout << \"===\" << endl;\n\n\tA ins;\n\tint* p2 = (int*)&ins.val2;\n\t*p2 = 2222; // 栈区，拿到地址随便改\n\tcout << &ins.val2 << \" \" << ins.val2 << endl;\n\tcout << p2 << \" \" << *p2 << endl;\n\tcout << \"===\" << endl;\n\n\tint* p3 = (int*)&A::val3;\n\t*p3 = 3333; // 全局数据区，但是不在常量区，可以修改\n\tcout << p3 << \" \" << *p3 << endl;\n\tcout << &A::val3 << \" \" << A::val3 << endl;\n\tcout << \"===\" << endl;\n\n\tint* p4 = (int*)&A::val4;\n\t//*p4 = 4444; // 编译不出错，运行会异常（常量区不能修改）\n\tcout << p4 << \" \" << *p4 << endl;\n\tcout << &A::val4 << \" \" << A::val4 << endl;\n\tcout << \"===\" << endl;\n\n\tint* p5 = (int*)&val5;\n\t//*p5 = 5555; // 编译不出错，运行会异常（常量区不能修改）\n\tcout << p5 << \" \" << *p5 << endl;\n\tcout << &val5 << \" \" << val5 << endl;\n\tcout << \"===\" << endl;\n\n\tint* p6 = (int*)&val6;\n\t*p6 = 6666; // 全局数据区，但是不在常量区，可以修改\n\tcout << p6 << \" \" << *p6 << endl;\n\tcout << &val6 << \" \" << val6 << endl;\n\treturn 0;\n}\n```\n输出结果：\n```c++\n/*\n00EFFD98 11\n00EFFD98 1111\n===\n00EFFD80 2222\n00EFFD80 2222\n===\n0027C038 3333\n0027C038 3333\n===\n00279B38 44\n00279B38 44\n===\n00279B30 55\n00279B30 55\n===\n0027C03C 6666\n0027C03C 6666\n*/\n```\n# C++内存分区\n![C++内存分区](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/CPP/C%2B%2B内存分区.jpg)\n# 参考\n1. [C++：const常量的存储位置](https://blog.csdn.net/qq_43152052/article/details/99306967)\n2. [C/C++的四大内存分区和常量的存储位置](https://www.cnblogs.com/heluan/p/8652809.html)\n3. [阿秀的笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/01-01-01-基础语法.html)","tags":["C/C++"]},{"title":"生成树","url":"/2022/08/13/生成树/","content":"# [Prim](https://leetcode.cn/problems/min-cost-to-connect-all-points/)：从一颗小树长大\n思路和Dijkstra基本一致，唯一不同就是dist记录的是与集合的距离而非与起点的距离\n```c++\nstruct Node{ // 用来在优先队列里用\n    int node;\n    int dis;\n    bool operator>(const Node& ano) const {\n        return this->dis > ano.dis;\n    }\n};\n\nclass Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n = points.size(); // 节点数\n        vector<vector<int>> graph(n, vector<int>(n, INT_MAX));\n        for (int i = 0; i < n; ++i){ // 建图\n            for (int j = 0; j < i; ++j){\n                graph[i][j] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]);\n                graph[j][i] = graph[i][j];\n            }\n        }  \n        priority_queue<Node, vector<Node>, greater<Node>> pq;\n        vector<int> dist(n, INT_MAX);\n        pq.push(Node({0, 0})); // 从0开始， 0到0的距离是0\n        int ret = 0;\n        while(!pq.empty()){\n            Node cur = pq.top(); pq.pop();\n            // 跟Dijkstra一样，但人家遇到终点直接可以break\n            // 因为采用优先队列的方式，队列里会有重复，第一次接触的肯定是最优解，后面\n            // 重复的都是大于最优解的，直接跳过，或者你用一个数组，存储对应节点最优dist\n            // 每次存储比较取最小值，但是空间浪费太大了，不如这样好\n            if(dist[cur.node] == 0) continue;\n            dist[cur.node] = 0;\n            ret += cur.dis;\n            for(int i=0; i<n; ++i){\n                if(dist[i] > graph[cur.node][i]){\n                    dist[i] = graph[cur.node][i];\n                    pq.push(Node({i, graph[cur.node][i]}));\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n\n# [Kruskal](https://leetcode.cn/problems/min-cost-to-connect-all-points/)\n利用并查集的思想\n```c++\n// Leetcode 1584 连接所有点的最小费用\n// points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 求坐标轴上这几个点的最小生成树的路径和\nclass UFSet{\npublic:\n    UFSet(int _n):count(_n), parent(_n, -1){}\n    int getCount(){return count;}\n    void unite(int a, int b){\n        int f1 = find(a);\n        int f2 = find(b);\n        if(f1 == f2) return;\n        if(parent[f1] < parent[f2]){\n            parent[f1] += parent[f2];\n            parent[f2] = f1;\n        }else{\n            parent[f2] += parent[f1];\n            parent[f1] = f2;\n        }\n        -- count;\n    }\n    bool isConnected(int a, int b){\n        return find(a) == find(b);\n    }\n    \nprivate:\n    int find(int pos){\n        if(parent[pos] < 0) return pos;\n        return parent[pos] = find(parent[pos]);\n    }\n    int count; // 连通集的个数\n    vector<int> parent;\n};\n\nstruct Edge{\n    int from;\n    int to;\n    int weight;\n    bool operator>(const Edge& ano) const {\n        return this->weight > ano.weight;\n    }\n};\n\nclass Solution {\npublic:\n    // 都不用建图，直接把边放进去就行了\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        UFSet ufs(n);\n        priority_queue<Edge, vector<Edge>, greater<Edge>> pq;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<i; ++j){\n                int weight = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]);\n                pq.push(Edge({i, j, weight}));\n            }\n        }\n        int res = 0, cnt = 0;\n        while(!pq.empty() && cnt<n-1){\n            Edge cur = pq.top(); pq.pop();\n            if(ufs.isConnected(cur.from, cur.to) == false){ // from和to是图节点名，这里直接以points顺序的下标来表示\n                ufs.unite(cur.from, cur.to);\n                res += cur.weight;\n                ++cnt;\n            }\n        }\n        return res;\n    }\n};\n```","tags":["算法","树","并查集","优先队列"]},{"title":"背包问题","url":"/2022/08/13/背包问题/","content":"# 01背包\n经典动态规划问题，输入重量数组weight、价值数组value和背包可承载的最大重量整数maxW\n```c++\nclass Solution {\npublic:\n\tint knapsack(vector<int>& weight, vector<int>& value, int maxW) {\n\t\t// 物品数目\n\t\tint kinds = weight.size();\n\t\t// dp数组初始化为二维数组\n\t\tvector<vector<int>> dp(kinds + 1, vector<int>(maxW + 1, 0));\n\t\t// 状态一：可选的目标：0个可选，前一个可选、前两个可选、前三个可选，以此类推（与找零钱不同，物品不能重复选）\n\t\tfor (int c = 1; c <= kinds; c++) {\n\t\t\t// 状态二：当前的可承载重量，0、1、2...maxW\n\t\t\tfor (int w = 1; w <= maxW; w++) {\n\t\t\t\t// 该物品太大以至于当前重量超标：下标越界，直接赋值为“没有该物品时的最优答案”\n\t\t\t\tif (w - weight[c - 1] < 0) \n\t\t\t\t\tdp[c][w] = dp[c - 1][w];\n\t\t\t\t// 比较，“不选择该物品”和“选择该物品”时，哪个价值大\n\t\t\t\telse\n\t\t\t\t\tdp[c][w] = max(dp[c - 1][w], dp[c - 1][w - weight[c - 1]] + value[c - 1]);\n\t\t\t}\n\t\t}\n\t\treturn dp[kinds][maxW];\n\t}\n};\n```\n\n# [完全背包](https://leetcode.cn/problems/coin-change-2/)\n## 标准DP\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        int n = coins.size();\n        vector<vector<int>> dp(n+1, vector<int>(amount+1, 0));\n\t\t// base case 这里也可以只dp[0][0]=1，但下面的二重循环的j必须从0开始了\n\t\t// 从含义上来说，还是在这里初始化一列全1比较符合定义\n\t\tfor(int s = 0; s<=n; ++s)\n\t\t\tdp[s][0] = 1;\n        for(int i=1; i<=n; ++i){\n            for(int j=1; j<=amount; ++j){\n                if(coins[i-1] > j)\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n                else // dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]];一个数字之差就变成不可重复选取了\n                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];\n            }\n        }\n        return dp[n][amount];\n    }\n};\n```\n\n## 压缩一下\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        int n = coins.size();\n        vector<int> dp(amount+1, 0);\n\t\tdp[0] = 1;\n        for(int i=1; i<=n; ++i){\n            for(int j=1; j<=amount; ++j){\n                if(coins[i-1] <= j)\n                    dp[j] = dp[j] + dp[j-coins[i-1]]; // 由于需要用到当前行更新的值，正好不用倒过来了，和下面子集背包压缩做对比\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n# [子集背包](https://leetcode.cn/problems/partition-equal-subset-sum/)\n## 标准DP\n```c++\n// 子集背包问题\nclass Solution {\npublic:\n    // sum(A1) == sum(A2) -> target = sum(A)/2\n    bool canPartition(vector<int>& nums) {\n        int sum = 0;\n        for (auto e : nums) sum += e;\n        if (sum % 2) // 和必须是偶数\n            return false;\n        int target = sum >> 1;\n        int n = nums.size();\n        vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, 0)); // 用布尔\n        dp[0][0] = 1; // 初始化\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= target; j++) {\n                if (nums[i - 1] > j)\n                    dp[i][j] = dp[i - 1][j];\n                else\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\n            }\n        }\n        return dp[n][target] > 0;\n    }\n};\n\n```\n## 压缩一下\n```c++\n// 子集背包问题\nclass Solution {\npublic:\n    // sum(A1) == sum(A2) -> target = sum(A)/2\n    bool canPartition(vector<int>& nums) {\n        int sum = 0;\n        for (auto e : nums) sum += e;\n        if (sum % 2) // 和必须是偶数\n            return false;\n        int target = sum >> 1;\n        int n = nums.size();\n        vector<bool> dp(target + 1, false); // 用布尔\n        dp[0] = true; // 初始化\n        for (int i = 1; i <= n; i++) {\n            for (int j = target; j >= 0; j--) { // 必须从后往前，不然会覆盖之前的数据\n                if (nums[i - 1] > j)\n                    dp[j] = dp[j];\n                else\n                    dp[j] = dp[j] || dp[j - nums[i - 1]];\n            }\n        }\n        return dp[target] > 0;\n    }\n};\n```\n\n# 参考\n[labuladong](https://labuladong.github.io/algo/3/27/)","tags":["算法","动态规划"]},{"title":"并查集","url":"/2022/08/13/并查集/","content":"# 并查集\n- 一般用于快速判断两个元素是否同属于一个集合\n- 数组形式表示树结构\n- 插入元素会被映射到从0开始的顺序整数中\n\n# 实现技巧\n- 路径压缩：在find时，通过递归并返回找到的祖宗节点并赋值，可以达成find后降低树高的功效\n- 按秩归并：在unite时，其中一方会挂在另一方的门下，所以希望“小的挂到大的上面”，以此来产生结果高度更小的树，有两种方式：\n  - 高度：树高：S[Root]=-树高，代码多一步判断：即：[两个树相同高度时，增加树高](https://github.com/fkjkkll/My-Algorithm/blob/master/3.3%20tree(3)/3.4%20并查集-按秩归并-高度.jpg)\n  - 数目（推荐）：S[Root]=-元素个数。子孙节点数目，可以通过利用根节点来达成，根节点之前是-1，现在改为-n，其中n是包含根节点的整个树的节点数目\n\n# [LC.990](https://leetcode.cn/problems/satisfiability-of-equality-equations/)\n```c++\nclass UF {\npublic:\n\tUF(int _n) :count(_n), parent(_n, -1) {}\n\tint getCount() { return count; }\n\tbool isConnected(int a, int b) {\n\t\tint class1 = find(a);\n\t\tint class2 = find(b);\n\t\treturn class1 == class2;\n\t}\n\tvoid unite(int a, int b) {\n\t\tint class1 = find(a);\n\t\tint class2 = find(b);\n\t\tif (class1 == class2)\n\t\t\treturn;\n\t\tif (parent[class1] < parent[class2]) { // 按秩归并\n\t\t\tparent[class1] += parent[class2];\n\t\t\tparent[class2] = class1;\n\t\t}\n\t\telse {\n\t\t\tparent[class2] += parent[class1];\n\t\t\tparent[class1] = class2;\n\t\t}\n\t\t--count;\n\t}\n\nprivate:\n\tint find(int pos) {\n\t\tif (parent[pos] < 0)\n\t\t\treturn pos;\n\t\treturn parent[pos] = find(parent[pos]); // 路径压缩\n\t}\n\n\tint count;\n\tvector<int> parent;\n};\n\n// leetcode 990\nclass Solution {\npublic:\n\tbool equationsPossible(vector<string>& equations) {\n\t\tUF a(26);\n\t\tfor (int i = 0; i < equations.size(); i++) {\n\t\t\tif (equations[i][1] == '=') {\n\t\t\t\ta.unite(equations[i][0] - 97, equations[i][3] - 97);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < equations.size(); i++) {\n\t\t\tif (equations[i][1] == '!') {\n\t\t\t\tif (a.isConnected(equations[i][0] - 97, equations[i][3] - 97))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};\n```","tags":["算法","树","并查集"]},{"title":"右值引用详解","url":"/2022/04/08/右值引用详解/","content":"# 问题\n1. 临时对象非必要的昂贵的拷贝操作\n2. 在模板函数中如何按照参数的实际类型进行转发\n- 关键字：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义、完美转发\n- 以下用四条代码来阐述C++的右值引用及其思想\n\n# 1. 第一行代码\n```c++\nint i = getVal();\n```\n- 上式代码会产生一个左值和纯右值，**右值是不具名的，判断左值和右值的办法就是看能否取地址**\n- 在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等。\n\n# 2. 第二行代码\n## 2.1 特点1：重获新生\n```c++\nT getVal(){\n    return T();\n}\nT k = getVal();     // F1\nT&& k = getVal();   // F2\n```\n- F1：调用一次默认构造、两次拷贝构造（一次函数内到函数外的临时值，一次临时值到k）\n- F2：调用一次默认构造、一次拷贝构造（一次函数内到函数外的临时值，并且临时值通过右值引用**重获新生**）\n- 现代编译器进行了优化，可能仅仅调用一次默认构造，但这不是C++标准\n- 当然在C++98/03年代，为了相同的目的，可以用常量左值引用这种万能引用：`const T& k = getVal();`，也能达到减少一次拷贝构造的目的，但是k不能再改变了。\n\n## 2.2 特点2：右值引用“二相性”\n- 右值引用独立于左值和右值，即，右值引用类型的变量可能是左值也可能是右值，例如：\n```c++\nint&& val = 1;\n```\n- **val类型为右值引用，但val本身是左值**，所有具名变量都是左值\n```c++\ntemplate<typename T>\nvoid f(T&& t){}\n\nf(10); // t是右值 T&& t = 10\n\nint x = 10;\nf(x);  // t是左值 (T&)&& t = x，折叠后变为T& t = x;\n```\n## 2.3 特点3：通用引用(universal references)\n- T&& t在**发生自动类型推断**的时候，它是通用引用类型\n- 通用引用是需要初始化的，如果是左值，那就归为左值引用，如果是右值，那就归为右值引用。\n```c++\n// 注意上述关键词：\"发生自动类型推断\"时\nint a = 1;\nauto&& b = a;  // b类型为左值引用 (int&)&& b -> int& b = a\nauto&& c = 10; // c类型为右值引用 int&& b = 10\n```\n### **引用折叠**\n1. 所有的右值引用叠加到右值引用上仍然还是一个右值引用\n    - 类型 T&& && 折叠成 T&&\n2. 所有的其他引用类型之间的叠加都将变成左值引用\n    - T& &、T& && 和 T&& & 都会折叠成类型 T&\n   \n\n\n# 3. 第三行代码\n```c++\nMyClass(MyClass&& a) : m_val(a.m_val) { a.m_val=nullptr; }\n```\n- 即，移动构造函数(move constructor)，采用浅拷贝的方式，因为某些临时变量如果没有移动构造函数，则会频繁发生拷贝构造（深拷贝），如果对象内部堆空间很大的话，代价会非常大\n- 这里介绍move语句，move语句会将一个左值变为一个右值类型。`move(val)`后，并不会对val本身做出改变。类似上面的代码，将`move(val)`交给一个构造函数或者一个赋值函数，那么会按照右值类型匹配对应的移动构造函数和移动赋值函数，在移动函数里会将`val`的资源指针交给别人，`val`自身资源指针指向`nullptr`，这个时候`val`才会发生改变（你在代码里`move(val)`一百次，但是不交给对应函数匹配处理，那么`val`就不会有一丁点的变化）。当然，这些操作别人已经实现好了，如果是你自己的类，要自己实现！\n\n# 4. 第四行代码\n```c++\ntemplate <typename T>\nvoid f(T&& val){ \n    foo(std::forward<T>(val));\n}\n```\n\n## 4.1 C++11前，调用模板函数的问题\n```c++\ntemplate <typename T>\nvoid forwardValue(T&& val){\n    processValue(val); // 右值参数会变成左值传递给processValue\n}\n```\n- 因此引入了完美转发`std::forward`，他会按照参数的实际类型进行转发\n```c++\nvoid processValue(int& a){ cout << \"lvalue\" << endl; }\nvoid processValue(int&& a){ cout << \"rvalue\" << endl; }\ntemplate <typename T>\nvoid forwardValue(T&& val){\n    // 照参数本来的类型进行转发。\n    processValue(std::forward<T>(val)); \n}\nvoid Testdelcl(){\n    int i = 0;\n    forwardValue(i); // 传入左值 输出：lvaue \n    forwardValue(0); // 传入右值 暑促和：rvalue\n}\n```\n- T&&是一个通用引用(universal references)，可以接受左值或者右值，正是这个特性让他适合作为一个参数的**路由**，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。\n\n## 4.2 进一步体会完美转发\n### 4.2.1 问题\n- `func`函数接收的`v2`是引用，但是引用的却是`middle`里面的一个局部变量`t2`，而非`main`中的`t2`，应该怎么办？\n```c++\ntemplate <typename F, typename T1, typename T2>\nvoid middle(F f, T1 t1, T2 t2) {\n  f(t1, t2);\n}\n\nvoid func(int v1, int& v2) {  // v2 是一个引用\n  ++v1;\n  ++v2;\n}\n\nint main(int argc, char* argv[]) {\n  int i = 0;\n  func(42, i);\n  // here i = 1\n  middle(func, 42, i);\n  // here i = 1\n}\n```\n### 4.2.2 尝试\n- `middle`中`t1`类型是`int&&`，`t2`类型是`int& && -> int&`，`i`的值也如预期般变化\n```c++\ntemplate <typename F, typename T1, typename T2>\nvoid middle(F f, T1&& t1, T2&& t2) {\n  f(t1, t2);\n}\n\nvoid func(int v1, int& v2) {  // v2 是一个引用\n  ++v1;\n  ++v2;\n}\n\nint main(int argc, char* argv[]) {\n  int i = 0;\n  func(42, i);\n  // here i = 1\n  middle(func, 42, i);\n  // here i = 2\n}\n```\n- 虽然看似没毛病，但是我们改一下`func`，就会暴露问题，修改func如下：\n```c++\nvoid func(int&& v1, int& v2) {\n  ++v1;\n  ++v2;\n}\n```\n- 修改`func`后再用4.2.2的代码运行就会报错，提示：“无法将一个右值引用绑定到左值上”，why？因为，在`main`中42虽然是右值，传入到`middle`后`t1`的类型也确实是`int&&`，但是`t1`本身作为具名变量，它是一个左值！而左值是无法与右值进行绑定的。\n\n### 4.2.3 解决\n```c++\ntemplate <typename F, typename T1, typename T2>\nvoid middle(F f, T1&& t1, T2&& t2) {\n  f(std::forward<T1>(t1), std::forward<T2>(t2));\n}\n```\n- `forward`就是解决以上问题的关键\n- `42`传入`middle`后绑定到`t1`，此时t1类型是`int&&`（其中`T1`是`int`）。通过`forward<T1>(t1) -> forward<int>(t1)`，将返回`int&&`成功传给func函数。这里你肯定有疑问，刚才不就是`int&&`？你绕一大圈子是不是耍人？其实不然，之前的那个啊叫named rvalue，有名字，传参时被当成左值！现在通过`forward`返回的是无名字的真正的右值，从而右值得到了保留！\n- `i`传入`middle`后绑定到`t2`，此时t2类型为`int& &&`（其中`T2`是`int&`，why？因为`T2`如果是`int`，那么就变成`int&& t2 = i`，会导致右值绑定一个左值从而报错！）经过引用折叠变为`int&`.通过`forward<T2>(t2) -> forward<int&>(t2)`，将返回一个`int& &`，折叠后变为`int&`，左值也得到了保留！\n\n\n## 4.3 应用：泛型工厂函数\n利用forward可以实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：\n```c++\ntemplate<typename…  Args>\nT* Instance(Args&&… args){\n    return new T(std::forward<Args >(args)…);\n}\n```\n- 这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。\n\n\n# 参考资料\n- [博客园qicosmos(江南)](https://www.cnblogs.com/qicosmos/p/4283455.html#:~:text=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%98%AFC,%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E3%80%82)\n- [Dong's Blog](https://www.guodong.plus/2020/0314-132811/)","tags":["C/C++"]},{"title":"路径搜索","url":"/2022/04/07/路径搜索/","content":"\n# 辅助代码（全局变量）\n```c++\ntypedef pair<int, int> node;\nvector<vector<int>> G = {\n\t{1,1,1,1,1,1,1,1,1,1,1},\n\t{1,1,1,1,1,1,1,1,1,1,1},\n\t{1,1,1,1,1,2,1,1,1,1,1},\n\t{1,1,1,1,2,3,2,1,1,1,1},\n\t{1,1,1,2,3,4,3,2,1,1,1},\n\t{1,1,2,3,4,5,4,3,2,1,1},\n\t{1,1,1,2,3,4,3,2,1,1,1},\n\t{1,1,1,1,2,3,2,1,1,1,1},\n\t{1,1,1,1,1,2,1,1,1,1,1},\n\t{1,1,1,1,1,1,1,1,1,1,1},\n\t{1,1,1,1,1,1,1,1,1,1,1}\n};\nint row = (int)G.size();\nint col = (int)G[0].size();\nnode S = { 5,0 };\nnode E = { 5,10 };\nint dir[] = { -1, 0, 1, 0, -1 };\n```\n# DFS\n- **DFS是无法找到最优路径的**（理论上可以，但是复杂度巨高，如果是四个方向搜索的话，那么就是四叉树，高度是图中结点数，也就是说如果是10x10的图，那就是大约4^100复杂度）\n- 下面代码只表示找到任意一条路后直接返回\n```c++\nvector<vector<bool>> visited(row, vector<bool>(col, false));\nvector<node> path;\nbool END = false;\nvoid dfs(node cur) {\n\tif (cur == E) \n\t\tEND = true;\n\tvisited[cur.first][cur.second] = true;\n\tpath.push_back(cur);\n\tfor (int i = 0; i < 4 && !END; ++i) {\n\t\tint ix = cur.first + dir[i];\n\t\tint iy = cur.second + dir[i + 1];\n\t\tif (ix < 0 || ix >= row || iy < 0 || iy >= col || visited[ix][iy]) continue;\n\t\tdfs({ ix, iy });\n\t}\n\tif (END) return; // 保留路径\n\tpath.pop_back();\n\tvisited[cur.first][cur.second] = false;\n}\n```\n\n# BFS\n- BFS是可以找到最优路径的，每次到某点的距离变小时就将其加入队列\n- **不可以提前结束**，无法确定是否能够通过后面的点来缩短到终点的距离\n```c++\nvoid bfs() {\n\tqueue<node> qe;\n\tqe.push(S);\n    vector<vector<int>> dist(row, vector<int>(col, 10000));\n\tdist[S.first][S.second] = 0;\n\twhile (!qe.empty()) {\n\t\tnode cur = qe.front(); qe.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint ix = cur.first + dir[i];\n\t\t\tint iy = cur.second + dir[i + 1];\n\t\t\tif (ix < 0 || ix >= row || iy < 0 || iy >= col) continue;\n\t\t\tif (dist[ix][iy] > dist[cur.first][cur.second] + G[ix][iy]) {\n\t\t\t\tdist[ix][iy] = dist[cur.first][cur.second] + G[ix][iy];\n\t\t\t\tqe.emplace(ix, iy);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n# Dijkstra\n- 每次弹出优先队列的都是确定下来的最优解，因此可以接触终点时直接`break`提前结束\n- 也不需要visited数组，因为遇到重复的x和y时，优先队列会依照priority排列，大的自动排到后面，由于接触到终点直接break，那些非最优的都没机会弹出队列。\n- 你可能会想到有没有这种可能绕一个大圈然后使得到达终点的距离进一步降低？其实不可能的，因为优先队列的贪心思想，反证法：如果之前已经将E弹出，后面又经过X到达E使得dist(E)降低；但是既然后面再弹出的X，那证明X的dist比之前第一次弹出的E的dist要大(优先队列先弹出dist小的)，那如何能使得经过X后让E的dist减小呢？矛盾！\n```c++\nstruct item{ // 存放在优先队列的结构体\n\tint x;\n\tint y;\n\tint priority;\n\tbool operator>(const item& ano) const {\n\t\treturn this->priority > ano.priority;\n\t}\n};\n\nvoid dijkstra() {\n\tpriority_queue<item, vector<item>, greater<item>> qe;\n\tvector<vector<int>> dist(row, vector<int>(col, 1000)); // dist二维数组\n\tqe.push({ S.first, S.second, 0 }); // 初始化\n\tdist[S.first][S.second] = 0; // 初始化\n\twhile (!qe.empty()) {\n\t\titem cur = qe.top(); qe.pop();\n\t\t// 找到后可以直接返回，这里贪心算法，确保是最优解\n\t\tif (cur.x == E.first && cur.y == E.second) break;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint ix = cur.x + dir[i];\n\t\t\tint iy = cur.y + dir[i + 1];\n\t\t\tif (ix < 0 || ix >= row || iy < 0 || iy >= col) continue;\n\t\t\tif (dist[ix][iy] > cur.priority + G[ix][iy]) {\n\t\t\t\tdist[ix][iy] = cur.priority + G[ix][iy];\n\t\t\t\tqe.push({ ix, iy, dist[ix][iy] });\n\t\t\t}\n\t\t}\n\t}\n}\n```\n# A星\n- A星的思想是对Dijkstra的一点改进。首先BFS是没有方向的，Dijkstra是在BFS之上加入了贪心思想，但是同样没有方向，A星则是增加了终点方向的属性，并入到Dijkstra的优先级中，参与优先队列的弹出选择，对于能明确表明与终点距离的图问题来说，效果相当不错。\n```c++\nstruct item{ // 存放在优先队列的结构体\n\tint x;\n\tint y;\n\tint p1; // 从起点到该点的 dist (与实际图权值相关，如果无权图则退化为曼哈顿距离)\n\tint p2; // 从该点到终点的 [曼哈顿距离] \n\tbool operator>(const item& ano) const {\n\t\treturn p1 + p2 > ano.p1 + ano.p2;\n\t}\n};\n\n// 获取曼哈顿距离的函数\nauto getP2 = [&](int x, int y) {return abs(E.first - x) + abs(E.second - y); };\n\nvoid aStar() {\n\tpriority_queue<item, vector<item>, greater<item>> qe;\n\tvector<vector<int>> dist(row, vector<int>(col, 1000)); // dist二维数组\n\tqe.push({ S.first, S.second, 0, getP2(S.first, S.second)}); // 初始化\n\tdist[S.first][S.second] = 0; // 初始化\n\twhile (!qe.empty()) {\n\t\titem cur = qe.top(); qe.pop();\n\t\t// 找到后可以直接返回，这里贪心算法，确保是最优解\n\t\tif (cur.x == E.first && cur.y == E.second) break;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint ix = cur.x + dir[i];\n\t\t\tint iy = cur.y + dir[i + 1];\n\t\t\tif (ix < 0 || ix >= row || iy < 0 || iy >= col) continue;\n\t\t\tif (dist[ix][iy] > cur.p1 + G[ix][iy]) {\n\t\t\t\tdist[ix][iy] = cur.p1 + G[ix][iy];\n\t\t\t\tqe.push({ ix, iy, dist[ix][iy], getP2(ix, iy) });\n\t\t\t}\n\t\t}\n\t}\n}\n```","tags":["算法","递归"]},{"title":"字符串匹配","url":"/2022/04/06/字符串匹配/","content":"# BF(Brute Force)算法\n- BF是最符合人类直觉的字符串匹配算法，但是主串的下标`i`经常要往回走，无法利用已匹配信息，效率不够好\n```c++\nint bruteForce(const string& t, const string& p) {\n\tint i = 0, j = 0;\n    // i和j都是非负数，所以可以和无符号直接比较\n\twhile (i < t.size() && j < p.size()) {\n\t\tif (t[i] == p[j]) {\n\t\t\t++i; ++j;\n\t\t} else {\n\t\t\ti = i - j + 1;\n\t\t\tj = 0;\n\t\t}\n\t}\n\tif (j == p.size())\n\t\treturn i - j;\n\telse\n\t\treturn -1;\n}\n```\n\n# KMP算法\n- 思想：“利用已部分匹配的信息，保持 $i$ 指针不回溯，通过修改 $j$ 指针，让模式串尽量移动到有效的位置”\n- 定义 $next$ 数组： `next[j] = d` 表示当 `t[i] != p[j]` 时， $j$ 下一次匹配的位置。注意到，下标从0开始，$d$ 值实际上是下标 $j$ 前的**最长前后缀子串**的**长度**\n- 求取 $next$ 的过程本身就是 $p$ 串与自己匹配的过程\n    1. 当 `p[i]==p[j]` ，则 `p[++i] = ++j`\n    2. 当 `p[i]!=p[j]` ，则利用前面已求得的 $next$ 数组，`j=next[j]` ；直到无法找到，此时 `j=-1` ，自动进入第一个 $if$ 语句，此时 $i$ 往后走一步，妙\n```c++\nvector<int> getNext(const string& p) {\n\tint n = p.size();\n\tvector<int> next(n);\n\tnext[0] = -1;\n\tint i = 0, j = -1;\n\t// !!! i < n 则会在下面越界，因为0已经求过了，循环只会进行n-1次\n\twhile (i < n - 1) {\n\t\tif (j == -1 || p[i] == p[j]) {\n\t\t\t++i, ++j;\n\t\t\tnext[i] = j;\n\t\t} else {\n\t\t\tj = next[j];\n\t\t}\n\t}\n\treturn next;\n}\n\nint KMP(const string& t, const string& p) {\n\tvector<int> next = getNext(p);\n\tint n = t.size(), m = p.size();\n\tint i = 0, j = 0;\n\t// !!! j可以为负数，和无符号比较会转换为无符号比较法(南辕北辙)\n\twhile (i < n && j < m) {\n\t\tif (j == -1 || t[i] == p[j]) {\n\t\t\t++i; ++j;\n\t\t} else {\n\t\t\tj = next[j];\n\t\t}\n\t}\n\tif (j == p.size())\n\t\treturn i - j;\n\telse\n\t\treturn -1;\n}\n```\n\n# KMP之Next优化\n- 比如 $[ A B A B ]$ 这个串，按照上面所述KMP得到的结果是 [-1, 0, 0, 1] ，然而，例如匹配的是 $[ A B A B D E]$ ，在下标为 $3$ 处失败了，$next$ 指导去下标 $1$ 处继续匹配，但是，下标 $1$ 和下标 $3$ 都是 $B$ ，没有必要再进行比较了。诸如此类的例子还有 $[ A A A A B]$ ，用上述KMP得到的 $next$ 是 [-1, 0, 1, 2, 3]\n- 方法就是在 `++i, ++j` 后加一步判断，本来直接 `next[i]=j` 但是如果 `p[i]==p[j]` 则如果以后匹配 `p[i]` 失败，则匹配 `p[j]` 肯定也失败啊，所以如果两者相等，直接 `next[i] = next[j]` 。此时的结果对于 $[ A B A B ]$ 产生的是 [-1, 0, -1, 0]；对于 $[ A A A A B]$ 产生的是 [-1, -1, -1, -1, 3]\n- 加三行代码就行了\n```c++\nvector<int> getNext(const string& p) {\n\tint n = p.size();\n\tvector<int> next(n);\n\tnext[0] = -1;\n\tint i = 0, j = -1;\n\twhile (i < n - 1) {\n\t\tif (j == -1 || p[i] == p[j]) {\n\t\t\t++i, ++j;\n\t\t\tif (p[i] == p[j]) // new \n\t\t\t\tnext[i] = next[j]; // new \n\t\t\telse // new\n\t\t\t\tnext[i] = j;\n\t\t}\n\t\telse {\n\t\t\tj = next[j];\n\t\t}\n\t}\n\treturn next;\n}\n\nint KMP(const string& t, const string& p) {\n\tvector<int> next = getNext(p);\n\tint n = t.size(), m = p.size();\n\tint i = 0, j = 0;\n\twhile (i < n && j < m) {\n\t\tif (j == -1 || t[i] == p[j]) {\n\t\t\t++i; ++j;\n\t\t}\n\t\telse {\n\t\t\tj = next[j];\n\t\t}\n\t}\n\tif (j == p.size())\n\t\treturn i - j;\n\telse\n\t\treturn -1;\n}\n```\n\n# 参考资料\n- 博客园博主：[sofu6](https://www.cnblogs.com/dusf/p/kmp.html)","tags":["算法","字符串"]},{"title":"计算器","url":"/2022/04/05/计算器/","content":"# 功能说明\n- 实现+、-、*、/、括号的整数运算\n- 实现处理多余空格\n\n# 实现1（更高效）\n- 用引用`l`指针的方式逐步处理\n```c++\nint core(string& s, int& l) {\n\tstack<int> stk;\n\tint n = s.size();\n\tint num = 0;\n\tchar sign = '+';\n\tfor (; l < n; ++l) {\n\t\tchar c = s[l];\n\t\tif (isdigit(c)) \n\t\t\tnum = num * 10 + (c - '0');\n\t\t// if(c == ' ') continue是不对的，因为l=n-1时一定要最后来一次\n\t\tif ((!isdigit(c) && c != ' ') || l == n - 1) {\n\t\t\tif (c == '(') \n\t\t\t\tnum = core(s, ++l); // 理解这种递归思想很重要\n\t\t\tint prev;\n\t\t\tswitch (sign) {\n\t\t\tcase '+':\n\t\t\t\tstk.push(num); break;\n\t\t\tcase '-':\n\t\t\t\tstk.push(-num); break;\n\t\t\tcase '*':\n\t\t\t\tprev = stk.top(); stk.pop();\n\t\t\t\tstk.push(prev * num);\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tprev = stk.top(); stk.pop();\n\t\t\t\tstk.push(prev / num);\n\t\t\t\tbreak;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\tsign = c;\n\t\t\tnum = 0;\n\t\t\tif (c == ')') \n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!stk.empty()) {\n\t\tret += stk.top();\n\t\tstk.pop();\n\t}\n\treturn ret;\n}\n\nint caculator(string s) {\n\tint tmp = 0;\n\treturn core(s, tmp);\n}\n```\n\n# 实现2（更优雅）\n- 由于需要不停`pop`首部，所以采用`deque`代替移动的`l`，更优雅\n```c++\nint core(deque<char>& s) {\n\tstack<int> stk;\n\tint num = 0;\n\tchar sign = '+';\n\twhile (!s.empty()) {\n\t\tchar c = s[0]; s.pop_front();\n\t\tif (isdigit(c))\n\t\t\tnum = num * 10 + (c - '0');\n\t\tif ((!isdigit(c) && c != ' ') || s.empty()) {\n\t\t\tif (c == '(')\n\t\t\t\tnum = core(s);\n\t\t\tint prev;\n\t\t\tswitch (sign) {\n\t\t\tcase '+':\n\t\t\t\tstk.push(num); break;\n\t\t\tcase '-':\n\t\t\t\tstk.push(-num); break;\n\t\t\tcase '*':\n\t\t\t\tprev = stk.top(); stk.pop();\n\t\t\t\tstk.push(prev * num);\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tprev = stk.top(); stk.pop();\n\t\t\t\tstk.push(prev / num);\n\t\t\t\tbreak;\n\t\t\tdefault: break;\n\t\t\t}\n\t\t\tsign = c;\n\t\t\tnum = 0;\n\t\t\tif (c == ')')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint ret = 0;\n\twhile (!stk.empty()) {\n\t\tret += stk.top();\n\t\tstk.pop();\n\t}\n\treturn ret;\n}\n\nint caculator(string s) {\n\tdeque<char> dq;\n\tfor (auto& e : s) dq.push_back(e);\n\treturn core(dq);\n}\n```\n\n# 参考\n- labuladong的算法小抄","tags":["算法","递归","栈"]},{"title":"链表排序","url":"/2022/04/04/链表排序/","content":"# 1. 插入排序\n- 只要注意每次判断比前面的大那就不需要回头\n- 否则需要从头找合适的位置\n```c++\nListNode* insertSort(ListNode* head) {\n\tif (!head || !head->next) return head;\n\tListNode dummy; dummy.next = head;\n\tListNode* prev = head;\n\tListNode* curr = head->next;\n\twhile (curr) {\n\t\tif (prev->val <= curr->val) {\n\t\t\tprev = curr;\n\t\t\tcurr = curr->next;\n\t\t} else {\n\t\t\tListNode* t = &dummy;\n\t\t\twhile (t->next && t->next->val <= curr->val) t = t->next;\n\t\t\tprev->next = curr->next;\n\t\t\tcurr->next = t->next;\n\t\t\tt->next = curr;\n\t\t\tcurr = prev->next;\n\t\t}\n\t}\n\treturn dummy.next;\n}\n```\n\n# 2. 归并排序\n- 不论是主递归还是merge都要求两个链表以nullptr结尾\n- 也就是在合适的地方断开\n## 2.1 递归版本\n```c++\nListNode* mergeTwoList(ListNode* p2a, ListNode* p2b) {\n\tListNode dummy;\n\tListNode* ptr = &dummy;\n\twhile (p2a || p2b) {\n\t\tint a = p2a ? p2a->val : INT_MAX;\n\t\tint b = p2b ? p2b->val : INT_MAX;\n\t\tif (a < b) {\n\t\t\tptr->next = p2a;\n\t\t\tp2a = p2a->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2b;\n\t\t\tp2b = p2b->next;\n\t\t}\n\t\tptr = ptr->next; // 别忘了\n\t}\n\treturn dummy.next;\n}\n\nListNode* mergeSort(ListNode* head) {\n\tif (!head || !head->next) return head;\n\tListNode* slow = head, *fast = head;\n\twhile (fast) { // 链表快慢指针有多种形式，要会灵活运用\n\t\tfast = fast->next;\n\t\tif(fast) fast = fast->next;\n\t\tif(fast) slow = slow->next; // if(fast)：slow指向第一个链表的最后一位结点\n\t}\n\tListNode* head2 = slow->next;\n\tslow->next = nullptr;\n\treturn mergeTwoList(mergeSort(head), mergeSort(head2));\n}\n```\n\n## 2.2 非递归版本\n```c++\nListNode* mergeTwoList(ListNode* p2a, ListNode* p2b) {\n\tListNode dummy;\n\tListNode* ptr = &dummy;\n\twhile (p2a || p2b) {\n\t\tint a = p2a ? p2a->val : INT_MAX;\n\t\tint b = p2b ? p2b->val : INT_MAX;\n\t\tif (a < b) {\n\t\t\tptr->next = p2a;\n\t\t\tp2a = p2a->next;\n\t\t}\n\t\telse {\n\t\t\tptr->next = p2b;\n\t\t\tp2b = p2b->next;\n\t\t}\n\t\tptr = ptr->next; // 别忘了\n\t}\n\treturn dummy.next;\n}\n\nListNode* mergeSort(ListNode* head) {\n\tif (!head || !head->next) return head;\n\tint n = 0;\n\tListNode* ptr = head;\n\twhile (ptr) { // 统计链表长度\n\t\t++n;\n\t\tptr = ptr->next;\n\t}\n\tListNode dummy;\n\tdummy.next = head;\n\tptr = &dummy;\n\tListNode* prev, *l, *r, *t, *next; // 屮，5个指针\n\tfor (int w = 1; w < n; w <<= 1) {\n\t\tprev = &dummy;\n\t\tl = dummy.next;\n\t\tr = nullptr;\n\t\twhile (l) {\n\t\t\t// 第一个子链表的最后一个元素 注意：i从1开始\n            t = l;\n\t\t\tfor (int i = 1; i < w && t; ++i) t = t->next;\n\t\t\tr = nullptr;\n\t\t\tif (t) {\n\t\t\t\tr = t->next;\n\t\t\t\tt->next = nullptr;\n\t\t\t}\n\t\t\t// 第二个子链表的最后一个元素 注意：i从1开始\n            t = r;\n\t\t\tfor (int i = 1; i < w && t; ++i) t = t->next;\n\t\t\tnext = nullptr;\n\t\t\tif (t) {\n\t\t\t\tnext = t->next;\n\t\t\t\tt->next = nullptr;\n\t\t\t}\n            // 合并子链表\n\t\t\tListNode* ret = mergeTwoList(l, r);\n\t\t\tprev->next = ret;\n\t\t\t// prev指向合并后的子链表的最后一个元素\n\t\t\twhile (prev->next) prev = prev->next;\n\t\t\tl = next;\n\t\t}\n\t}\n\treturn dummy.next;\n}\n```\n# 3. 快速排序\n- 其实对于链表，由于不需要额外空间，归并排序其实很优秀了；快速排序由于需要选取pivot，选的不好，会变成n^2，而归并排序是稳定的nlogn\n- pivot的选取可以将中点节点移到链头充当pivot或者随机一个节点充当pivot，否则对于有序数列，会退化为n^2\n- 由于无法采用l和r两边向中间靠拢的方式划分集合，只能采用单边形式，所以遇到“窄数据”或者都是一样值（窄特例化），也会退化为n^2\n```c++\nListNode* quickSort(ListNode* head) {\n\tif (!head || !head->next) return head;\n\tint pivot = head->val;\n\tListNode L, R;\n\tListNode* l = &L, *r = &R;\n\tListNode* ptr = head->next;\n\twhile (ptr) {\n\t\tif (ptr->val <= pivot) {\n\t\t\tl->next = ptr;\n\t\t\tl = l->next;\n\t\t}\n\t\telse {\n\t\t\tr->next = ptr;\n\t\t\tr = r->next;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\tl->next = nullptr; // 断尾\n\tr->next = nullptr; // 断尾\n\tl = quickSort(L.next);\n\tr = quickSort(R.next);\n\thead->next = r;\n\tif (!l) return head;\n\tListNode* t = l;\n\twhile (t->next) t = t->next;\n\tt->next = head;\n\treturn l;\n}\n```\n- 取中间作为pivot\n```c++\nListNode* quickSort(ListNode* head) {\n\tif (!head || !head->next) return head;\n\tListNode* slow = head, *fast = head;\n\twhile (fast) {\n\t\tfast = fast->next;\n\t\tif (fast) fast = fast->next;\n\t\tif (fast) slow = slow->next;\n\t}\n\tListNode* newHead = slow->next;\n\tslow->next = newHead->next;\n\tnewHead->next = head;\n\n\tint pivot = newHead->val;\n\tListNode L, R;\n\tListNode* l = &L, *r = &R;\n\tListNode* ptr = newHead->next;\n\twhile (ptr) {\n\t\tif (ptr->val <= pivot) {\n\t\t\tl->next = ptr;\n\t\t\tl = l->next;\n\t\t}\n\t\telse {\n\t\t\tr->next = ptr;\n\t\t\tr = r->next;\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\tl->next = nullptr; // 断尾\n\tr->next = nullptr; // 断尾\n\tl = quickSort(L.next);\n\tr = quickSort(R.next);\n\tnewHead->next = r;\n\tif (!l) return newHead;\n\tListNode* t = l;\n\twhile (t->next) t = t->next;\n\tt->next = newHead;\n\treturn l;\n}\n```\n\n# 4. 辅助代码\n```c++\nstruct ListNode{\n\tint val;\n\tListNode* next;\n\tListNode(int _v = 0) :val(_v), next(nullptr) {}\n};\n\nListNode* genList(int n, int range) { // 数目， 分布范围\n\tListNode dummy;\n\tListNode* ptr = &dummy;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint r = rand() % range;\n\t\tListNode* tmp = new ListNode(r);\n\t\tptr->next = tmp;\n\t\tptr = ptr->next;\n\t}\n\treturn dummy.next;\n}\n\nvoid parseList(ListNode* p, bool show=true) {\n\tint ret = 0;\n\tint cnt = 0;\n\twhile (p) {\n\t\tif(show) cout << p->val << \"\\t\";\n\t\tp = p->next;\n\t\t++cnt;\n\t\tif (show && cnt / 10) {\n\t\t\tret += cnt;\n\t\t\tcnt = 0;\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tret += cnt;\n\tcout << \"总计:\"<< ret << endl;\n}\n\nint main() {\n\tListNode* ptr = genList(1000, 1000);\n\tparseList(ptr, true);\n\t// ptr = yourSort(ptr);\n\tparseList(ptr, true);\n\treturn 0;\n}\n```","tags":["算法","递归","排序"]},{"title":"十大排序总结","url":"/2022/04/03/十大排序总结/","content":"# 一、简单排序\n## 1. 冒泡排序\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(1)\n- 稳定\n```c++\nvoid bubbleSort(vector<int>& arr) {\n\tint n = arr.size();\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tfor (int j = 0; j < n - 1 - i; ++j) {\n\t\t\tif (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);\n\t\t}\n\t}\n}\n```\n## 2. 选择排序\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(1)\n- **不稳定**（是不是以为`(arr[j] > arr[pos])`改为`>=`就变成稳定的了？那看一下`3, 2, 1, 2`。所以若想选择排序稳定，需要开辟新的数组空间；或者进行大量移动位置操作；或者是对链表排序）\n```c++\nvoid selectSort(vector<int>& arr) {\n\tint n = arr.size();\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint pos = 0;\n\t\tfor (int j = 1; j < n - i; ++j) {\n\t\t\tif (arr[j] > arr[pos]) pos = j;\n\t\t}\n\t\tswap(arr[pos], arr[n - i - 1]);\n\t}\n}\n```\n\n## 3. 插入排序\n- 时间复杂度：O(N^2)\n- 空间复杂度：O(1)\n- 稳定\n```c++\nvoid insertSort(vector<int>& arr) {\n\tint n = arr.size();\n\tfor (int i = 1; i < n; ++i) {\n\t\tint cur = arr[i];\n\t\tint j = i - 1;\n\t\tfor (; j >= 0 && arr[j] > cur; --j)\n\t\t\tarr[j + 1] = arr[j];\n\t\tarr[j + 1] = cur;\n\t}\n}\n```\n# 二、高级排序\n## 4. 希尔排序\n- 时间复杂度：O(N^(4/3~3/2))复杂度非常难以估算\n- 空间复杂度：O(1)\n- **不稳定**\n- 下面两个实现都一样，唯一区别就是`插入排序外循环里面i增加的形式，第一种分开实现，第二种合并了`\n### 4.1 实现1\n```c++\nvoid shellSort(vector<int>& arr) {\n\tint n = arr.size();\n\t// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了\n\tstatic vector<int> incre = { 1023, 511, 255, 127, 63, 31, 15, 7, 3, 1 };\n\tfor (int u = 0; u <incre.size(); ++u) { // 增量循环\n\t\tint width = incre[u];\n\t\tif (width > n) continue;\n\t\tfor (int v = 0; v < width; ++v) { // 当前增量循环\n\t\t\tfor (int i = width + v; i < n; i += width) { // 插入排序外循环\n\t\t\t\tint cur = arr[i];\n\t\t\t\tint j = i - width;\n\t\t\t\tfor (; j >= 0 && arr[j] > cur; j -= width) // 插入排序内循环\n\t\t\t\t\tarr[j + width] = arr[j];\n\t\t\t\tarr[j + width] = cur;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n### 4.2 实现2（浙大陈姥姥代码）\n```c++\nvoid shellSort(vector<int>& arr) {\n\tint n = arr.size();\n\t// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了\n\tstatic vector<int> incre = { 1023, 511, 255, 127, 63, 31, 15, 7, 3, 1 };\n\tfor (int u = 0; u < incre.size(); ++u) { // 增量循环\n\t\tint width = incre[u];\n\t\tfor (int i = width; i < n; ++i) { // 插入排序外循环\n\t\t\tint cur = arr[i];\n\t\t\tint j = i - width;\n\t\t\tfor (; j >= 0 && arr[j] > cur; j -= width) // 插入排序内循环\n\t\t\t\tarr[j + width] = arr[j];\n\t\t\tarr[j + width] = cur;\n\t\t}\n\t}\n}\n```\n\n## 5. 堆排序\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(1)\n- 不稳定\n```c++\nvoid downMethod(vector<int>& arr, int f, int sz) {\n\tint s = f * 2 + 1;\n\tint cur = arr[f];\n\twhile(s < sz){\n\t\tif (s + 1 < sz && arr[s] < arr[s + 1]) // 兄弟值大，让位\n\t\t\t++s;\n\t\tif (arr[s] <= cur) break; // 父亲值大，镇压\n\t\tarr[f] = arr[s]; // 儿子值大，禅位\n\t\tf = s; // 下一代的父亲\n\t\ts = f * 2 + 1; // 下一代的儿子\n\t}\n\tarr[f] = cur;\n}\n\nvoid heapSort(vector<int>& arr) {\n\tint n = arr.size();\n    // 数组形成堆\n\tfor (int p = (n - 2) / 2; p >= 0; --p)\n\t\tdownMethod(arr, p, n);\n    // 堆首尾交换进行排序\n\tfor (int p = n-1; p > 0; --p) {\n\t\tswap(arr[0], arr[p]);\n\t\tdownMethod(arr, 0, p);\n\t}\n}\n```\n\n## 6. 归并排序\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)\n- 稳定\n### 6.1 递归版本\n```c++\n// [l, m] [m+1, r]\nvoid mergeTwoArray(vector<int>& arr, vector<int>& trr, int l, int m, int r) {\n\tint i = l, j = m + 1, k = l;\n\twhile (i <= m || j <= r) { // k <= r 一样\n\t\tint a = i <= m ? arr[i] : INT_MAX;\n\t\tint b = j <= r ? arr[j] : INT_MAX;\n\t\tif (a < b) ++i; // 每次i和j只能有一个增加\n\t\telse ++j;\n\t\ttrr[k++] = a < b ? a : b;\n\t}\n\twhile (l <= r) { // 拷贝回去\n\t\tarr[l] = trr[l];\n\t\t++l;\n\t}\n}\n\nvoid mergeRecursion(vector<int>& arr, vector<int>& trr, int l, int r) {\n\tif (l == r) return;\n\tint m = l + ((r - l) >> 1);\n\tmergeRecursion(arr, trr, l, m);\n\tmergeRecursion(arr, trr, m + 1, r);\n\tmergeTwoArray(arr, trr, l, m, r);\n}\n\nvoid mergeSort(vector<int>& arr) {\n\tint n = arr.size();\n\tvector<int> trr(arr); // 避免频繁创建子数组\n\tmergeRecursion(arr, trr, 0, n - 1);\n}\n```\n### 6.2 非递归版本\n```c++\n// [l, m] [m+1, r]\nvoid mergeTwoArray(vector<int>& arr, vector<int>& trr, int l, int m, int r) {\n\tint i = l, j = m + 1, k = l;\n\twhile (i <= m || j <= r) { // k <= r 一样\n\t\tint a = i <= m ? arr[i] : INT_MAX;\n\t\tint b = j <= r ? arr[j] : INT_MAX;\n\t\tif (a < b) ++i; // 每次i和j只能有一个增加\n\t\telse ++j;\n\t\ttrr[k++] = a < b ? a : b;\n\t}\n    // 不用拷贝回去...\n}\n\nvoid mergeSort(vector<int>& arr) {\n\tint n = arr.size();\n\tint range = 1;\n\tvector<int> trr(arr); // 避免频繁创建子数组\n\twhile (range < n) {\n\t\tfor (int i = 0; i < n; i += range*2) { // arr -> trr\n\t\t\tint m = i + range - 1;\n\t\t\tif (m >= n - 1) m = n - 1; // 不能break\n\t\t\tint r = i + range * 2 - 1;\n\t\t\tif (r >= n - 1) r = n - 1;\n\t\t\tmergeTwoArray(arr, trr, i, m, r);\n\t\t}\n\t\trange <<= 1;\n\t\tfor (int i = 0; i < n; i += range*2) { // trr -> arr\n\t\t\tint m = i + range - 1;\n\t\t\tif (m >= n - 1) m = n - 1; // 不能break\n\t\t\tint r = i + range * 2 - 1;\n\t\t\tif (r >= n - 1) r = n - 1;\n\t\t\tmergeTwoArray(trr, arr, i, m, r);\n\t\t}\n\t\trange <<= 1;\n\t}\n}\n```\n\n## 7. 快速排序\n- 时间复杂度：O(NlogN)\n- 空间复杂度：栈上O(logN)\n- 不稳定\n- 注意1：遇到l和r指向相等时，需要交换，不然遇到全1的数组，退化为n^2\n- 注意2：快排在数据范围较小时（`r-l<threshold`）直接使用插入排序可有效优化速度\n### 7.1 实现1（朴素版）\n```c++\nvoid quickRecursion(vector<int>& arr, int l, int r) {\n\tif (l >= r) return;\n\tint oldl = l, oldr = r;\n\t// 选 [枢纽]\n\tint pivot = arr[l];\n\t// 排序\n\t++r;\n\twhile (l < r) {\n\t\twhile (l < r && arr[--r] > pivot); // 右侧先动是安全的\n\t\twhile (l < r && arr[++l] < pivot); // 左侧后动\n\t\tif (l < r) swap(arr[l], arr[r]);\n\t}\n\tswap(arr[oldl], arr[l]);\n\tquickRecursion(arr, oldl, r - 1);\n\tquickRecursion(arr, r + 1, oldr);\n}\n\nvoid quickSort(vector<int>& arr) {\n\tint n = arr.size();\n\tquickRecursion(arr, 0, n - 1);\n}\n```\n### 7.2 实现2（改进朴素版）\n```c++\nint pivot = arr[l];\n// 改为\nint randomPos = l + rand()%(r-l+1);\nswap(arr[l], arr[randomPos]);\nint pivot = arr[l];\n```\n### 7.3 实现3（中间值枢纽）\n```c++\n// 三数选中间数并将最小值放在l，最大值放在r，中间值(pivot)放在l+1\n// 陈姥姥代码里是放在r-1的，这样肯定正确因为m肯定<r\n// 我为了兼容朴素版的大部分代码，选择放在l+1，这样由于m可能等于l，所以需要多一次特殊点判断\nint median3(vector<int>& arr, int l, int r) {\n\tint m = l + ((r - l) >> 1);\n\tif (arr[l] > arr[m])\n\t\tswap(arr[l], arr[m]);\n\tif (arr[l] > arr[r])\n\t\tswap(arr[l], arr[r]);\n\tif (arr[m] > arr[r])\n\t\tswap(arr[m], arr[r]);\n\tif (l == m) return arr[l]; // 特殊点\n\tswap(arr[m], arr[l + 1]);\n\treturn arr[l + 1];\n}\n\nvoid quickRecursion(vector<int>& arr, int l, int r) {\n\tif (l >= r) return;\n\tint oldl = l, oldr = r;\n\t// 选 [枢纽]\n\tint pivot = median3(arr, l, r);\n\n\t// 排序\n\t++l; // 注意：两端收缩了一位\n\twhile (l < r) {\n\t\twhile (l < r && arr[--r] > pivot); // 右侧先动是安全的\n\t\twhile (l < r && arr[++l] < pivot); // 左侧后动\n\t\tif (l < r) swap(arr[l], arr[r]);\n\t}\n\tswap(arr[oldl + 1], arr[l]); // 注意：pivot枢纽放在了l+1位置\n\tquickRecursion(arr, oldl, r - 1);\n\tquickRecursion(arr, r + 1, oldr);\n}\n\nvoid quickSort(vector<int>& arr) {\n\tint n = arr.size();\n\tquickRecursion(arr, 0, n - 1);\n}\n```\n### 7.4 实现4（有限制）\n虽然代码看起来很简洁，但是有如下问题：\n1. 极端情况会退化为n^2算法\n2. 正因如此，在我的实验中，对3w个分布0~99的数字排序，会栈溢出（异常结束，main函数return 非0）。其实前面的方法里，移动i和j时如果`>`改为`>=`、`<`改为`<=`也会出现这种问题哦。因此在数据分布较窄时，这种方法无疑是低效的\n```c++\nvoid quickRecursion(vector<int>& arr, int l, int r) {\n\tif (l >= r) return;\n\t// 选 [枢纽] 可改进随机化但效果还是差\n\tint pivot = arr[l];\n\n\t// 排序\n\tint j = l;\n\tfor (int i = l + 1; i <= r; ++i) {\n\t\tif (arr[i] < pivot) {\n\t\t\t++j;\n\t\t\tswap(arr[i], arr[j]);\n\t\t}\n\t}\n\tswap(arr[j], arr[l]);\n\n\tquickRecursion(arr, l, j - 1);\n\tquickRecursion(arr, j + 1, r);\n}\n\nvoid quickSort(vector<int>& arr) {\n\tint n = arr.size();\n\tquickRecursion(arr, 0, n - 1);\n}\n```\n\n# 三、特殊排序\n## 8. 计数排序\n- 时间复杂度：O(B+N)，B是数据范围一般较小，可认为是O(N)\n- 空间复杂度：栈上O(B+N) -> O(N)\n- 稳定（实现的不好则不稳定，比如从前往后填）\n```c++\nvoid countingSort(vector<int>& arr) {\n\tint n = arr.size();\n\tint maxV = INT_MIN;\n\tfor (auto& e : arr) maxV = maxV > e ? maxV : e;\n\tvector<int> counting(maxV + 1); // 计数数组\n\tvector<int> trr(arr); // 留作中转拷贝\n\tfor (auto& e : arr) ++counting[e]; // 计数\n\tfor (int i = 1; i < counting.size(); ++i) // 累加计数\n\t\tcounting[i] = counting[i - 1] + counting[i];\n\tfor (int i = n - 1; i >= 0; --i) { // 从后向前填：稳定的排序\n\t\tint pos = --counting[arr[i]];\n\t\ttrr[pos] = arr[i];\n\t}\n\tfor (int i = 0; i < n; ++i) // 拷回去\n\t\tarr[i] = trr[i];\n}\n```\n## 9. 基数排序\n- 时间复杂度：O(Rs * N)，Rs是数据最大值的位数一般较小，可认为是O(N)\n- 空间复杂度：栈上O(10 + N) -> O(N)\n- 稳定（实现的不好则不稳定，比如从前往后填）\n- 经常利用计数排序实现\n### 9.1 LSD基数排序\n1. 最低位优先(Least Significant Digit first, LSD)，先排低位；再排高位\n2. 由于每一位介于0~9，所以对每一个基位排序时都可看做是分为10个桶的桶排序\n```c++\n// 获得一个int的某一位的数字\n// 例如13247 r=0 -> 7 | r=1 -> 4 | r=2 -> 2 | r=3 -> 3 | r=4 -> 1 | r = 5 -> 0 \nint getRadix(int num, int r) {\n\tstatic int radices[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\tnum %= radices[r + 1];\n\treturn num / radices[r];\n}\n\nvoid radixSortLSD(vector<int>& arr) {\n\tint n = arr.size();\n\tint maxV = INT_MIN;\n\tfor (auto& e : arr) maxV = maxV > e ? maxV : e;\n\tint radixNum = 0;\n\twhile (maxV) {\n\t\t++radixNum;\n\t\tmaxV /= 10;\n\t}\n\tvector<int> trr(arr); // 留作中转拷贝\n\tfor (int r = 0; r < radixNum; ++r) {\n\t\tvector<int> counting(10); // 计数数组\n\t\tfor (auto& e : arr) ++counting[getRadix(e, r)]; // 计数\n\t\tfor (int i = 1; i < counting.size(); ++i) // 累加计数\n\t\t\tcounting[i] = counting[i - 1] + counting[i];\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tint pos = --counting[getRadix(arr[i], r)];\n\t\t\ttrr[pos] = arr[i];\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) // 拷回去\n\t\t\tarr[i] = trr[i];\n\t}\n}\n```\n### 9.2 MSD基数排序\n- 最高位优先(Most Significant Digit first, MSD)，先排高位；再排低位\n- MSD一般采用递归写法：按高位分组，形成连续区段，然后在区段内递归处理低一位\n```c++\n// 获得一个int的某一位的数字\n// 例如13247 r=0 -> 7 | r=1 -> 4 | r=2 -> 2 | r=3 -> 3 | r=4 -> 1 | r = 5 -> 0 \nint getRadix(int num, int r) {\n\tstatic int radices[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\n\tnum %= radices[r + 1];\n\treturn num / radices[r];\n}\n\nvoid radixRecursion(vector<int>& arr, vector<int>& trr, int l, int r, int d) {\n\tif (l >= r || d < 0) return;\n\tvector<int> counting(10);\n\tfor (int i = l; i <= r; ++i) \n\t\t++counting[getRadix(arr[i], d)]; // l~r 计数\n\tfor (int i = 1; i < counting.size(); ++i) \n\t\tcounting[i] = counting[i - 1] + counting[i]; // 累加计数\n\tfor (int i = r; i >= l; --i) {\n\t\tint pos = --counting[getRadix(arr[i], d)] + l; // + l 偏移别忘了\n\t\ttrr[pos] = arr[i];\n\t}\n\tfor (int i = l; i <= r; ++i) // 拷回去\n\t\tarr[i] = trr[i];\n\tfor (int i = 0; i < 10; ++i) {\n\t\tif (i == 0) radixRecursion(arr, trr, l, l + counting[0] - 1, d - 1);\n\t\telse radixRecursion(arr, trr, l + counting[i - 1], l + counting[i] - 1, d - 1);\n\t}\n}\n\nvoid radixSortMSD(vector<int>& arr) {\n\tint n = arr.size();\n\tint maxV = INT_MIN;\n\tfor (auto& e : arr) maxV = maxV > e ? maxV : e;\n\tint radixNum = 0;\n\twhile (maxV) {\n\t\t++radixNum;\n\t\tmaxV /= 10;\n\t}\n\tvector<int> trr(arr); // 留作中转拷贝\n\tradixRecursion(arr, trr, 0, n - 1, radixNum-1);\n}\n```\n## 10. 桶排序\n- 桶排序的时间复杂度和空间复杂度以及是不是稳定都看你采取的子排序算法\n- 桶排序一般用于数据**分布均匀**的\n- 桶排序用于遏制N^2、NlogN等复杂度的算法因数据量太大而带来的速度问题\n```c++\nvoid insertSort(vector<int>& arr) {\n\tint n = arr.size();\n\tfor (int i = 1; i < n; ++i) {\n\t\tint cur = arr[i];\n\t\tint j = i - 1;\n\t\tfor (; j >= 0 && arr[j] > cur; --j)\n\t\t\tarr[j + 1] = arr[j];\n\t\tarr[j + 1] = cur;\n\t}\n}\n\nvoid bucketSort(vector<int>& arr) {\n\tint n = arr.size();\n\tint maxV = INT_MIN;\n\tfor (auto& e : arr) maxV = maxV > e ? maxV : e;\n\t++maxV;\n\tint bckNum = 10; // 分十个桶\n\tvector<vector<int>> buckets(bckNum, vector<int>());\n\tfor (auto& e : arr) {\n\t\tint pos = e * 10 / maxV;\n\t\tbuckets[pos].push_back(e); // 放进桶里\n\t}\n\tfor (auto& b : buckets) { // 随意选取排序算法\n\t\tinsertSort(b);\n\t}\n\tint k = 0;\n\tfor (int i = 0; i < buckets.size(); ++i)\n\t\tfor (int j = 0; j < buckets[i].size(); ++j)\n\t\t\tarr[k++] = buckets[i][j]; // 从桶里面拿出来\n}\n```\n# 四、辅助代码\n- 获取数据、判断排序合格、显示已排序frontN等\n```c++\n#pragma once\n#include <iostream>\n#include <vector>\n#include <fstream>\n#include <string>\nusing namespace std;\n\nclass Data{\npublic:\n\tData(string fn, int _n) : arr(_n) {\n\t\tfstream file;\n\t\tfile.open(fn, ios::in);\n\t\tif (!file) {\n\t\t\tthrow string(\"ERROR!\");\n\t\t}\n\t\tfor (auto& e : arr)\n\t\t\tfile >> e;\n\t\tfile.close();\n\t}\n\tvector<int>&& getData() { return move(arr); }\nprivate:\n\tvector<int> arr;\n};\n\nbool isSorted(vector<int>& arr) {\n\tfor (int i = 1; i < arr.size(); ++i)\n\t\tif (arr[i] < arr[i - 1]) return false;\n\treturn true;\n}\n\nvoid showFrontN(vector<int>& arr, int n) {\n\tn = n > arr.size() ? arr.size() : n;\n\tfor (int i = 0; i < n;) {\n\t\tint cnt = 0;\n\t\tfor (; cnt < 10 && i + cnt < n; ++cnt) // 每行十列显示\n\t\t\tcout << arr[i + cnt] << \"\\t\";\n\t\tcout << endl;\n\t\ti += cnt;\n\t}\n}\n```\n```c++\nint main() {\n\tData dataGenerator(\"Data.txt\", 1000);\n\tvector<int> arr = dataGenerator.getData();\n\n\t# yourSort(arr);\n\tshowFrontN(arr, 100);\n\n\tif (isSorted(arr)) cout << \"排序完成\" << endl;\n\telse cout << \"排序出错\" << endl;\n\treturn 0;\n}\n```","tags":["算法","递归","排序"]},{"title":"Set、Map、Unordered","url":"/2022/03/27/Set、Map、Unordered/","content":"# Map和Set\n- Map是`<key, value>`结构；Set是`<key>`结构，天然具有去重功能。\n- 自定义类放入Map或Set需要实现`bool operator<(const MyClass& ano) const`，注意里面的两个const是必备的，不能漏。\n- 不用实现`operator=`，因为`a<b == false && a>b == false`会自动推断出等于。所以当你放入自己的类的时候，\n\n## 0、示范图\n```c++\n           0\n           |\n          (1)\n           |\n  2 —(1)—  1  —(1)— 3\n     \\           /\n     (3)       (2)\n        \\     /\n           4\n```\n## 1、错误代码示例\n- 下面`Node`类，利用Set来实现Dijkstra是不对的，因为在`operator<`中参与返回结果的只有`val`因此，两个不一样的`Node`在`Set`中会被认为是相同的。即`Node a = Node({1,1})和Node b = Node({2,1})`，由于`(a<b==false && b>a==false)`所以被判定为相等，与我们的目的南辕北辙。\n```c++\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int inf = INT_MAX;\nstruct Node {\n\tNode(int _p, int _v):pos(_p), val(_v){}\n\tint pos;\n\tint val;\n\tbool operator<(const Node& ano) const {\n\t\treturn this->val < ano.val;\n\t}\n};\n\nint main() {\n\tvector<vector<int>> g = {\n\t\t{0,   1,   inf, inf, inf},\n\t\t{1,   0,   1,   1,   inf},\n\t\t{inf, 1,   0,   inf, 3  },\n\t\t{inf, 1,   inf, 0,   2  },\n\t\t{inf, inf, 3,   2,   0  },\n\t};\n\tint n = (int)g.size();\n\t// ------------------------------------\n\tvector<int> dist(n, INT_MAX);\n\tdist[0] = 0;\n\tset<Node> pq;\n\tpq.insert(Node(0, 0));\n\twhile (!pq.empty()) {\n\t\tNode cur = *pq.begin(); pq.erase(pq.begin());\n\t\tint from = cur.pos;\n\t\tint dis = cur.val;\n\t\tcout << from << \" \" << cur.val << endl;\n\t\tfor (int to = 0; to < n; ++to) {\n\t\t\tif (g[from][to] < inf && dist[to] > dis + g[from][to]) {\n\t\t\t\tdist[to] = dis + g[from][to];\n\t\t\t\tpq.insert(Node(to, dist[to]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto e : dist)\n\t\tcout << e << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出结果为：\n```c++\n0 0\n1 1\n2 2\n4 5\n0 1 2 2 5 // 错误，应该是4\n// 原因是插入Node{3,2}时发现已经有了，所以就取消插入，因此无法利用{3,2}来更新最小边\n```\n\n\n## 2、正确用法priority_queue\n```c++\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nconst int inf = INT_MAX;\nstruct Node {\n\tNode(int _p, int _v):pos(_p), val(_v){}\n\tint pos;\n\tint val;\n\tbool operator>(const Node& ano) const {\n\t\treturn this->val > ano.val;\n\t}\n};\n\nint main() {\n\tvector<vector<int>> g = {\n\t\t{0,   1,   inf, inf, inf},\n\t\t{1,   0,   1,   1,   inf},\n\t\t{inf, 1,   0,   inf, 3  },\n\t\t{inf, 1,   inf, 0,   2  },\n\t\t{inf, inf, 3,   2,   0  },\n\t};\n\tint n = (int)g.size();\n\t// ------------------------------------\n\tvector<int> dist(n, INT_MAX);\n\tdist[0] = 0;\n\tpriority_queue<Node, vector<Node>, greater<Node>> pq;\n\tpq.push(Node(0, 0));\n\twhile (!pq.empty()) {\n\t\tNode cur = pq.top(); pq.pop();\n\t\tint from = cur.pos;\n\t\tint dis = cur.val;\n\t\tcout << from << \" \" << cur.val << endl;\n\t\tfor (int to = 0; to < n; ++to) {\n\t\t\tif (g[from][to] < inf && dist[to] > dis + g[from][to]) {\n\t\t\t\tdist[to] = dis + g[from][to];\n\t\t\t\tpq.push(Node(to, dist[to]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto e : dist)\n\t\tcout << e << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n```\n输出结果为：\n```c++\n0 0\n1 1\n2 2\n3 2 // OK\n4 4\n4 5\n0 1 2 2 4 // OK\n```\n## 总之，以后写Dijkstra不要妄图用set和map来替换优先队列!!!\n\n\n\n# Unordered_set和unordered_map\n1. 需要定义一个仿函数`operator(...)`用来计算hash_value，并在定义时传入模板参数\n2. 重载`operator==`\n```c++\n#include <iostream>\nusing namespace std;\n\n#include <string>\n#include <unordered_map>\nstruct node {\n\tnode(int _id, double _val) : id(_id), val(_val) {}\n\tint id;\n\tdouble val;\n\tbool operator==(const node& ano) const { // 判断两个对象是否相等（自动加上key匹配再判断相等）\n\t\treturn val == ano.val;\n\t}\n};\n\nstruct node_hash {\n\tsize_t operator()(const node& v) const { // 生成hash value，必须返回 [无符号整数] 用来进行映射\n\t\treturn v.id; // 生成hash value的方式都可以灵活自定义\n\t\t//return hash<double>()(v.val);\n\t}\n};\n\nint main() {\n\tunordered_map<node, string, node_hash> ms;\n\tnode a = { 1, 1.1111 };\n\tnode b = { 2, 1.1111 };\n\tms[a] = \"aaaa\";\n\tms[b] = \"bbbb\";\n\tcout << ms[a] << endl;\n\tcout << ms[b] << endl;\n\treturn 0;\n}\n```","tags":["C/C++"]},{"title":"单例模式","url":"/2022/03/26/单例模式/","content":"# 单例模式\n## 1、普通版本（高并发效率不足）（安全）\n- 在类中添加一个私有静态成员单例实例的指针。\n- 声明一个公有静态构建方法用于获取单例实例的指针。\n- 在静态方法中实现\"延迟初始化\"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。\n- 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。\n- 检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。\n```c++\n#include <iostream>\n#include <string>\n#include <mutex>\nusing namespace std;\n\nclass Singleton {\nprotected:\n\tSingleton(const string& val) : data(val) {} // 构造函数\n\t~Singleton() {}\n\tstatic Singleton* _instance; // 静态：实例的指针\n\tstatic mutex _mutex;\n\tstring data; // 代表类内的资源\n\npublic:\n\tSingleton(const Singleton& another) = delete; // 禁止拷贝构造\n\tSingleton& operator=(const Singleton& another) = delete; // 禁止赋值\n\tstatic Singleton* getInstance(const string& val); // 静态：获取实例\n\tvoid show() { cout << \"data: \" << data << endl; } // 测试\n};\n\n// 静态成员需要在类外定义\nSingleton* Singleton::_instance = nullptr;\nmutex Singleton::_mutex;\n\nSingleton* Singleton::getInstance(const string& val) {\n\tlock_guard<mutex> lock(_mutex); // 出作用域自动释放\n\tif (_instance == nullptr) {\n\t\t_instance = new Singleton(val);\n\t}\n\treturn _instance;\n}\n\nint main() {\n\tSingleton* a = Singleton::getInstance(\"aaa\");\n\ta->show(); // \"aaa\" ok\n\tSingleton* b = Singleton::getInstance(\"bbb\");\n\tb->show(); // \"aaa\" ok\n\treturn 0;\n}\n```\n## 2、双检查锁（有隐患）\nreorder问题：通常new通常有三步：1、分配一块内存空间；2、执行构造器；3、返回指针；\n但是由于编译器有时会进行优化，执行顺序变为132：即分配空间后先返回指针，再执行构造器\n这样就会到来危险，比如线程A执行new，132，3执行完；线程B发现m_instance非空返回，然后外部直接用这个指针会出错\n```c++\n//双检查锁，但由于内存读写reorder不安全（不安全）\nSingleton* Singleton::getInstance() {\n    if(m_instance==nullptr){ // 第一次检查，主要解决性能问题，毕竟读操作不需要上锁\n        Lock lock;\n        if (m_instance == nullptr) { // 第二次检查，解决核心问题：只能new单个\n            m_instance = new Singleton();\n        }\n    }\n    return m_instance;\n}\n```\n## 3、双检查锁（安全）\n```c++\n//C++ 11版本之后的跨平台实现 (volatile)（安全）\nstd::atomic<Singleton*> Singleton::m_instance;\nstd::mutex Singleton::m_mutex;\n\nSingleton* Singleton::getInstance() {\n    Singleton* tmp = m_instance.load(std::memory_order_relaxed);\n    std::atomic_thread_fence(std::memory_order_acquire); // 获取内存fence\n    if (tmp == nullptr) {\n        std::lock_guard<std::mutex> lock(m_mutex);\n        tmp = m_instance.load(std::memory_order_relaxed);\n        if (tmp == nullptr) {\n            tmp = new Singleton;\n            std::atomic_thread_fence(std::memory_order_release); // 释放内存fence\n            m_instance.store(tmp, std::memory_order_relaxed);\n        }\n    }\n    return tmp;\n}\n```\n\n## 参考资料\n1. [Refactoring.Guru](https://refactoringguru.cn/design-patterns/catalog)\n2. 李建忠 设计模式 课程","tags":["C/C++","设计模式"]},{"title":"线程安全智能指针","url":"/2022/03/24/线程安全智能指针/","content":"# 线程安全的share指针\n## 1. 代码部分\n```c++\n#include <iostream>\n#include <mutex>\nusing namespace std;\n\nclass Counter{\npublic:\n\tCounter(): m_Counter(0) {}\n\tCounter(const Counter&) = delete;\n\tCounter& operator=(const Counter&) = delete;\n\t~Counter() {}\n\tvoid reset() { m_Counter = 0; }\n\tunsigned int get() const { return m_Counter; }\n\tvoid operator++() { m_Counter++; }\n\tvoid operator++(int) { m_Counter++; }\n\tvoid operator--() { m_Counter--; }\n\tvoid operator--(int) { m_Counter--; }\n\nprivate:\n\tunsigned int m_Counter{}; // 花括号也可以初始化\n};\n\ntemplate<typename T>\nclass SharedPtr{\npublic:\n\texplicit SharedPtr(T *ptr = nullptr): // explicit\n\t\tpData(ptr),\n\t\tpCounter(new Counter()),\n\t\tpMutex(new std::mutex)\n\t{\n\t\tif (ptr) {\n\t\t\taddCount();\n\t\t}\n\t}\n\n\tSharedPtr(const SharedPtr<T>& sp) {\n\t\tpData = sp.pData;\n\t\tpCounter = sp.pCounter;\n\t\tpMutex = sp.pMutex;\n\t\taddCount();\n\t}\n\n\tSharedPtr<T>& operator=(const SharedPtr<T>& sp) {\n\t\tif (pData != sp.pData) {\n\t\t\tsubCount();\n\t\t\tpData = sp.pData;\n\t\t\tpCounter = sp.pCounter;\n\t\t\tpMutex = sp.pMutex;\n\t\t\taddCount();\n\t\t}\n\t}\n\n\tT* operator->() { return pData; }\n\n\tT& operator*() { return *pData; }\n\n\tT* get() { return pData; }\n\n\tunsigned int getCount() { return pCounter->get(); }\n\n\t~SharedPtr() { subCount(); }\n\nprivate:\n\tvoid addCount() {\n\t\tpMutex->lock();\n\t\t++(*pCounter);\n\t\tpMutex->unlock();\n\t}\n\n\tvoid subCount() {\n\t\tbool deleteflag = false;\n\t\tpMutex->lock();\n\t\t--(*pCounter);\n\t\tif (pCounter->get() == 0) {\n\t\t\tdelete pCounter;\n\t\t\tdelete pData;\n\t\t\tdeleteflag = true;\n\t\t}\n\t\tpMutex->unlock();\n\t\tif (deleteflag == true) delete pMutex;\n\t}\n\nprivate:\n\tT *pData;\n\tstd::mutex *pMutex;\n\tCounter *pCounter;\n};\n\nclass MyClass {\npublic:\n\tMyClass() {\n\t\tcout << \"Constructor\" << endl;\n\t}\n\t~MyClass() {\n\t\tcout << \"Destructor\" << endl;\n\t}\n};\n\nint main() {\n\tSharedPtr<MyClass> p(new MyClass());\n\tSharedPtr<MyClass> p2 = p;\n\tcout << \"END\" << endl;\n\treturn 0;\n}\n```\n## 2. 参考资料\n- [1. 线程安全智能指针](https://blog.csdn.net/songguangfan/article/details/121974538)\n- [2. 智能指针](https://www.cnblogs.com/WindSun/p/11444429.html)","tags":["C/C++"]},{"title":"LC-540 二分变种","url":"/2022/03/21/LC-540-二分变种/","content":"# 540 [有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)\n## 我的二分\n- 与右侧配对失败:\n    - 右侧是奇数: `l = m + 1`\n    - 右侧是偶数: `r = m`\n- 与右侧配对成功:\n    - 右侧是奇数: `l = m + 2`\n    - 右侧是偶数: `r = m - 1`\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int l = 0, r = nums.size()-1;\n        while(l < r){ // 这样可以放心取m+1不越界\n            int m = (l + r) >> 1;\n            if(nums[m] != nums[m+1]){\n                if((r-m) & 1) l = m + 1;\n                else r = m;\n            }else{\n                if((r-m-1) & 1) l = m + 2;\n                else r = m - 1;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n\n## 官方的全数组二分查找\n- 假设要找的是数字X，则在X左边的数，下标是偶数的都是重复数字的第一位，下标是奇数的都是重复数字的第二位；在X右边的数，下标是奇数的都是重复数字的第一位，下标是偶数的都是重复数字的第二位；\n- 取中值时，若m是偶数，则尝试与m+1比较是否相等，相等则表明[:m+1]正常，X在m+1的右侧，因此`l = m + 2`；若不相等，则X在[:m]，因此`r = m`\n- 取中值时，若m是奇数，则尝试与m-1比较是否相等，相等则表明[:m]正常，X在m的右侧，因此`l = m + 1`；若不相等，则X在[:m]，因此`r = m`\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if((m & 1) && nums[m] == nums[m-1]){ // 奇数\n                l = m + 1;\n            }else if(!(m & 1) && nums[m] == nums[m+1]){ // 偶数\n                l = m + 2;\n            }else{\n                r = m;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n- 上述思想可以在代码层面进行简化`m ^ 1`，对于偶数表示`m + 1`；对于奇数表示`m - 1`，同时照顾到短板，每次更新`l`时，有`l = m + 1`\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int m = (l + r) >> 1;\n            if (nums[m] == nums[m ^ 1]) { // 这是技巧\n                l = m + 1;\n            }else{\n                r = m;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n## 官方的偶数范围二分查找\n- X的下标一定是偶数\n```c++\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int l = 0, r = nums.size()-1;\n        while (l < r) {\n            int m = (r - l) / 2 + l;\n            m -= m & 1; // 变为偶数\n            if (nums[m] == nums[m + 1]) { // [...m+1]都ok\n                l = m + 2;\n            } else {\n                r = m;\n            }\n        }\n        return nums[l];\n    }\n};\n```\n","tags":["算法","二分法"]},{"title":"LC-33-153-162 旋转数组二分","url":"/2022/03/21/LC-33-153-162-旋转数组二分/","content":"# 162 [寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)\n找到任意一个峰值，你可以假设 nums[-1] = nums[n] = -∞ 。\n## 二分法（不怎么优雅）\n```c++\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int l = 0, r = nums.size()-1;\n        while(l <= r){\n            int m = (l + r) / 2;\n            if(m-1>=0 && nums[m-1]>nums[m]) r = m - 1;\n            else if(m+1<nums.size() && nums[m+1]>nums[m])\n                l = m + 1;\n            else\n                return m;\n        }\n        return 0; // 永远不会走\n    }\n};\n```\n## 二分法（优雅）\n**其实只要搞清楚我们「二分」什么内容，根本不会存在说用哪种方式才能写过的情况。**\n```c++\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int l = 0, r = nums.size()-1;\n        while(l < r){\n            int m = (l + r)>>1;\n            // 这里m+1不会越界，因为l <= m < r，所以m-1是可能越界的，m+1必然不会越界\n            if(nums[m] > nums[m+1])\n                r = m;  // 注意\n            else\n                l = m + 1;  // 注意\n        }\n        return l;\n    }\n};\n```\n\n# 153 [寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)\n![图解](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/LC-153.png)\n## 二分法\n- 如上图所示，如果每次以 $nums[l] < nums[m]$ 为条件虽然可以认定左区间是单调的，但是就全局最小值而言无法区分图1和图2的；但是以 $nums[m] < nums[r]$ 可以认定右区间单调，且可以区分所有最小值情况。一定要理解二分时收缩区间的含义。\n- 不能动不动l = m+1，r = m-1这种大起大和的方式，因为目的是求极值而不是target，target不等于的时候，某一边确实可以跳；但是求极值时，例如下面代码中r = m，因为不确定nums[m]是不是极值，所以不能写成r = m - 1。\n```c++\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int l = 0, r = nums.size()-1;\n        while(l < r){\n            int m = (l + r) / 2;\n            if(nums[m] < nums[r])\n                r = m; // 注意\n            else\n                l = m + 1;  // 注意\n        }\n        return nums[l];\n    }\n};\n```\n> 为什么左右不对称？为什么比较mid与right而不比较mid与left？能不能通过比较mid与left来解决问题？<br>\n> 左右不对称的原因是：这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。<br>\n为什么比较mid与right而不比较mid与left？具体原因前面已经分析过了，简单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。<br>\n那么能不能通过比较mid与left来解决问题？能，转换思路，不直接找最小值，而是先找最大值，最大值偏右，可以通过比较mid与left来找到最大值，最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）。<br>\n作者：armeria-program\n链接：https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/ 来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n# 33 [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)\n## 二分法（易理解）\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size(), l = 0, r = n - 1;\n        while(l <= r){\n            int m = (l + r) >> 1;\n            if(nums[m] == target) return m;\n            \n            // 因为如果就俩数，除以二肯定l == m, r == m+1\n            if(nums[l] == nums[m]){\n                if(r < n && nums[r] == target) return r;\n                else return -1;\n            }\n            else if(nums[l] < nums[m]){ // 左边正常\n                if(target >= nums[l] && target < nums[m]) \n                    r = m - 1;\n                else \n                    l = m + 1;\n            }\n            else{ // 右边正常\n                if(target > nums[m] && target <= nums[r])\n                    l = m + 1;\n                else\n                    r = m - 1;\n            }\n        }\n        return -1;\n    }\n};\n```\n## 二分法（优雅）\n- **牢记：左区间是[l, m]，右区间是[m+1, r]，所以“左区间正常”包含等号**\n- 由于前一步 `if(nums[m] == target) return m;` 已经判定了 $nums[m] != target$ ，所以后面对target和nums[m]的比较**不带等号**\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size(), l = 0, r = n - 1;\n        while(l <= r){\n            int m = (l + r) >> 1;\n            if(nums[m] == target) return m;\n            if(nums[l] <= nums[m]){ // 左边正常\n                if(target >= nums[l] && target < nums[m]) \n                    r = m - 1;\n                else \n                    l = m + 1;\n            }\n            else{ // 右边正常\n                if(target > nums[m] && target <= nums[r])\n                    l = m + 1;\n                else\n                    r = m - 1;\n            }\n        }\n        return -1;\n    }\n};\n```\n## 2022.08.10\n```c++\n// while等号和不等号\nclass Solution {\npublic:\n    int search(const vector<int>& arr, int target) {\n        int l = 0, r = arr.size() - 1;\n        while(l < r){\n            int m = (l+r)/2;\n            if(arr[m] == target) return m;\n            if(arr[m] < arr[r]){ // 右边正常（互不相同所以没等于）\n                if(target > arr[m] && target<=arr[r]) l = m + 1;\n                else r = m - 1;\n            }else{ // 左边正常\n                if(target >= arr[l] && target<arr[m]) r = m - 1;\n                else l = m + 1;\n            }\n        }\n        return arr[l] == target?l:-1;\n    }\n};\n\nclass Solution {\npublic:\n    int search(vector<int>& arr, int target) {\n        int l = 0, r = arr.size() - 1;\n        while(l <= r){\n            int m = (l+r)/2;\n            if(arr[m] == target) return m;\n            if(arr[m] < arr[r]){ // 右边正常（互不相同所以没等于）\n                if(target > arr[m] && target<=arr[r]) l = m + 1;\n                else r = m - 1;\n            }else{ // 左边正常\n                if(target >= arr[l] && target<arr[m]) r = m - 1;\n                else l = m + 1;\n            }\n        }\n        return -1;\n    }\n};\n```","tags":["算法","二分法"]},{"title":"LC-82-83 链表去重","url":"/2022/03/20/LC-82-83-链表去重/","content":"# 83 [删除排序链表中重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)\n## 前序遍历\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head) return head;\n        ListNode* ptr = head->next;\n        while(ptr && head->val == ptr->val) ptr = ptr->next;\n\n        // 下面俩方式效果一样\n        head->next = deleteDuplicates(ptr);\n        // head->next = ptr;\n        // deleteDuplicates(ptr);\n        return head;\n    }\n};\n```\n## 后续遍历\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head) return head;\n        // 有点像并查集里的路径压缩\n        head->next = deleteDuplicates(head->next);\n        if(head->next && head->val == head->next->val)\n            return head->next;\n        return head;\n    }\n};\n```\n## 迭代法\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) return head;\n        ListNode* cur = head;\n        while (cur->next) {\n            if (cur->val == cur->next->val) \n                cur->next = cur->next->next;\n            else \n                cur = cur->next;\n        }\n        return head;\n    }\n};\n```\n\n## 迭代法：双指针\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (!head) return head;\n        ListNode* slow = head, *fast = head;\n        while(fast){\n            if(fast->val != slow->val){\n                slow->next = fast;\n                slow = slow->next;\n            }\n            fast = fast->next;\n        }\n        slow->next = nullptr; // 别忘了\n        return head;\n    }\n};\n\n// 类似于数组去重，一模一样\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int slow = 0, fast = 0;\n        while(fast < nums.size()){\n            if(nums[slow] != nums[fast]){\n                nums[++slow] = nums[fast];\n            }\n            ++fast;\n        }\n        return slow + 1;\n    }\n};\n```\n\n# 82 [删除排序链表中的重复元素Ⅱ](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)\n## 递归\n```c++\nclass Solution {\npublic:\n    int prev = INT_MAX;\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head->next){\n            if(head) prev = head->val;\n            return head;\n        }\n        head->next = deleteDuplicates(head->next);\n        while(head && head->val == prev) // 如果要delete，在这里\n            head = head->next;\n        if(head && head->val < prev) // 小于号很重要，因为是递增链表，防止prev更新旧值\n            prev = head->val;\n        return head;\n    }\n};\n```\n## 递归2(类似83后续遍历)\n```c++\nclass Solution {\npublic:\n    int prev = INT_MIN;\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head) return head;\n        // 有点像并查集里的路径压缩\n        head->next = deleteDuplicates(head->next);\n        if(head->next && head->val == head->next->val){\n            prev = head->val;\n            return head->next->next;\n        }\n        if(head->val == prev)\n            return head->next;\n        return head;\n    }\n};\n```\n## 迭代\n```c++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        ListNode* dummy = new ListNode(INT_MAX, head);\n        ListNode* ptr = dummy;\n        while(ptr){\n            ListNode* cur = ptr->next;\n            while(cur && cur->next && cur->val == cur->next->val){\n                cur = cur->next;\n            }\n            if(cur == ptr->next) // 下一步没重复，放心走\n                ptr = ptr->next;\n            else // 有重复 cur必不为nullptr，否则就是没重复那步\n                ptr->next = cur->next;\n        }\n        return dummy->next;\n    }\n};\n```","tags":["算法","递归","链表","双指针"]},{"title":"LC-1143-718 最长子序列子数组问题","url":"/2022/03/20/LC-1143-718-最长子序列子数组问题/","content":"# 1143 [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)\n- **子序列是可以不连续的**\n- **dp[i][j]的含义是text1[:i]和text2[:j]最长公共子序列，这个最长公共子序列不一定包含text1[i]和text2[j]**\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size(), n = text2.size();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0)); // 多一行一列\n        for(int i=1; i<=m; ++i){\n            for(int j=1; j<=n; ++j){\n                if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; // 别忘了坐标偏移\n                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n# 718 [最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)\n- **子数组是连续的**\n- **dp[i][j]的含义是以nums1[i]结尾的nums1[:i]和以nums2[j]结尾的nums2[:j]的最长重复子数组**\n```c++\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        int m = nums1.size(), n = nums2.size();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n        int ret = 0;\n        for(int i=1; i<=m; ++i){\n            for(int j=1; j<=n; ++j){\n                if(nums1[i-1] == nums2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                    ret = max(ret, dp[i][j]);\n                }\n            }\n        }\n        return ret;\n    }\n};\n```\n## 错误1\n如果里面写成这样：\n```c++\nif(nums1[i-1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\nelse dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n...\nreturn dp[m][n];\n```\n则是处理非连续的“数组子序列”，对于`[0,1,1,1,1]和[1,0,1,0,1]`给出的答案是3，但是正确答案应该是2\n```c++\n// 错误DP图\nX | X   1   0   1   0   1\n——————————————————————————\nX | 0   0   0   0   0   0\n0 | 0   0   1   *1  1   *1\n1 | 0   1   *1  2   *2  2\n1 | 0   1   *1  *2  *2  *3\n1 | 0   1   *1  *2  *2  *3\n1 | 0   1   *1  *2  *2  *3\n```\n```c++\n// 正确DP图\nX | X   1   0   1   0   1\n——————————————————————————\nX | 0   0   0   0   0   0\n0 | 0   0   1   0   1   0\n1 | 0   1   0   2   0   2\n1 | 0   1   0   1   0   1\n1 | 0   1   0   1   0   1\n1 | 0   1   0   1   0   1\n```\n\n## 错误2\n如果里面写成这样：\n```c++\ndp[i][j] == max(max(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]+1);\nret = max(ret, dp[i][j]);\n...\nreturn ret;\n```\n则属于**彻底混淆**了自己对于dp数组的定义，一定要是**以nums1[i]结尾**的子数组和**以nums1[j]结尾**的子数组的最长子数组，对于`[1,0,0,0,1]和[1,0,0,1,1]`给出的答案是4，但是正确答案应该是3\n```c++\n// 错误DP图\nX | X   1   0   0   0   1\n——————————————————————————\nX | 0   0   0   0   0   0\n1 | 0   1   0   0   0   1\n0 | 0   0   2   *2  *2  0\n0 | 0   0   *2  3   *3  0\n1 | 0   1   0   0   0   *4\n1 | 0   1   0   0   0   *4\n```\n```c++\n// 正确DP图\nX | X   1   0   0   0   1\n——————————————————————————\nX | 0   0   0   0   0   0\n1 | 0   1   0   0   0   1\n0 | 0   0   2   1   1   0\n0 | 0   0   1   3   2   0\n1 | 0   1   0   0   0   3\n1 | 0   1   0   0   0   1\n```","tags":["算法","动态规划"]},{"title":"LC-78-90-39-40-46-47 子集组合排列","url":"/2022/03/20/LC-78-90-39-40-46-47-子集组合排列/","content":"# 零. 子集、组合和排列问题汇总\n- 组合问题和子集问题是等价的\n- 参考[labuladong](https://labuladong.gitee.io/algo/4/30/110/)和优秀题解\n\n# 一. 子集问题\n## 78 [子集划分](https://leetcode-cn.com/problems/subsets/)\n### 1.1 子集扩张\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        if(nums.empty())\n            return vector<vector<int>>(1, vector<int>());\n        int last = nums.back(); nums.pop_back();\n        vector<vector<int>> sub = subsets(nums);\n        int sz = sub.size();\n        for(int i=0; i<sz; ++i){\n            vector<int> tmp = sub[i];\n            tmp.push_back(last);\n            sub.push_back(tmp);\n        }\n        return sub;\n    }\n};\n```\n### 1.2 回溯1\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> tmp;\n    void traceback(vector<int>& nums, int pos){\n        if(pos == nums.size()){\n            ret.push_back(tmp);\n            return;\n        }\n        // 选\n        tmp.push_back(nums[pos]);\n        traceback(nums, pos+1);\n        tmp.pop_back();\n        \n        // 不选\n        traceback(nums, pos+1);\n    }\n    \n    vector<vector<int>> subsets(vector<int>& nums) {\n        traceback(nums, 0);\n        return ret;\n    }\n};\n```\n\n### 1.3 回溯2(★)\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> tmp;\n    void traceback(vector<int>& nums, int pos){\n        ret.push_back(tmp);\n        for(int i=pos; i<nums.size(); ++i){\n            tmp.push_back(nums[i]);\n            traceback(nums, i+1);\n            tmp.pop_back();\n        }\n    }\n    \n    vector<vector<int>> subsets(vector<int>& nums) {\n        traceback(nums, 0);\n        return ret;\n    }\n};\n```\n\n## 90 [子集划分Ⅱ](https://leetcode-cn.com/problems/subsets-ii/)\n1. 两条值相同的相邻树枝会产生重复，如果**一个节点**有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历\n2. **“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。** 我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。（注意：这里的同一树层指的是由同一个父节点引出的子节点，叔伯的子节点可以用相同下一个值，比如下图[1]接2和[2]接2，都可以用2；但是[1]接2就不能接2'了！）\n\n![labuladong图示 LC-90](https://labuladong.gitee.io/algo/images/排列组合/9.jpeg)\n### 2.1 回溯1\n```c++\nclass Solution {\npublic:\n    vector<int> t;\n    vector<vector<int>> ans;\n\n    void traceback(bool choosePre, int cur, vector<int> &nums) {\n        if (cur == nums.size()) {\n            ans.push_back(t);\n            return;\n        }\n        // 不选\n        traceback(false, cur + 1, nums);\n        \n        // 要在 [选] 之前执行，要在 [不选] 之后执行\n        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) return;\n        \n        // 选\n        t.push_back(nums[cur]);\n        traceback(true, cur + 1, nums);\n        t.pop_back();\n    }\n\n    vector<vector<int>> subsetsWithDup(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        traceback(false, 0, nums);\n        return ans;\n    }\n};\n```\n### 2.2 回溯2(★)\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, int pos){\n        ret.push_back(cur);\n        for(int i=pos; i<nums.size(); ++i){\n            // i从pos开始，天然可以判定同一父节点的子节点们不会重复\n            // 即只让重复段的第一个节点的树向下生长\n            // 如果i从0开始，无法确定pos-1位置是否使用过，需要\n            // 借助一个used数组\n            if(i > pos && nums[i] == nums[i-1]) continue;\n            cur.push_back(nums[i]);\n            backtrack(nums, i+1);\n            cur.pop_back();\n        }\n    }\n    \n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); // 要排序\n        backtrack(nums, 0);\n        return ret;\n    }\n};\n```\n### 2.3 回溯2（易读版利用used判断树层重复）\n也可用used数组来简化理解，$nums[i]$与$nums[i-1]$相等，且$nums[i-1]$没有使用的情况下，表明重复了，因为只有在$nums[i-1]$用过之后才会不用，而$nums[i-1]$之前用过，其后的子树是已经加入到结果了，即可跳过当前点\n```c++\nclass Solution {\nprivate:\n    vector<vector<int>> ret;\n    vector<int> path;\n    void backtracking(vector<int>& nums, int pos, vector<bool>& used) {\n        ret.push_back(path);\n        for (int i = pos; i < nums.size(); i++) {\n            // used[i-1] == true，说明同一树支nums[i-1]使用过\n            // used[i-1] == false，说明同一树层nums[i-1]使用过\n            // 而我们要对同一树层使用过的元素进行跳过\n            if (i > 0 && nums[i] == nums[i - 1] && !used[i-1])\n                continue;\n            used[i] = true;\n            path.push_back(nums[i]);\n            backtracking(nums, i + 1, used);\n            path.pop_back();\n            used[i] = false;\n        }\n    }\n\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<bool> used(nums.size(), false);\n        sort(nums.begin(), nums.end()); // 去重需要排序\n        backtracking(nums, 0, used);\n        return ret;\n    }\n};\n\n```\n\n# 二. 组合问题\n## 39 [组合总数](https://leetcode-cn.com/problems/combination-sum/)\n### 1.1 回溯\nnums中的每个数字可以多次使用\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, int pos, int target){\n        if(target < 0) return;\n        if(target == 0){\n            ret.push_back(cur);\n            return;\n        }\n        for(int i=pos; i<nums.size(); ++i){\n            cur.push_back(nums[i]);\n            backtrack(nums, i, target-nums[i]); // 依旧传入i\n            cur.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\n        backtrack(nums, 0, target);\n        return ret;\n    }\n};\n```\n\n## 2. 40 [组合总数Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii/)\nnums中的每个数字在每个组合中只能使用一次 && 解集不能包含重复的组合。\n\n说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 candidates 中所有和为 target 的子集。\n### 2.1 回溯1\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, int pos, int target, bool preUsed){\n        if(target < 0) return;\n        if(target == 0){\n            ret.push_back(cur);\n            return;\n        }\n        if(pos >= nums.size()) return; // 不能放前面\n        if(nums[pos] > target) return; // 剪枝：当前和后面的不可能会选\n        \n        // 不选\n        backtrack(nums, pos+1, target, false);\n        \n        if(pos>0 && nums[pos-1] == nums[pos] && !preUsed) return;\n        \n        // 选\n        cur.push_back(nums[pos]);\n        backtrack(nums, pos+1, target - nums[pos], true);\n        cur.pop_back();\n    }\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        backtrack(nums, 0, target, false);\n        return ret;\n    }\n};\n```\n\n### 2.2 回溯2(★)\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, int pos, int target){\n        if(target == 0){\n            ret.push_back(cur);\n            return;\n        }\n        for(int i=pos; i<nums.size(); ++i){\n            if(i>pos && nums[i-1] == nums[i]) continue; // 值相同的树枝，只遍历第一条，防止重复\n            if(target < nums[i]) return; // 剪枝：当前和后面的不可能会选\n            cur.push_back(nums[i]);\n            backtrack(nums, i+1, target-nums[i]);\n            cur.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        backtrack(nums, 0, target);\n        return ret;\n    }\n};\n```\n\n\n# 三. 排列问题\n## 1. 46 [全排列](https://leetcode-cn.com/problems/permutations/)\n不含重复数字的数组：nums，经典回溯\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, vector<bool>& used){\n        if(cur.size() == nums.size()){\n            ret.push_back(cur);\n            return;\n        }\n        for(int i=0; i<nums.size(); ++i){\n            if(used[i]) continue;\n            used[i] = true;\n            cur.push_back(nums[i]);\n            backtrack(nums, used);\n            cur.pop_back();\n            used[i] = false;\n        }\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<bool> used(nums.size(), false);\n        backtrack(nums, used);\n        return ret;\n    }\n};\n```\n\n## 2. 47 [全排列Ⅱ](https://leetcode-cn.com/problems/permutations-ii/)\n含有重复数字的数组：nums\n### 2.1 哈希（有意思）\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> res;\n    \n    void traceback(map<int, int>& hash, vector<int>& cur, int n){\n        if(cur.size() == n){\n            res.push_back(cur);\n            return;\n        }\n        for(map<int, int>::iterator itr=hash.begin(); itr!=hash.end(); ++itr){\n            if(itr->second){\n                --itr->second;\n                cur.push_back(itr->first);\n                traceback(hash, cur, n);\n                cur.pop_back();\n                ++itr->second;\n            }\n        }\n    }\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        map<int, int> hash;\n        vector<int> cur;\n        for(auto e: nums) ++hash[e];\n        traceback(hash, cur, nums.size());\n        return res;\n    }\n};\n```\n\n### 2.2 回溯(跟子集问题2.3很像)\n当出现重复元素时，比如输入 nums = [1,2,2',2'']，2' 只有在 2 已经被使用的情况下才会被选择，2'' 只有在 2' 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> ret;\n    vector<int> cur;\n    void backtrack(vector<int>& nums, vector<bool>& used){\n        if(cur.size() == nums.size()){\n            ret.push_back(cur);\n            return;\n        }\n        for(int i=0; i<nums.size(); ++i){\n            // i从0开始，固定相同的元素在排列中的相对位置\n            if(i>0 && nums[i]==nums[i-1] && !used[i-1]) continue;\n            if(used[i]) continue;\n            used[i] = true;\n            cur.push_back(nums[i]);\n            backtrack(nums, used);\n            cur.pop_back();\n            used[i] = false;\n        }\n    }\n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); // 必须排序\n        vector<bool> used(nums.size(), false);\n        backtrack(nums, used);\n        return ret;\n    }\n};\n```","tags":["算法","递归","回溯","哈希"]},{"title":"LC-43 字符串相乘","url":"/2022/03/19/LC-43-字符串相乘/","content":"# 43 [字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)\n*两数A位和B位，相加后位数最大为 $max(A, B)+1$；相乘后最大位数为$A+B$*\n### 1.1 常规法\n将两个串的指针位置 $m$ 和 $n$ 、进位 $c$ 统一放入while循环，代码就会很**优美**。 代码可以继续优化速度存储：addtion函数改为原地相加，但是会破坏代码的逻辑性，就不改了。\n```c++\nclass Solution {\npublic:\n    string addtion(string& num1, string& num2){\n        int m = num1.size()-1, n = num2.size()-1;\n        int c = 0;\n        string ret;\n        while(m>=0 || n>=0 || c){\n            int a = m>=0 ? num1[m]-'0' : 0; // 越界定0技巧\n            int b = n>=0 ? num2[n]-'0' : 0; // 越界定0技巧\n            int s = a + b + c;\n            ret.push_back('0' + s % 10);\n            c = s / 10;\n            --m, --n;\n        }\n        reverse(ret.begin(), ret.end()); // 反转\n        return ret;\n    }\n    \n    string multiply(string num1, string num2) {\n        if(num1==\"0\" || num2==\"0\") return \"0\";\n        string res = \"0\";\n        int cnt = 0; // 记录表示每次乘完左移的0的个数\n        int m = num2.size()-1;\n        while(m >= 0){\n            int n = num1.size()-1;\n            int b = num2[m] - '0';\n            int c = 0;\n            string ret(cnt, '0'); // 初始化\"左移\"0\n            while(n>=0 || c){\n                int a = n>=0 ? num1[n]-'0' : 0; // 越界定0技巧\n                int s = a * b + c;\n                ret.push_back('0' + s % 10);\n                c = s / 10;\n                --n;\n            }\n            reverse(ret.begin(), ret.end()); // 反转\n            res = addtion(res, ret);\n            --m, ++cnt;\n        }\n        return res;\n    }\n};\n```\n\n### 1.2 优化竖式 (LC高赞)(很难想到啊)\n![说明图](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/algorithm/LC-43-字符串相乘-1.png)\nnum1[i] x num2[j] 的结果为 tmp(位数为两位，\"0x\",\"xy\"的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。\n```c++\nclass Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if(num1 == \"0\" || num2 == \"0\") return \"0\";\n        int m = num1.size(), n = num2.size();\n        vector<int> temp(m+n, 0); // 数组哦\n        for(int i=m-1; i>=0; --i){\n            for(int j=n-1; j>=0; --j){\n                int cur = (num1[i]-'0') * (num2[j]-'0') + temp[i+j+1];\n                temp[i+j+1] = cur % 10; // 存储计算结果低位 =\n                temp[i+j] += cur / 10; // 存储计算结果高位 +=\n            }\n        }\n        string ret; ret.reserve(m+n);\n        int i = 0;\n        for(; i<temp.size(); ++i) // 去掉前缀0\n            if(temp[i] != 0) break;\n        for(; i<temp.size(); ++i) // 放入字符串\n            ret.push_back(char(temp[i] + '0'));\n        return ret;\n    }\n};\n```","tags":["算法","字符串"]},{"title":"LC-124-543 二叉树最大和","url":"/2022/03/19/LC-124-543-二叉树最大和/","content":"\n# 1. 124 [二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)\n### 1.1 两个递归的笨方法\n```c++\nclass Solution {\npublic:\n    int ans = INT_MIN;\n    int core(TreeNode* root) { // 找到以root为起点，深入向下的最大路径一条线（分叉只走一条）\n        if(!root) return 0;\n        int lv = core(root->left);\n        int rv = core(root->right);\n        int res = max(max(lv, rv), 0) + root->val;\n        return res;\n    }\n    \n    void recursion(TreeNode* root){ // 遍历树中每个结点，尝试寻找本题答案的“起点根”\n        if(!root) return;\n        recursion(root->left);\n        recursion(root->right);\n        int lv = core(root->left); // 以左孩子为起点的“线”\n        int rv = core(root->right); // 以右孩子为起点的“线”\n        if(lv < 0) lv = 0;\n        if(rv < 0) rv = 0;\n        ans = max(ans, lv + rv + root->val);\n    }\n    \n    int maxPathSum(TreeNode* root) {\n        recursion(root);\n        return ans;\n    }\n};\n```\n\n### 1.2 一个递归的好方法\n```c++\nclass Solution {\npublic:\n    int ans = INT_MIN;\n    int core(TreeNode* root) {\n        if(!root) return 0;\n        \n        // 递归计算左右子节点的最大贡献值\n        // 只有在最大贡献值大于 0 时，才会选取对应子节点\n        int lv = max(core(root->left), 0);\n        int rv = max(core(root->right), 0);\n        \n        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值\n        int ifAnsRoot = root->val + lv + rv;\n        ans = max(ans, ifAnsRoot);\n        \n        // 返回\n        return max(lv, rv) + root->val;\n    }\n    \n    int maxPathSum(TreeNode* root) {\n        core(root);\n        return ans;\n    }\n};\n```\n\n# 2. 543 [二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)\n## **这些问题都有共性：递归主线依旧，所求是副产物**\n### 2.1 两个递归的笨方法\n```c++\nclass Solution {\npublic:\n    int core(TreeNode* root){\n        if(!root) return 0;\n        int l = core(root->left);\n        int r = core(root->right);\n        return max(l, r) + 1;\n    }\n    \n    int diameterOfBinaryTree(TreeNode* root) {\n        if(!root) return 0;\n        int l = diameterOfBinaryTree(root->left);\n        int r = diameterOfBinaryTree(root->right);\n        int m = core(root->left) + core(root->right);\n        return max(m, max(l, r));\n    }\n};\n```\n### 2.2 一个递归的好方法\n```c++\n// 递归主线还是算高度，直径是 [副产品]\nclass Solution {\npublic:\n    int res = 0;\n    int core(TreeNode* root){ // 给定根节点，计算最长深度节点数\n        if(!root) return 0;\n        int l = core(root->left); // 左儿子为根的子树的深度\n        int r = core(root->right); // 右儿子为根的子树的深度\n        res = max(res, l + r); // 在这里更新res，不用+1，因为路径长度是总结点长度-1\n        return max(l, r) + 1; // 返回该节点为根的子树的最长深度节点数\n    }\n    \n    int diameterOfBinaryTree(TreeNode* root) {\n        if(!root) return 0;\n        core(root);\n        return res;\n    }\n};\n```","tags":["算法","递归","树"]},{"title":"LC-470 Rand7实现Rand10","url":"/2022/03/19/LC-470-Rand7实现Rand10/","content":"# 470 [用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)\n## 1. 拒绝采样\n在解LC-470前先介绍一道拒绝采样的经典问题：利用频率近似概率的方式求出Pi的值。在$1\\times1$的方块内随机坐标采样，记录落入以原点为圆心，半径为1的$\\frac{1}{4}$圆内的次数。\n\n由$\\frac{1}{4}\\pi r^2 = \\frac{cnt}{N}$ 可得 $\\pi = \\frac{4\\times cnt}{N\\times r^2}$ ，由于$r=1$，所以$\\pi = \\frac{4\\times cnt}{N}$\n```c++\nint main() {\n    srand((unsigned)time(0)); // time(0)表示从1970到现在的秒数\n    int N = (int)1e7, cnt = 0;\n    for (int i = 0; i < N; i++) {\n        double a = (1.0 * rand() / RAND_MAX); // 除以RAND_MAX归一化0~1\n        double b = (1.0 * rand() / RAND_MAX);\n        if (a * a + b * b < 1.0) cnt++; // 落入1/4圆则加一\n    }\n    printf(\"%lf\", (4.0 * cnt) / N);\n    return 0;\n}\n```\n\n## 2. LC-470 Rand7生成Rand10\n[力扣高赞题解](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/)\n\n**(rand_X() - 1) × Y + rand_Y() ==> 可以等概率的生成[1, X * Y]范围的随机数**\n```c++\nclass Solution {\npublic:\n    int rand10() {\n        while(true){\n            // 等概率生成[1,49]范围的随机数\n            int num = (rand7()-1)*7 + rand7();\n            // 拒绝采样，并返回[1,10]范围的随机数\n            if(num <= 40) return num % 10 + 1;\n        }\n    }\n};\n```","tags":["算法"]},{"title":"LC-32 最长有效括号","url":"/2022/03/19/LC-32-最长有效括号/","content":"# 32 [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)\n## 方法1：动态规划\n### 1.1 错误1\n**无法解决诸如`(())`的问题。** 要考虑到当前碰到右括号后，前面的是左括号还是右括号，然后分别进行处理\n\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        int l = 0;\n        vector<int> dp(n);\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(s[i] == '('){\n                ++l; \n                continue;\n            }\n            if(l){\n                --l;\n                dp[i] = 2;\n                if(i-2 >= 0) dp[i] += dp[i-2]; // BUG\n                ret = max(ret, dp[i]);\n            }\n        }\n        return ret;\n    }\n};\n```\n### 1.2 错误2\n**无法解决诸如`()(())`的问题。** \n1. `*****()` 好解决直接 `dp[i] += dp[i-2];`\n2. `*****))` 需要额外判断找到与当前右括号 $i$ 对应的左括号 $t$，然后 $t$ 的左边要继续判断\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        int l = 0;\n        vector<int> dp(n);\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(s[i] == '('){\n                ++l; \n                continue;\n            }\n            if(l){\n                --l;\n                dp[i] = 2;\n                if(s[i-1] == '(' && i-2 >= 0) dp[i] += dp[i-2];\n                else if(s[i-1] == ')') dp[i] += dp[i-1]; // 这里要继续修改\n                ret = max(ret, dp[i]);\n            }\n        }\n        return ret;\n    }\n};\n```\n### 1.3 正确答案\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        int l = 0;\n        vector<int> dp(n);\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            if(s[i] == '('){\n                ++l; \n                continue;\n            }\n            if(l){\n                --l;\n                dp[i] = 2;\n                if(s[i-1] == '(' && i-2 >= 0) dp[i] += dp[i-2];\n                else if(s[i-1] == ')'){\n                    dp[i] += dp[i-1];\n                    if(i-dp[i]>=0) //添加这里\n                        dp[i] += dp[i-dp[i]];\n                }\n                ret = max(ret, dp[i]);\n            }\n        }\n        return ret;\n    }\n};\n```\n### 1.4 官方的DP（LC官方）(Elegant)\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        vector<int> dp(n, 0);\n        int res = 0;\n        for(int i=1; i<n; ++i){\n            if(s[i] == '(') continue;\n            // 只有以')'结尾的才有效\n            if(s[i-1] == '('){\n                if(i-2 < 0) dp[i] = 2; // 防止越界\n                else dp[i] = dp[i-2] + 2; // 转移函数\n            }else{\n                if(i-dp[i-1]-1>=0 && s[i-dp[i-1]-1] == '('){\n                    dp[i] = dp[i-1] + 2; // 转移函数\n                    if(i-dp[i-1]-2 >= 0)\n                        dp[i] += dp[i-dp[i-1]-2];\n                }\n            }\n            res = max(res, dp[i]);\n        }\n        return res;\n    }\n};\n```\n\n## 方法2：栈（LC官方）\n保持栈底元素为当前已经遍历过的元素中 **「最后一个没有被匹配的右括号的下标」** 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int n = s.size();\n        stack<int> stk;\n        stk.push(-1);\n        int res = 0;\n        for(int i=0; i<n; ++i){\n            if(s[i] == '(') stk.push(i);\n            else{\n                stk.pop();\n                if(stk.empty()) // 更新「最后一个没有被匹配的右括号的下标」\n                    stk.push(i);\n                else\n                    res = max(res, i-stk.top()); // 以i结尾的有效性括号长度\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 方法3：贪心（LC官方）\n利用两个计数器 $l和r$ ，从左到右遍历字符串，遇到左括号则 $l加1$ ，遇到右括号则 $r加1$ ；当 $l和r$ 相等时更新最长长度，当 $r>l时将l和r置0$\n\n这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。\n\n解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：当 $r<l 时将 l 和 r 置0$ 。\n\n这样我们就能涵盖所有情况从而求解出答案。\n```c++\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int l = 0, r = 0;\n        int res = 0;\n        for(int i=0; i<s.size(); ++i){\n            if(s[i] == '(') ++l;\n            else ++r;\n            if(l == r) res = max(res, l + r);\n            else if(r > l) l = r = 0;\n        }\n        l = r = 0; // 重置！\n        for(int i=s.size()-1; i>=0; --i){\n            if(s[i] == '(') ++l;\n            else ++r;\n            if(l == r) res = max(res, l + r);\n            else if(l > r) l = r = 0;\n        }\n        return res;\n    }\n};\n```","tags":["算法","动态规划","贪心","栈"]},{"title":"目标检测SSD","url":"/2021/11/23/目标检测SSD/","content":"\n> **目标检测SSD**\n\n### 1. 锚框的长和宽\n\n#### 1.1 书上代码解析\ns指的是长宽的缩放比例而非面积的缩放比例，比如s=0.5，则面积就是原图像的0.5^2=0.25倍。r是宽高比，指的是将原图像归一化为正方形后截取的锚框的宽高比；或者说是在原图像的宽高比基础上乘以r，才是锚框的宽高比。锚框的实际宽高比即$frac{w}{h}*r$。之所以r=1时你看到的是方形，之后会解释。\n由此，可得以下方程组\n$$\\begin{cases}\nw_0*h_0=s^2*w*h\\\\\n\\frac{w_0}{h_0}=\\frac{w}{h} * r\n\\end{cases}$$\n解得\n$$\n\\begin{cases}\nw_0=s*w*\\sqrt{r}\\\\\nh_0=s*h/\\sqrt{r}\n\\end{cases}\n$$\n$w_0和h_0$分别处以w和h进行归一化，可得\n$$\n\\begin{cases}\nw_0=s*\\sqrt{r} \\\\\nh_0=s/\\sqrt{r}\n\\end{cases}\n$$\n而在代码中我们可以看到：\n\n```\nw0 = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),\n                   sizes[0] * torch.sqrt(ratio_tensor[1:])))\\\n                   * in_height / in_width\nh0 = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),\n                   sizes[0] / torch.sqrt(ratio_tensor[1:])))\n```\n\n先不看`in_height / in_width`。上面解得的归一化后的公式与代码所写的一模一样。代码中的$w_0$和$h_0$就是锚框归一化后的宽高（此时消除了原图像w和h的影响，可以认为，r所代表的宽高比就是此时锚框的宽高比，r=1时，是一个正方形锚框，也即此时$w_0$和$h_0$的值是一样的）。但是呢，由于我们显示的时候需要乘以图像的实际宽高所以，乘后的锚框实际宽高比就不是1了，所以才要乘以`in_height / in_width`，作用就是抵消乘以实际图像长宽后r会改变的问题，当然这样做存粹是为了显示方便（也让你误以为r是指锚框的宽高比），带来的副作用就是，锚框的实际面积就不再是原始图像的$s^2$。`(￣ε(#￣)。`\n\n由于实际在我们进行目标检测时，特征图长和宽都是相同的，比如(19, 19)、(7, 7)，所以`in_height / in_width`恒等于1，因此对于实际的使用并不会带来副作用。但此时，如果要将锚框显示出来，归一化后的锚框再乘以图像实际长宽后，所显示的锚框的长宽比会改变。如下图所示，特征图宽高是(1, 1)，当r=1，s=0.5时，最终锚框的宽高比并不是r=1，而是$\\frac{w}{h}*r$。即上述代码中`in_height / in_width`这部分失效了。好消息是，面积是原图的$s^2$，又符合定义了。`\\(￣︶￣\\))`\n\n![](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/目标检测SSD-图1.png)\n\n#### 1.2 尝试的改动\n\n所以如果r宽高比的定义按照**原图像的宽高比*r**来定义，那么沐神的代码和书上的公式在**实际使用**时都是没问题的。只是将这个函数作用于特征图**宽高不相同**的实例时（比如为了给观众显示方便，直接作用上面这幅图像），会产生一丢丢歧义：此时的r的定义居然又变回了**锚框的宽高比**。\n\n我们可以尝试来重新定义宽高比r（s定义不变），直接**认定它代表锚框的宽高比**，会有如下公式：\n$$\n\\begin{cases}\n\\frac{w_0}{h_0}=r\\\\\nw_0*h_0 = s^2*w*h\n\\end{cases}\n$$\n解得\n$$\n\\begin{cases}\nw_0=s*\\sqrt{w*h*r}\\\\\nh_0=s*\\sqrt{\\frac{w*h}{r}}\n\\end{cases}\n$$\n$w_0和h_0$分别处以w和h进行归一化，可得\n$$\n\\begin{cases}\nw_0=s*\\sqrt{\\frac{h*r}{w}}\\\\\nh_0=s*\\sqrt{\\frac{w}{r*h}}\n\\end{cases}\\\\\n$$\n这样定义的话，就要求`multibox_prior()`函数要传入原图像的长度和宽度。\n下面实验验证，不论特征图的长宽怎么变，r和s的定义都是一致的。\n\n\n![](https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/object%20detection/目标检测SSD-图2.png)\n\n\n### 2. 锚框偏移\n\n假设$\\hat{g}_j$是某个标签目标，$d_i$是某个anchor，边框回归与Faster-RCNN类似\n回归的偏移相对的是$d_i$的中点和宽高(cx, cy, w, h)\n$$\n\\begin{cases}\n\\hat{g}^{cx}_j = (g^{cx}_j - d^{cx}_i)/d^w_i\\\\\n\\hat{g}^{cy}_j = (g^{cy}_j - d^{cy}_i)/d^h_i\\\\\n\\hat{g}^{cw}_j = log(g^{cw}_j / d^{cw}_i)\\\\\n\\hat{g}^{ch}_j = log(g^{ch}_j / d^{ch}_i)\\\\\n\\end{cases}\\\\\n$$\n解释：\n\n- 激活的锚框（即给分配了某gt的正样本），其与某gt的IOU肯定不低，则其x、y、w、h也肯定差不大，这是前提\n- x、y：做差后分布于零点对称，除以锚框宽或高起到归一化作用，值分布变窄\n- w、h：做除法后用log，可近似线性，且使得结果的分布呈现零点对称，使得网络回归更简单","tags":["目标检测"]},{"title":"C++ priority_queue自定义排序","url":"/2021/10/31/C-priority-queue自定义排序/","content":"\n> **C++ priority_queue自定义排序总结**\n\n### 方法一：函数指针\n\n以下几种都可以，具体可参考《C++ Primer》\n\n```\ntypedef int elem;\nbool cmp(elem a, elem b) {\n    return a < b;\n}\npriority_queue<elem, vector<elem>, decltype(&cmp)> q(arr.begin(), arr.end(), cmp);\npriority_queue<elem, vector<elem>, decltype(cmp)*> q(arr.begin(), arr.end(), cmp);\npriority_queue<elem, vector<elem>, bool(*)(elem, elem)> q(arr.begin(), arr.end(), cmp);\n// 构造函数前两个可以不填，但是必须传入cmp\n// 前面模板只是告诉它是一个函数指针bool(*)(elem, elem)，但并没有传入函数地址（实体）\npriority_queue<elem, vector<elem>, bool(*)(elem, elem)> q(cmp);\n```\n**对于cmp和&cmp你应该这样理解，cmp是函数的首地址，它的类型是bool(elem,  elem)，&cmp表示一个指向函数cmp这个对象的地址，它的类型是bool(*)(elem, elem)，因此test和&test所代表的地址的值是一样的，但类型不一样！**\n\n### 方法二：重载运算符\n\n```\nstruct elem {\n    int a;\n    int b;\n    bool operator<(const elem& another) const {\n        return this->b < another.b;\n    }\n};\npriority_queue<elem, vector<elem>, less<elem>> q;\n```\n注意：operator函数要有const，这是能构成重载的，否则未找到对应函数报错\n\n### 方法三：仿函数\n\n```\nstruct elem {\n    int a;\n    int b;\n};\nstruct cmp {\n    bool operator()(const elem& left, const elem& right) {\n        return left.b < right.b;\n    }\n};\npriority_queue<elem, vector<elem>, cmp> q;\n```\n\n","tags":["C/C++"]},{"title":"读者写者问题","url":"/2021/08/27/读者写者问题/","content":"\n> **经典读者写者问题**\n\n### 读者写者问题\n\n##### 1、读者优先\n\n```c++\nint readcount=0; \nsemaphore RCSignal=1, fileSrc=1;\n// RCSignal readcount修改互斥量\n// fileSrc 文件资源互斥量：实现读者优先\n\n// 读者进程：\n\tP(RCSignal);\n\treadcount++;\t\n\tif (readcount == 1)\n\t\tP(fileSrc);\n\tV(RCSignal);\n\t// ...\n\t// reading is performed\n\t// ...\n\tP(RCSignal);\n\treadcount--;\n\tif (readcount == 0)\n\t\tV(fileSrc);\n\tV(RCSignal);\n \n// 写者进程：     \n\tP(fileSrc);\n\t//...\n    //writing is performed\n\t//...\n\tV(fileSrc);\n```\n\n##### 2、写者优先\n\n```c++\nint readcount=0, writecount=0; \nsemaphore RCSignal=1, WCSignal=1, read=1, fileSrc;\n// RCSignal readcount修改互斥量\n// WCSignal writecount修改互斥量\n// read 实现写者优先：拦截读者\n// fileSrc 文件资源互斥量：保护剩余读者（拦截写者），以及写者唯一\n\n// 读者进程：\nP(read);\n\tP(RCSignal);\n\t\treadcount++;\n\t\tif(readcount == 1 ) \n    \t\tP(fileSrc);\n\tV(RCSignal);\nV(read);\n\t// ...\n    // reading is performed\n\t// ...\nP(RCSignal);\n    readcount--;\n    if (readcount == 0 )\n\t\tV(fileSrc);\nV(RCSignal);\n\n// 写者进程：     \nP(WCSingal);\n    writecount++;\n    if (writecount == 1 )\n\t\tP(read);\nV(WCSingal);\nP(fileSrc);\n    // writing is performed\nV(fileSrc);\nP(WCSingal);\n    writecount --;\n    if (writecount == 0)\n    \tV(read);\nV(WCSingal); \n```\n\n\n##### 参考资料\n\nhttps://www.bilibili.com/video/av21593625\nhttps://blog.csdn.net/c1194758555/article/details/52805918\nhttps://blog.csdn.net/william_munch/article/details/84256690      （有问题？）\n","tags":["操作系统"]},{"title":"Essential C++ note","url":"/2021/08/05/essential-C-note/","content":">**记录本书（对我来说）的一些重点内容**\n\n### 1 C++编程基础\n1. 初始化方法：构造函数法（constructor syntax）\n\n```c++\n    int var(66);\n    int var2{66}; // ok\n```\n\n2. srand()随机数种子；rand()则产生一个介于0和int所能表示的最大整数；需包含头文件cstdlib\n3. cerr（standard error）代表标准错误设备，与cout唯一区别就是不带缓冲，立即显示于用户终端\n\n### 2 面向过程的编程风格\n1. 使用模板，则声明与定义要放在一起\n2. 函数指针\n\n```c++\n    // 给函数指针赋初值\n    const vector<int>* (*seq_str)(int) = 0;\n    // seq_array是个数组，内放函数指针\n    const vector<int>* (*seq_array[])(int) = {\n        fibon_seq, lucas_seq, pell_seq,\n        triang_seq, square_seq, pent_seq\n    }\n```\n\n3. inline函数的声明和定义都需要放在头文件，声明和定义有一个标明inline即可（在类定义中实现则默认是inline）；其他的函数，则必须是**“定义放在程序代码文件”、“声明放在头文件”**\n4. 多文件共享变量\n\n```c++\n/*\n    变量只能定义一次，但是可以声明多次\n    假定main.cpp func.cpp func.h三个文件\n    1. 在func.cpp有一个int a=1;如果要在main.cpp中使用，要在func.h或main.cpp中写extern int a；\n    2. const object和inline函数一样，是“一次定义”规则下的例外。const object定义只要一出文件外就\n       不可见（意味着可以在多个程序代码中加以定义）。因此如果const int a=1想多文件共享，可以直接写\n       在func.h中，其他的非const object则不可。\n       可参考：https://www.icode9.com/content-1-915590.html\n*/\n```\n\n### 3 泛型编程风格\n1. list不支持iterator的偏移运算（+、-）但是有++和--\n2. 对于标准容器，不确保目标空间大小，可使用iterator inserter用插入操作替代赋值操作\n3. <这章挺多东西，需要结合书本去看>\n\n### 4 基于对象的编程风格\n1. 如果有必要为某个class编写[拷贝构造]，则同样有必要为它编写[赋值操作]\n2. 没有一个const reference class参数可以调用公开接口中的non-const成分\n3. 类中的变量声明为mutable，标明其不会破坏对象的**常量性**（constness），即可在const函数中可以修改它\n4. 当定义class的static function时，不可加上关键字static（同理静态成员变量）\n5. 当类中有静态成员变量时，需要及时在类外进行初始化，否则报错：无法解析的外部命令\n6. 通常情况：**operator*无参表示解引用；有参表示乘法**\n7. friend声明可以出现在类定义任意位置，不受public或private影响\n8. **嵌套类型**（Nested Type），类中可以定义嵌套类型，再用域解析符（例如每个STL容器类都有自己的iterator）\n9. 重载iostream（看书）\n10. 类的函数指针：\n\n```c++\n    void (num_sequence::*pm)(int) = 0;\n    // 如果决定上面一行复杂可以写成：\n    typedef void (num_sequence::*PtrType)(int);\n    PtrType pm = 0;\n    // 成员函数取址要加上class scope限定符和&取地址运算符（不同于一般函数，都不可以省！）\n    PtrType pm = &num_sequence::fibonaci;\n    // 调用，由此要引出pointer to member selection运算符“.*”和\"->*\"\n    (ns.*pm)(pos)\n    (pns->*pm)(pos)\n```\n\n### 5 面向对象编程风格\n1. 纯虚函数：将虚函数赋值为0\n\n```c++\n    virtual void gen_elems(int pos) = 0;\n```\n\n2. 任何类声明了纯虚函数，那么由于其接口不完整（无定义），程序无法为其产生实体。这种类只能作为派生类的子对象使用，而且前提是这些派生类为**所有**虚函数提供确切的定义。\n3. 一般规则：凡基类定义了虚函数，则destructor也要声明为virtual\n4. 一般而言，对象的拷贝构造函数开发者如果未提供，则编译器会自动生成默认的拷贝构造函数。然而以下情况默认的拷贝构造函数会被删除：\n\n```c++\n/*\n    1、存在非静态的const成员变量\n    2、存在非静态的引用成员变量\n    3、存在不能拷贝的成员变量\n    4、存在不能拷贝的基类\n    5、存在用户定义的移动构造函数或移动赋值函数\n*/\n```\n\n5. 在基类的constructor中，派生类的虚函数不允许被调用\n6. static_cast和dynamic_cast，前者无条件转换，后者判断（比如基类的指针是否真的指向了该派生类）是否可以转换为目的类型再进行转换\n\n### 6 以template进行编程\n1. 函数传入一个指针，只能改变指针所指对象的内容，要想改变指针本身（指向）就要传递reference to pointer\n\n```c++\n\tBTnode*& prev // 可以看成BTnode* &prev 或 ((BTnode*)&) prev\n```\n\n2. 模板类声明友元的问题：\n\n```c++\n\t// 下面代码直接运行会报错：无法解析的外部命令\n```\n\n```c++\n    template <typename T>\n    class A {\n    public:\n        A(T t):dy(t) {}\n        T dy;\n\n        friend ostream& operator<<(ostream& os, const A<T>& b);\n\n    private:\n        void func(ostream& os) const{\n            os << dy << endl;\n        }\n    };\n\n    template <typename T>\n    ostream& operator<<(ostream& os, const A<T>& b) {\n        b.func(os);\n        return os;\n    }\n\n    int main() {\n        A<double> a(4.2);\n        cout << a << endl;\n        return 0;\n    }\n```\n```c++\n/*\n    原因：\n    因为\"operator<<\"这个函数的参数T不应该依赖于class的模板参数，友元本来是可以访问类的所有数据成员的(该模板类的int、double、string对象)，你这样依赖的话，放到外部表名该参数T是属于类内部本身，解决方案是为了更好的支持友元，我们一般单独给友元一个模板参数\n    1、类中友元声明改为（意义不明不过能用，但是其下绿波浪线提示函数未定义）（不推荐）\n    friend ostream& operator<< <T>(ostream& os, const A<T>& b);\n    2、类中友元声明改为（S不同于T）（推荐）\n    template <typename S>\n    friend ostream& operator<<(ostream& os, const A<S>& b);\n*/\n```\n\n3. 非类型参数\n\n```c++\n/*\n    1、这类参数在模板内部都是常量值\n    2、只允许传入整形、指针和引用这三类\n    3、调用非类型参数的实参必须为常量表达式（必须在编译时能计算出结果的）\n*/\n```\n\n### 7 异常处理\n1. 重新抛出时，只需写下关键字throw即可。它只能出现于catch子句中\n2. 局部资源管理，在易发生异常后释放资源是一件风险很大的事情。虽然可以通过try catch处理，但是释放资源的代码要出现两次，不好。这就引出了resource acquisition is initialization(RAII)策略，即初始化阶段进行资源请求。说人话就是，在构造函数中请求所有资源，在析构函数中释放所有资源：C++保证，在异常处理机制终结某个函数之前，所有局部对象的destructor都会被调用。或者使用智能指针例如：unique_ptr、shared_ptr等。\n3. ptext = new vector<string>; 经过以下几个步骤（异常出现，余下不会执行，会沿着调用链抛出）\n\n```c++\n/*\n    // 可能会reorder哦~\n    1、分配足够的空间\n    2、将vector<string> default constructor应用于heap对象之上\n    3、将对象地址设置给ptext\n*/\n```\n\n\n\n\n\n","tags":["C/C++"]},{"title":"Hexo说明","url":"/2021/06/28/Hexo说明/","content":"\n> **Hexo相关说明**\n\n## 安装Hexo\n\n[安装hexo](https://blog.csdn.net/guixinchn/article/details/107787660)\n\n## Hexo基本语法\n\nhexo n 我的博客 == hexo new 我的博客 //新建文章\nhexo g == hexo generate //生成\nhexo s == hexo server //启动服务预览\nhexo d == hexo deploy //部署\n\nhexo server //Hexo会监视文件变动并自动更新，无须重启服务器\nhexo server -s //静态模式\nhexo server -p 5000 //更改端口\nhexo server -i 192.168.1.1 //自定义 IP\nhexo clean //清除缓存，若是网页正常情况下可以忽略这条命令\n\n### Hexo相关\n\n1. 自动展开设置1：[显示部分摘要](https://blog.csdn.net/yueyue200830/article/details/104470646)\n2. 自动展开设置2：[显示部分摘要](https://www.zhihu.com/question/394167076)\n3. hexo显示公式乱码问题：[公式乱码问题](https://www.cnblogs.com/zhyantao/p/10424874.html)\n4. [如何在另一台电脑使用hexo更新博客](https://www.cnblogs.com/study-everyday/p/8902136.html)\n\n### Github相关\n如果无法deploy到Github，此时打开命令行输入`ping github.com`又失败，则可能是梯子的原因，无法进行DNS，即使关掉梯子也不行。此时可以手动在电脑的hosts文件里添加到Github的域名到ip映射，具体操作如下：\n1. 在[IP查询网页](https://ipaddress.com/website/github.com)搜索github，找到github的网站地址\n2. 进入`C:\\Windows\\System32\\drivers\\etc`修改hosts\n3. 由于需要权限所以**以管理员模式**打开cmd，cd到hosts，然后输入`notepad hosts`即可进行修改添加，只需插入`IP www.github.com和IP github.com`保存即可\n\n### 主题相关\n1. [NEXT常用配置](http://home.ustc.edu.cn/~liujunyan/blog/hexo-next-theme-config/)\n2. [背景图片修改问题](https://blog.csdn.net/qq_52116176/article/details/109406842)\n3. [tags无法显示问题](https://www.zhihu.com/question/29017171)\n4. [next动画速度修改](https://blog.csdn.net/Domino_b/article/details/81704118)\n5. [数学公式问题](https://blog.csdn.net/weixin_45511189/article/details/115798563)","tags":["Others"]},{"title":"Bitcpy","url":"/2021/06/24/Bitcpy/","content":"\n> **两种bitcpy的实现方式**\n\n### 1. 显示数据bits\n\n```C++\n#define HALF_WORD   uint16_t\n#define WORD        uint32_t\nvoid showBits(void* d, int len) {\n\tint bytes = len / 8;\n\tunsigned char* p = (unsigned char*)d;\n\tfor (int i = 0; i < bytes; i++) {\n\t\tunsigned char tmp = 0x80;\n\t\tfor (int j = 0; j < 8; j++) {\n\t\t\tif (tmp & *p)\n\t\t\t\tprintf(\"1\");\n\t\t\telse\n\t\t\t\tprintf(\"0\");\n\t\t\ttmp >>= 1;\n\t\t}\n\t\tprintf(\" \");\n\t\t++p;\n\t}\n\tprintf(\"\\n\");\n}\n```\n\n### 2. bitcpy 算术方式\n\n**拷贝方式是从单个字节的低位开始拷贝，进位式拷贝。**\n\n```C++\nint bitcopy(void* to, unsigned int tOfs, int tCnt, const void* from, unsigned int fOfs, int fCnt) {\n\tint BitsOfHalfWord = sizeof(HALF_WORD) * 8;\n\t// align data and offset to HALF_WORD\n\tto = (void*)((intptr_t)to + (tOfs / BitsOfHalfWord) * sizeof(HALF_WORD));\n\tfrom = (void*)((intptr_t)from + (fOfs / BitsOfHalfWord) * sizeof(HALF_WORD));\n\tfOfs %= BitsOfHalfWord;\n\ttOfs %= BitsOfHalfWord;\n\n\tint NbrOfCopiedBits = 0, bCnt = (fCnt < tCnt) ? fCnt : tCnt;\n\tWORD rMask, wMask;\n\tWORD temp, * _to = (WORD*)to, * _from = (WORD*)from;\n\twhile (bCnt > 0) {\n\t\t// update counter\n\t\tint BitsToCopy = (bCnt < BitsOfHalfWord) ? bCnt : BitsOfHalfWord;\n\t\tbCnt -= BitsToCopy;\n\t\tNbrOfCopiedBits += BitsToCopy;\n\t\t// mask reading from '_from' and mask writing to '_to'\n\t\trMask = (((WORD)-1) << fOfs) ^ (((WORD)-1) << (fOfs + BitsToCopy));\n\t\twMask = (((WORD)-1) << tOfs) ^ (((WORD)-1) << (tOfs + BitsToCopy));\n\t\tshowBits(&rMask, 32);\n\t\tshowBits(&wMask, 32);\n\t\ttemp = (*_from & rMask) >> fOfs << tOfs;\n\t\t*_to &= ~wMask;\n\t\t*_to |= temp;\n\t\tprintf(\"%d bit(s) copied\\n\", BitsToCopy);\n\t\t// increase data pointer if copy is not completed\n\t\tif (BitsToCopy == BitsOfHalfWord) {\n\t\t\t_to = (WORD*)((intptr_t)_to + sizeof(HALF_WORD));\n\t\t\t_from = (WORD*)((intptr_t)_from + sizeof(HALF_WORD));\n\t\t}\n\t\tshowBits(to, 64);\n\t}\n\treturn NbrOfCopiedBits;\n}\n```\n\n### 3. bitcpy 物理方式\n**物理左移**\n\n```C++\nWORD shiftLeft(WORD w, int len) {\n\tunsigned char* s = (unsigned char*)&w;\n\twhile (len--) {\n\t\t*(s) <<= 1;\n\t\tfor (int i = 1; i < 4; i++) {\n\t\t\tif (*(s + i) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (*(s + i) & 0x80)\n\t\t\t\t*(s + i - 1) |= 1;\n\t\t\t*(s + i) <<= 1;\n\t\t}\n\t}\n\treturn w;\n}\n```\n**物理右移**\n\n```C++\nWORD shiftRight(WORD w, int len) {\n\tunsigned char* s = (unsigned char*)&w;\n\twhile (len--) {\n\t\t*(s+3) >>= 1;\n\t\tfor (int i = 2; i >= 0; i--) {\n\t\t\tif (*(s + i) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (*(s + i) & 1)\n\t\t\t\t*(s + i + 1) |= 0x80;\n\t\t\t*(s + i) >>= 1;\n\t\t}\n\t}\n\treturn w;\n}\n```\n**拷贝方式是按照实际的物理bit位进行顺序拷贝的**\n\n```C++\nint bitcpy(void* to, unsigned int tOfs, const void* from, unsigned int fOfs, int bCnt) {\n\tint BitsOfHalfWord = sizeof(HALF_WORD) * 8;\n\t// 将数据和偏置对其“半字”\n\t// 指针视为intptr_t，加1则前进一个Byte，且更安全（适用于将指针进行算术运算时使用）\n\tto = (void*)((intptr_t)to + (tOfs / BitsOfHalfWord) * sizeof(HALF_WORD));\n\tfrom = (void*)((intptr_t)from + (fOfs / BitsOfHalfWord) * sizeof(HALF_WORD));\n\tfOfs %= BitsOfHalfWord;\n\ttOfs %= BitsOfHalfWord;\n\tint NbrOfCopiedBits = 0;\n\tWORD rMask, wMask;\n\tWORD temp;\n\tWORD *_to = (WORD*)to;\n\tWORD *_from = (WORD*)from;\n\twhile (bCnt > 0) {\n\t\t// 更新\n\t\tint BitsToCopy = (bCnt < BitsOfHalfWord) ? bCnt : BitsOfHalfWord;\n\t\tbCnt -= BitsToCopy;\n\t\tNbrOfCopiedBits += BitsToCopy;\n\t\t// 源与目标的遮罩\n\t\trMask = shiftRight((WORD)-1, fOfs) ^ shiftRight((WORD)-1, fOfs + BitsToCopy);\n\t\twMask = shiftRight((WORD)-1, tOfs) ^ shiftRight((WORD)-1, tOfs + BitsToCopy);\n\t\ttemp = (*_from & rMask);\n\t\ttemp = shiftLeft(temp, fOfs);\n\t\ttemp = shiftRight(temp, tOfs);\n\t\t*_to &= ~wMask;\t// 先清理此部分\n\t\t*_to |= temp;\t// 在“拷贝”进来\n\t\t// 拷贝未完成情况下，跟进指针\n\t\tif (BitsToCopy == BitsOfHalfWord) {\n\t\t\t_to = (WORD*)((intptr_t)_to + sizeof(HALF_WORD));\n\t\t\t_from = (WORD*)((intptr_t)_from + sizeof(HALF_WORD));\n\t\t}\n\t}\n\treturn NbrOfCopiedBits;\n}\n```\n### 4. 运行效果\n\n![](https://raw.githubusercontent.com/fkjkkll/My-Algorithm/master/Others/Bitcpy/BitcpyResult.png)","tags":["C/C++"]}]