[{"title":"Hexo说明","url":"/2021/06/28/Hexo%E8%AF%B4%E6%98%8E/","content":"\nHexo相关说明\n\n安装Hexo安装hexo\nHexo基本语法hexo n 我的博客 &#x3D;&#x3D; hexo new 我的博客 &#x2F;&#x2F;新建文章hexo g &#x3D;&#x3D; hexo generate &#x2F;&#x2F;生成hexo s &#x3D;&#x3D; hexo server &#x2F;&#x2F;启动服务预览hexo d &#x3D;&#x3D; hexo deploy &#x2F;&#x2F;部署\nhexo server &#x2F;&#x2F;Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s &#x2F;&#x2F;静态模式hexo server -p 5000 &#x2F;&#x2F;更改端口hexo server -i 192.168.1.1 &#x2F;&#x2F;自定义 IPhexo clean &#x2F;&#x2F;清除缓存，若是网页正常情况下可以忽略这条命令\nHexo相关\n自动展开设置1：显示部分摘要\n自动展开设置2：显示部分摘要\nhexo显示公式乱码问题：公式乱码问题\n如何在另一台电脑使用hexo更新博客\n\nGithub相关如果无法deploy到Github，此时打开命令行输入ping github.com又失败，则可能是梯子的原因，无法进行DNS，即使关掉梯子也不行。此时可以手动在电脑的hosts文件里添加到Github的域名到ip映射，具体操作如下：\n\n在IP查询网页搜索github，找到github的网站地址\n进入C:\\Windows\\System32\\drivers\\etc修改hosts\n由于需要权限所以以管理员模式打开cmd，cd到hosts，然后输入notepad hosts即可进行修改添加，只需插入IP www.github.com和IP github.com保存即可\n\n主题相关\nNEXT常用配置\n背景图片修改问题\ntags无法显示问题\nnext动画速度修改\n数学公式问题\n代码复制功能：去主题的_config.yml修改codeblock下的copy_button改为true即可\n\n写博客流程hexo new 新博客hexo s          # 预览hexo g -d       # 部署git add .git commit -m &#x27;New blog&#x27;git push\n\n恢复git clone [github address]cd [the directory]npm installhexo s\n\n其他\nWindows强制刷新外网网页: Ctrl + F5\n\n","tags":["Others"]},{"title":"C与CPP互相调用","url":"/2022/09/23/C%E4%B8%8ECPP%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/","content":"0. 说明\nC++采用g++编译，C采用gcc编译。两者主要不同点是：C++编译考虑到函数重载，会将原函数“改名”（命名倾轧name mangling）；而在C中不存在重载，函数名不会变动。\ng++和gcc可以兼容C++和C的编译方式，但是默认情况下g++采用C++编译方式；而gcc采用C的编译方式\n注意：gcc编译C++文件时不会主动链接C++用到的库stdc++，需要手动指定链接选项-lstdc++\n__cplusplus宏定义会在编译cpp文件以及用C++的方式编译时被包含，因此用gcc编译.cpp文件或者g++编译.c、.cpp文件都会有这个宏\n之所以用条件判断，因为gcc不认识extern &quot;C&quot;，直接编译会报错\n\n1. C++调用C只需要声明时包含extern &quot;C&quot;即可。下面的代码中，func.h可以不动，在main.cpp调用时，直接extern &quot;C&quot; int func(int, int)也是可以的。只需要让编译器按照C的方式编译，不要改动函数名即可正确链接的函数符号。\n// func.h 不论.c还是.cpp文件调用，都不会出错#ifndef FUNC_H#define FUNC_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // __cplusplusint func(int, int);#ifdef __cplusplus&#125;#endif // __cplusplus#endif\n\n// func.c#include &quot;func.h&quot;int func(int a, int b) &#123;\treturn a + b;&#125;\n\n// main.cpp#include &lt;iostream&gt;#include &quot;func.h&quot;int main() &#123;\tstd::cout &lt;&lt; func(1, 3) &lt;&lt; std::endl;&#125;\n\n2. C调用C++C调用C++稍微麻烦点，遇到类函数和重载函数往往需要嵌套一层，详细如下。\n2.1. 普通函数// func.h#ifndef FUNC_H#define FUNC_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // __cplusplusvoid func();#ifdef __cplusplus&#125;#endif#endif\n\n// func.cpp#include &quot;func.h&quot;#include &lt;iostream&gt;void func() &#123;\tstd::cout &lt;&lt; &quot;void func()&quot; &lt;&lt; std::endl;&#125;\n\n// main.c#include &quot;func.h&quot;int main() &#123;\tfunc();&#125;\n\n\n2.2. 重载函数// func.h#ifndef ADAPTER_H#define ADAPTER_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // __cplusplusvoid func_();void func_i(int);#ifdef __cplusplus&#125;#endif#endif\n\n// func.cpp#include &quot;func.h&quot;#include &lt;iostream&gt;void func() &#123;\tstd::cout &lt;&lt; &quot;void func()&quot; &lt;&lt; std::endl;&#125;void func(int a) &#123;\tstd::cout &lt;&lt; &quot;void func(int)&quot; &lt;&lt; std::endl;&#125;// adaptervoid func_() &#123;\tfunc();&#125;void func_i(int a) &#123;\tfunc(a);&#125;\n\n// main.c#include &quot;func.h&quot;int main() &#123;\tfunc_();\tfunc_i(1);&#125;\n\n2.3. 类函数// Circle.h#ifndef CIRCLE_H#define CIRCLE_Hclass Circle &#123;\tdouble radius;public:\tCircle(double r) :radius(r) &#123;&#125;\tdouble getArea();&#125;;#endif\n\n// Circle.cpp#include &quot;Circle.h&quot;double Circle::getArea() &#123;\treturn 3.1415926 * radius * radius;&#125;\n\n核心文件（adapter.h），此代码必须在C ++和C文件中都可以编译。\n// adapter.h#ifndef ADAPTER_H#define ADAPTER_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif // __cplusplusvoid* Circle_new(double);double Circle_getAea(void*);void Circle_detete(void*);#ifdef __cplusplus&#125;#endif#endif\n\n// adapter.cpp#include &quot;adapter.h&quot;#include &quot;Circle.h&quot;void* Circle_new(double r) &#123;\tCircle *p = new Circle(r);\treturn (void*)p;&#125;double Circle_getAea(void* p) &#123;\treturn ((Circle*)p)-&gt;getArea();&#125;void Circle_detete(void* p) &#123;\tCircle* cp = (Circle*)p;\tdelete cp;&#125;\n\n// main.c#include &lt;stdio.h&gt;#include &quot;adapter.h&quot;int main() &#123;\tvoid* p = Circle_new(1);\tprintf(&quot;%lf\\n&quot;, Circle_getAea(p));\tCircle_detete(p);&#125;\n\n3. 参考\nc语言和c++的相互调用\nC语言中调用C＋＋\n极简式从C调用C++类方法\nC调用C++和C++调用C\nC++与C的相互调用\n\n","tags":["C/C++"]},{"title":"C++ priority_queue自定义排序","url":"/2021/10/31/C-priority-queue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","content":"\nC++ priority_queue自定义排序总结\n\n方法一：函数指针以下几种都可以，具体可参考《C++ Primer》\ntypedef int elem;bool cmp(elem a, elem b) &#123;    return a &lt; b;&#125;priority_queue&lt;elem, vector&lt;elem&gt;, decltype(&amp;cmp)&gt; q(arr.begin(), arr.end(), cmp);priority_queue&lt;elem, vector&lt;elem&gt;, decltype(cmp)*&gt; q(arr.begin(), arr.end(), cmp);priority_queue&lt;elem, vector&lt;elem&gt;, bool(*)(elem, elem)&gt; q(arr.begin(), arr.end(), cmp);// 构造函数前两个可以不填，但是必须传入cmp// 前面模板只是告诉它是一个函数指针bool(*)(elem, elem)，但并没有传入函数地址（实体）priority_queue&lt;elem, vector&lt;elem&gt;, bool(*)(elem, elem)&gt; q(cmp);\n\n对于cmp和&amp;cmp你应该这样理解，cmp是函数的首地址，它的类型是bool(elem,  elem)，&amp;cmp表示一个指向函数cmp这个对象的地址，它的类型是bool(*)(elem, elem)，因此test和&amp;test所代表的地址的值是一样的，但类型不一样！\n方法二：重载运算符struct elem &#123;    int a;    int b;    bool operator&lt;(const elem&amp; another) const &#123;        return this-&gt;b &lt; another.b;    &#125;&#125;;priority_queue&lt;elem, vector&lt;elem&gt;, less&lt;elem&gt;&gt; q;\n注意：operator函数要有const，这是能构成重载的，否则未找到对应函数报错\n方法三：仿函数struct elem &#123;    int a;    int b;&#125;;struct cmp &#123;    bool operator()(const elem&amp; left, const elem&amp; right) &#123;        return left.b &lt; right.b;    &#125;&#125;;priority_queue&lt;elem, vector&lt;elem&gt;, cmp&gt; q;priority_queue&lt;elem, vector&lt;elem&gt;, cmp&gt; q(arr.begin(), arr.end()); // 不需要传入cmp参数\n\n方法四：匿名函数（类似仿函数）auto cmp = [](const item&amp; a, const item&amp; b) &#123;return a.first &lt; b.first; &#125;; // 实例priority_queue&lt;item, vector&lt;item&gt;, decltype(cmp)&gt; pq(arr.begin(), arr.end(), cmp); // decltype解析类型，并需要传入实例\n\n","tags":["C/C++"]},{"title":"Set、Map、Unordered","url":"/2022/03/27/Set%E3%80%81Map%E3%80%81Unordered/","content":"Map和Set\nMap是&lt;key, value&gt;结构；Set是&lt;key&gt;结构，天然具有去重功能\n自定义类放入Map或Set需要实现bool operator&lt;(const MyClass&amp; ano) const，注意里面的两个const是必备的，不能漏\n不用实现operator=，因为a&lt;b == false &amp;&amp; a&gt;b == false会自动推断出等于\n\n0、示范图         0         |        (1)         |2 —(1)—  1  —(1)— 3   \\           /   (3)       (2)      \\     /         4\n\n1、错误代码示例\n下面Node类，利用Set来实现Dijkstra是不对的，因为在operator&lt;中参与返回结果的只有val因此，两个不一样的Node在Set中会被认为是相同的。即Node a = Node({1,1})和Node b = Node({2,1})，由于(a&lt;b==false &amp;&amp; b&gt;a==false)所以被判定为相等，与我们的目的南辕北辙。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int inf = INT_MAX;struct Node &#123;    Node(int _p, int _v):pos(_p), val(_v)&#123;&#125;    int pos;    int val;    bool operator&lt;(const Node&amp; ano) const &#123;        return this-&gt;val &lt; ano.val;    &#125;&#125;;int main() &#123;    vector&lt;vector&lt;int&gt;&gt; g = &#123;        &#123;0,   1,   inf, inf, inf&#125;,        &#123;1,   0,   1,   1,   inf&#125;,        &#123;inf, 1,   0,   inf, 3  &#125;,        &#123;inf, 1,   inf, 0,   2  &#125;,        &#123;inf, inf, 3,   2,   0  &#125;,    &#125;;    int n = (int)g.size();    // ------------------------------------    vector&lt;int&gt; dist(n, INT_MAX);    dist[0] = 0;    set&lt;Node&gt; pq;    pq.insert(Node(0, 0));    while (!pq.empty()) &#123;        Node cur = *pq.begin(); pq.erase(pq.begin());        int from = cur.pos;        int dis = cur.val;        cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; cur.val &lt;&lt; endl;        for (int to = 0; to &lt; n; ++to) &#123;            if (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;                dist[to] = dis + g[from][to];                pq.insert(Node(to, dist[to]));            &#125;        &#125;    &#125;    for (auto e : dist)        cout &lt;&lt; e &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n输出结果为：\n0 01 12 24 50 1 2 2 5 // 错误，应该是4// 原因是插入Node&#123;3,2&#125;时发现已经有了，所以就取消插入，因此无法利用&#123;3,2&#125;来更新最小边\n\n2、正确用法priority_queue#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int inf = INT_MAX;struct Node &#123;    Node(int _p, int _v):pos(_p), val(_v)&#123;&#125;    int pos;    int val;    bool operator&gt;(const Node&amp; ano) const &#123;        return this-&gt;val &gt; ano.val;    &#125;&#125;;int main() &#123;    vector&lt;vector&lt;int&gt;&gt; g = &#123;        &#123;0,   1,   inf, inf, inf&#125;,        &#123;1,   0,   1,   1,   inf&#125;,        &#123;inf, 1,   0,   inf, 3  &#125;,        &#123;inf, 1,   inf, 0,   2  &#125;,        &#123;inf, inf, 3,   2,   0  &#125;,    &#125;;    int n = (int)g.size();    // ------------------------------------    vector&lt;int&gt; dist(n, INT_MAX);    dist[0] = 0;    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq;    pq.push(Node(0, 0));    while (!pq.empty()) &#123;        Node cur = pq.top(); pq.pop();        int from = cur.pos;        int dis = cur.val;        cout &lt;&lt; from &lt;&lt; &quot; &quot; &lt;&lt; cur.val &lt;&lt; endl;        for (int to = 0; to &lt; n; ++to) &#123;            if (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;                dist[to] = dis + g[from][to];                pq.push(Node(to, dist[to]));            &#125;        &#125;    &#125;    for (auto e : dist)        cout &lt;&lt; e &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n输出结果为：\n0 01 12 23 2 // OK4 44 50 1 2 2 4 // OK\n\n总之，以后写Dijkstra不要妄图用set和map来替换优先队列!!!Unordered_set和unordered_map\n需要定义一个仿函数operator(...)用来计算hash_value，并在定义时传入模板参数\n重载operator==\n\n#include &lt;iostream&gt;using namespace std;#include &lt;string&gt;#include &lt;unordered_map&gt;struct node &#123;    node(int _id, double _val) : id(_id), val(_val) &#123;&#125;    int id;    double val;    bool operator==(const node&amp; ano) const &#123; // 判断两个对象是否相等（自动加上key匹配再判断相等）        return val == ano.val;    &#125;&#125;;struct node_hash &#123;    size_t operator()(const node&amp; v) const &#123; // 生成hash value，必须返回 [无符号整数] 用来进行映射        return v.id; // 生成hash value的方式都可以灵活自定义        //return hash&lt;double&gt;()(v.val);    &#125;&#125;;int main() &#123;    unordered_map&lt;node, string, node_hash&gt; ms;    node a = &#123; 1, 1.1111 &#125;;    node b = &#123; 2, 1.1111 &#125;;    ms[a] = &quot;aaaa&quot;;    ms[b] = &quot;bbbb&quot;;    cout &lt;&lt; ms[a] &lt;&lt; endl;    cout &lt;&lt; ms[b] &lt;&lt; endl;    return 0;&#125;","tags":["C/C++"]},{"title":"Bitcpy","url":"/2021/06/24/Bitcpy/","content":"\n两种bitcpy的实现方式\n\n1. 显示数据bits#define HALF_WORD   uint16_t#define WORD        uint32_tvoid showBits(void* d, int len) &#123;    int bytes = len / 8;    unsigned char* p = (unsigned char*)d;    for (int i = 0; i &lt; bytes; i++) &#123;        unsigned char tmp = 0x80;        for (int j = 0; j &lt; 8; j++) &#123;            if (tmp &amp; *p)                printf(&quot;1&quot;);            else                printf(&quot;0&quot;);            tmp &gt;&gt;= 1;        &#125;        printf(&quot; &quot;);        ++p;    &#125;    printf(&quot;\\n&quot;);&#125;\n\n2. bitcpy 算术方式拷贝方式是从单个字节的低位开始拷贝，进位式拷贝。\nint bitcopy(void* to, unsigned int tOfs, int tCnt, const void* from, unsigned int fOfs, int fCnt) &#123;    int BitsOfHalfWord = sizeof(HALF_WORD) * 8;    // align data and offset to HALF_WORD    to = (void*)((intptr_t)to + (tOfs / BitsOfHalfWord) * sizeof(HALF_WORD));    from = (void*)((intptr_t)from + (fOfs / BitsOfHalfWord) * sizeof(HALF_WORD));    fOfs %= BitsOfHalfWord;    tOfs %= BitsOfHalfWord;    int NbrOfCopiedBits = 0, bCnt = (fCnt &lt; tCnt) ? fCnt : tCnt;    WORD rMask, wMask;    WORD temp, * _to = (WORD*)to, * _from = (WORD*)from;    while (bCnt &gt; 0) &#123;        // update counter        int BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;        bCnt -= BitsToCopy;        NbrOfCopiedBits += BitsToCopy;        // mask reading from &#x27;_from&#x27; and mask writing to &#x27;_to&#x27;        rMask = (((WORD)-1) &lt;&lt; fOfs) ^ (((WORD)-1) &lt;&lt; (fOfs + BitsToCopy));        wMask = (((WORD)-1) &lt;&lt; tOfs) ^ (((WORD)-1) &lt;&lt; (tOfs + BitsToCopy));        showBits(&amp;rMask, 32);        showBits(&amp;wMask, 32);        temp = (*_from &amp; rMask) &gt;&gt; fOfs &lt;&lt; tOfs;        *_to &amp;= ~wMask;        *_to |= temp;        printf(&quot;%d bit(s) copied\\n&quot;, BitsToCopy);        // increase data pointer if copy is not completed        if (BitsToCopy == BitsOfHalfWord) &#123;            _to = (WORD*)((intptr_t)_to + sizeof(HALF_WORD));            _from = (WORD*)((intptr_t)_from + sizeof(HALF_WORD));        &#125;        showBits(to, 64);    &#125;    return NbrOfCopiedBits;&#125;\n\n3. bitcpy 物理方式物理左移\nWORD shiftLeft(WORD w, int len) &#123;    unsigned char* s = (unsigned char*)&amp;w;    while (len--) &#123;        *(s) &lt;&lt;= 1;        for (int i = 1; i &lt; 4; i++) &#123;            if (*(s + i) == 0)                continue;            if (*(s + i) &amp; 0x80)                *(s + i - 1) |= 1;            *(s + i) &lt;&lt;= 1;        &#125;    &#125;    return w;&#125;\n物理右移\nWORD shiftRight(WORD w, int len) &#123;    unsigned char* s = (unsigned char*)&amp;w;    while (len--) &#123;        *(s+3) &gt;&gt;= 1;        for (int i = 2; i &gt;= 0; i--) &#123;            if (*(s + i) == 0)                continue;            if (*(s + i) &amp; 1)                *(s + i + 1) |= 0x80;            *(s + i) &gt;&gt;= 1;        &#125;    &#125;    return w;&#125;\n拷贝方式是按照实际的物理bit位进行顺序拷贝的\nint bitcpy(void* to, unsigned int tOfs, const void* from, unsigned int fOfs, int bCnt) &#123;    int BitsOfHalfWord = sizeof(HALF_WORD) * 8;    // 将数据和偏置对其“半字”    // 指针视为intptr_t，加1则前进一个Byte，且更安全（适用于将指针进行算术运算时使用）    to = (void*)((intptr_t)to + (tOfs / BitsOfHalfWord) * sizeof(HALF_WORD));    from = (void*)((intptr_t)from + (fOfs / BitsOfHalfWord) * sizeof(HALF_WORD));    fOfs %= BitsOfHalfWord;    tOfs %= BitsOfHalfWord;    int NbrOfCopiedBits = 0;    WORD rMask, wMask;    WORD temp;    WORD *_to = (WORD*)to;    WORD *_from = (WORD*)from;    while (bCnt &gt; 0) &#123;        // 更新        int BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;        bCnt -= BitsToCopy;        NbrOfCopiedBits += BitsToCopy;        // 源与目标的遮罩        rMask = shiftRight((WORD)-1, fOfs) ^ shiftRight((WORD)-1, fOfs + BitsToCopy);        wMask = shiftRight((WORD)-1, tOfs) ^ shiftRight((WORD)-1, tOfs + BitsToCopy);        temp = (*_from &amp; rMask);        temp = shiftLeft(temp, fOfs);        temp = shiftRight(temp, tOfs);        *_to &amp;= ~wMask;\t// 先清理此部分        *_to |= temp;\t// 在“拷贝”进来        // 拷贝未完成情况下，跟进指针        if (BitsToCopy == BitsOfHalfWord) &#123;            _to = (WORD*)((intptr_t)_to + sizeof(HALF_WORD));            _from = (WORD*)((intptr_t)_from + sizeof(HALF_WORD));        &#125;    &#125;    return NbrOfCopiedBits;&#125;","tags":["C/C++"]},{"title":"Qt信号与槽","url":"/2022/09/16/Qt%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD/","content":"Qt的信号与槽机制是如何实现的？\n猜测1：回调函数\n这里用C11出现的function来封装所有可调用的对象：函数、指针、lambda、bind创建的对象、重载了小括号的仿函数\n通过unordered_multimap来记录某个字符串与一个可调用对象的映射（注意unordered_multimap未实现[]和at函数，不能通过这类方式获取value）\n\nclass Connection &#123;\tunordered_multimap&lt;string, function&lt;void()&gt;&gt; mmap;public:\t// 按照名称建立映射关系\tvoid connect(const string&amp; name, const function&lt;void()&gt;&amp; callback) &#123;\t\t//mmap[name] = callback; ERROR\t\tmmap.insert(&#123; name, callback &#125;);\t&#125;\tvoid invok(const string&amp; name) &#123;\t\tauto res = mmap.equal_range(name);\t\tauto l = res.first, r = res.second;\t\twhile (l != r) &#123;\t\t\tl-&gt;second();\t\t\t++l;\t\t&#125;\t&#125;&#125;;// 全局共享的Connectionstatic Connection con;class Tom &#123;public:\tvoid miaow() &#123;\t\tcout &lt;&lt; &quot;喵&quot; &lt;&lt; endl;\t\tcon.invok(&quot;mouse&quot;);\t&#125;&#125;;class Jerry &#123;public:\tJerry() &#123;\t\t// 普通类函数的第一个参数是this，所以这里绑定this\t\tcon.connect(&quot;mouse&quot;, bind(&amp;Jerry::RunAway, this));\t&#125;\tvoid RunAway() &#123;\t\tcout &lt;&lt; &quot;那只笨又猫来了，快跑！&quot; &lt;&lt; endl;\t&#125;&#125;;int main() &#123;\t// 模拟嵌套层级很深的场景，外部不能直接访问到tom\tstruct A &#123;\t\tstruct B &#123;\t\t\tstruct C &#123;\t\t\tprivate:\t\t\t\tTom tom;\t\t\tpublic:\t\t\t\tvoid MiaoMiaoMiao() &#123;\t\t\t\t\ttom.miaow();\t\t\t\t&#125;\t\t\t&#125; c;\t\t\tvoid MiaoMiao() &#123;\t\t\t\tc.MiaoMiaoMiao();\t\t\t&#125;\t\t&#125; b;\t\tvoid Miao() &#123;\t\t\tb.MiaoMiao();\t\t&#125;\t&#125; a;\t// 模拟嵌套层级很深的场景，外部不能直接访问到jerry\tstruct D &#123;\t\tstruct E &#123;\t\t\tstruct F &#123;\t\t\tprivate:\t\t\t\tJerry jerry1, jerry2, jerry3;\t\t\t&#125; f;\t\t&#125; e;\t&#125; d;\ta.Miao();&#125;\n输出结果：\n喵那只笨又猫来了，快跑！那只笨又猫来了，快跑！那只笨又猫来了，快跑！\n\n猜测2：观察者模式\n别名：订阅-发布模式\n任意类继承Subject模板类，提供观察者参数，即拥有了订阅-发布模式\n\ntemplate&lt;typename ObserverType&gt;class Subject &#123;\tvector&lt;ObserverType*&gt; _list;public:\t// 订阅\tvoid subscribe(ObserverType* obs) &#123;\t\tauto itor = std::find(_list.begin(), _list.end(), obs);\t\tif (_list.end() == itor) &#123;\t\t\t_list.push_back(obs);\t\t&#125;\t&#125;\t\t// 取消订阅\tvoid unSubscribe(ObserverType* obs) &#123;\t\t// erase配合remove\t\t_list.erase(std::remove(_list.begin(), _list.end(), obs));\t&#125;\t// 发布\ttemplate&lt;typename FuncType&gt;\tvoid publish(FuncType func) &#123;\t\tfor (auto obs : _list) &#123;\t\t\t// 调用回调函数，将obs作为一个参数传入\t\t\tfunc(obs);\t\t&#125;\t&#125;&#125;;// CatObserver接口 猫的观察者class CatObserver &#123;public:\tvirtual void onMiaow() = 0;\tvirtual ~CatObserver() &#123;&#125;&#125;;// Tom继承自Subject，模板参数CatObserver// 这样Tom就可以订阅、发布对应类型class Tom : public Subject&lt;CatObserver&gt; &#123;public:\tvoid miaow() &#123;\t\tcout &lt;&lt; &quot;喵&quot; &lt;&lt; endl;\t\t// 这里CatObserver的成员函数，所以第一个参数需要this指针，这里悬置-&gt;对应publish的object\t\tpublish(std::bind(&amp;CatObserver::onMiaow, std::placeholders::_1));\t&#125;&#125;;// Jerry继承自CatObserver，可以被订阅class Jerry : public CatObserver &#123;public:\tvoid onMiaow() override &#123;\t\tRunAway();\t&#125;\tvoid RunAway() &#123;\t\tcout &lt;&lt; &quot;那只笨又猫来了，快跑！&quot; &lt;&lt; endl;\t&#125;&#125;;int main() &#123;\tTom tom;\tJerry jerry1, jerry2, jerry3;\t// 拿一堆jerry去订阅tom的 猫叫 事件\ttom.subscribe(&amp;jerry1);\ttom.subscribe(&amp;jerry2);\ttom.subscribe(&amp;jerry3);\t\ttom.miaow();&#125;\n输出结果：\n喵那只笨又猫来了，快跑！那只笨又猫来了，快跑！那只笨又猫来了，快跑！\n\n真实的Qt信号与槽\n同线程：类似函数调用，比观察者模式多一点性能损失\n异线程：发送者线程将槽函数的调用转化为一次“调用事件”加入到事件循环中，接收者线程执行到下一个事件处理时，处理调用事件\n\n信号与槽借助一个工具：元对象编译器MOC（Meta Object Compiler），集成在Qt编译工具链qmake中，在编译Qt工程前会先执行MOC，解析signals、slot、emit等关键字，处理Q_OBJECT、Q_PROPERTY、Q_INVOKABLE等宏，生成一个moc_xxx.cpp的C++文件（黑魔法来实现语法糖）比如信号只要声明不用实现，因为MOC自动生成实现放在moc_xxx.cpp中。之后即可进行常规的C&#x2F;C++编译、链接流程\nMOC的本质：反射反射简单来说，就是运行过程中，获取对象的构造函数、成员函数、成员变量，例如：\nclass Tom &#123;public:    Tom() &#123;&#125;    const std::string &amp; getName() const &#123;        return m_name;    &#125;    void setName(const std::string &amp;name) &#123;        m_name = name;    &#125;private:    std::string m_name;&#125;;\n\n类的使用者看不到类的声明，头文件都拿不到，不能直接调用类的构造函数、成员函数。因此将Tom类的构造函数、成员函数等信息存储起来，还要能够被调用到。这些信息就是“元信息”，使用者通过“元信息”就可以“使用这个类了”，这便是反射。设计模式中的工厂模式就是反射的一种。\npython中涉及反射机制的函数有：getattr(), setattr(), delattr(), exec(), eval(), __import__等，都可以执行字符串\n更具体的实现机制参考窥探信号槽的实现细节，这里仅摘录部分。\n参考\nC++ function\n认清信号槽的本质\n窥探信号槽的实现细节\nQt进阶之路\n\n","tags":["C/C++","Qt"]},{"title":"YOLOv3源码理解","url":"/2022/10/08/YOLOv3%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/","content":"0 主干网络YOLOv3采用DarkNet-53网络，结构如下图（DarkNet-53预训练于ImageNet，由于是1000类的分类，所以网络最后输出经过全连接层。但是目标检测不需要那个全连接层，因此实际上只使用了“DarkNet-52”，共52层卷积层）：\n\n\nBN为批归一化层，Acti为激活函数，YOLOv3采用LeakyReLU\n输入批次经过一个3X3卷积改变通道数为32，然后经过5个降残差块。每个降残差块包含一次步幅为2的3X3卷积加上一系列残差块。每个残差块包含一次1X1卷积降低通道数，再经过一次3X3卷积提升通道数，最后和残差边进行连接。\n整体主干网络清晰，每经过一个降残差块，通道数翻倍，特征图宽高减半。\n\n1 预测分支网络下图是YOLOv3的预测分支网络部分，是一个典型的特征金字塔结构。最后的输出通道75是假设采用VOC数据集进行20个类别的检测，因此输出的75代表3*(4+1+20)，3代表每个特征点3个先验框；4代表先验框x、y的偏移量以及宽高的伸缩量；1代表该先验框包含目标的置信度；20代表该数据集类别个数。\n\n2 数据加载\n图片会被进行各种图像增强、添加灰条等操作，最终大小为(416，416)，值归一化到0~1，形状为(B, 3, 416, 416)\n标签会被归一化0~1（从数据集[左上右下]转换为[中心宽高]），形状为list[(GT, 4)...B个]\n\n3 训练网络\n网络前向传播会获得一个包含三元素的元组：((bs,75,13,13),(bs,75,26,26),(bs,75,52,52))，代表网络三个层的输出\n依次计算每个层的损失，相加之后进行反向传播\n\n3.1 输出层的解码以(bs,75,13,13)为例，view到(bs,3,13,13,25)，随后通过其中包含的信息结合给该层分配的三个先验框的宽高，可以得到预测框的结果。\n\n(..., 0:2)执行sigmoid获得该层先验框的偏移\n(..., 2:4)不执行任何操作，之后用于宽高的缩放\n(..., 4)执行sigmoid获得包含物体的置信度\n(..., 5:)执行sigmoid获得被认为是每个类别的概率\n\n3.2 正负样本\n批次里的每个图片都会单独循环处理：将这些真实框与9个先验框做IOU，从而确定每个真实框由哪个大小的先验框负责。确认后，再根据真实框的中心位置，确认属于哪个特征点负责，最终即可确认由哪一个先验框（确定了哪一层）的哪个特征图（该层的哪个格子）负责，正样本既定。\n按理说，其他未分配真实框的预测框都是负样本，有(13*13+26*26+52*52)*3 - 9 = 10647 - 9 = 10638个负样本。但是作者考虑到，某些本不负责预测目标框的预测框，如果其IOU与该目标比较重合（例如大于0.5），则不能将其作为负样本，应该忽略之。因此实际的负样本应该是小于该值的。\n\n3.3 损失函数计算\nYOLOv3包含三个损失：边框回归损失、目标置信度损失、类别损失\n对于正样本，三项损失都要计算：\n其中边框回归损失可以采用MSELoss、BCELoss、或者各类的IOU损失，例如DIOU, GIOU, CIOU\n目标置信度损失直接采用BCELoss，可以选择和Focal Loss形式结合\n类别损失直接采用BCELoss\n\n\n对于负样本，只计算目标置信度损失，直接采用BCELoss，可以选择和Focal Loss形式结合。注意，当选择Focal Loss形式时，该项损失的权重系数要重新配置，一般要增大很多。而且训练结束后的预测的置信度*类别可能会降低，因为只学习难的，简单易判的往往损失权值极地，基本不学习，导致这种现象产生。\n\n4 预测网络\n转RGB、调整形状、添加灰条（可选）、归一化0~1、添加批次通道，最终形状：(1,3,416,416)\n送入网络得到结果，一个包含三元素的元组：((1,75,13,13),(1,75,26,26),(1,75,52,52))\n将结果解码：根据预测结果和先验框宽高，得到一个包含三元素的列表：[(1, 3*13*13, 25), (1, 3*26*26, 25), (1, 3*52*52, 25)]，最终合并为单个张量：(1, 10647, 25)。其中的值都被归一化为0~1了\n将数据转换为(10647, 7)代表xmin, ymin, xmax, ymax, conf, class_conf, class_pred，按照(..., 4)*(..., 5) &gt; threshold获得保留的预测框\n按照每个类别，分别执行非极大值抑制，最后收集保留的这些预测框\n将预测框按照之前图像预处理，进行反向操作（其中为方便操作，将之前的7属性的坐标部分进行颠倒，现在为ymin, xmin, ymax, xmax, conf, class_conf, class_pred），可以理解为top, left, bottom, right\n\n","tags":["目标检测"]},{"title":"Rand7实现Rand10","url":"/2022/03/19/Rand7%E5%AE%9E%E7%8E%B0Rand10/","content":"470 用 Rand7() 实现 Rand10()1. 拒绝采样在解LC-470前先介绍一道拒绝采样的经典问题：利用频率近似概率的方式求出 $\\pi$ 的值。在 $1\\times1$ 的方块内随机坐标采样，记录落入以原点为圆心，半径为1的 $\\frac{1}{4}$ 圆内的次数。\n由 $\\frac{1}{4}\\pi r^2 &#x3D; \\frac{cnt}{N}$ 可得 $\\pi &#x3D; \\frac{4\\times cnt}{N\\times r^2}$ ，由于 $r&#x3D;1$ ，所以 $\\pi &#x3D; \\frac{4\\times cnt}{N}$\nint main() &#123;    srand((unsigned)time(0)); // time(0)表示从1970到现在的秒数    int N = (int)1e7, cnt = 0;    for (int i = 0; i &lt; N; i++) &#123;        double a = (1.0 * rand() / RAND_MAX); // 除以RAND_MAX归一化0~1        double b = (1.0 * rand() / RAND_MAX);        if (a * a + b * b &lt; 1.0) cnt++; // 落入1/4圆则加一    &#125;    printf(&quot;%lf&quot;, (4.0 * cnt) / N);    return 0;&#125;\n\n2. LC-470 Rand7生成Rand10力扣高赞题解\n(rand_X() - 1) × Y + rand_Y() &#x3D;&#x3D;&gt; 可以等概率的生成[1, X * Y]范围的随机数\nclass Solution &#123;public:    int rand10() &#123;        while(true)&#123;            // 等概率生成[1,49]范围的随机数            int num = (rand7()-1)*7 + rand7();            // 拒绝采样，并返回[1,10]范围的随机数            if(num &lt;= 40) return num % 10 + 1;        &#125;    &#125;&#125;;","tags":["算法"]},{"title":"CPP线程使用","url":"/2022/05/01/CPP%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8/","content":"函数介绍\nlock_guard：锁定互斥锁后，生命周期结束后会自动释放，不需要手动解锁，也无法手动解锁\nunique_lock：多数情况与上面一个可以相互替代，但是其更具功能性（付出一些代价）。unique_lock可以进行unlock操作，因此可以和条件变量搭配使用\n\n多线程输出数字多个线程互斥输出: 0 1 2 3 4 5 6 ...\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;int idx = 0;mutex _mutex;void func(int n) &#123;\twhile (idx &lt; n) &#123; // 改成true一样的\t\tlock_guard&lt;mutex&gt; tmp(_mutex);\t\tif (idx &gt;= n) break; // 必须，否则多输出几个数才停\t\tcout &lt;&lt; idx++ &lt;&lt; &quot; &quot;;\t&#125;&#125;int main() &#123;\tvector&lt;thread&gt; arr;\tfor (int i = 0; i &lt; 10; ++i)\t\tarr.push_back(thread(func, 1000));\tfor (auto&amp; e : arr)\t\te.join();\treturn 0;&#125;\n版本2\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;windows.h&gt;using namespace std;int idx = 0;mutex _mutex;void func(int n) &#123;\twhile (idx &lt; n) &#123;\t\tlock_guard&lt;mutex&gt; tmp(_mutex);\t\tif (idx &gt;= n) break;\t\tcout &lt;&lt; idx++ &lt;&lt; &quot; &quot;;\t&#125;&#125;int main() &#123;\tvector&lt;thread&gt; arr;\tfor (int i = 0; i &lt; 10; ++i) &#123;\t\tauto t = thread(func, 1000);        // 不需要join了\t\tt.detach();        // 这里不能传入左值，会报错“尝试引用已删除的函数”        // 或者通过vector存放thread的指针的方式\t\tarr.push_back(move(t));\t&#125;\t// 模拟其他操作，虽然detach后不需要join但是主线程结束后    // 子线程也会直接结束\tSleep(1000);\treturn 0;&#125;\n\n\n多线程输出ABC多个线程互斥输出:\nA B CA B CA B CA B C...\n#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;using namespace std;mutex _mutex;int step = 0;int stepNum = 0;void func1() &#123;\twhile (true) &#123;\t\tlock_guard&lt;mutex&gt; tmp(_mutex);\t\tif (stepNum == 30) break;\t\tif (step % 3 == 0) &#123;\t\t\t++step;\t\t\t++stepNum;\t\t\tcout &lt;&lt; &quot;A&quot; &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;&#125;void func2() &#123;\twhile (true) &#123;\t\tlock_guard&lt;mutex&gt; tmp(_mutex);\t\tif (stepNum == 30) break;\t\tif (step % 3 == 1) &#123;\t\t\t++step;\t\t\t++stepNum;\t\t\tcout &lt;&lt; &quot;B&quot; &lt;&lt; &quot; &quot;;\t\t&#125;\t&#125;&#125;void func3() &#123;\twhile (true) &#123;\t\tlock_guard&lt;mutex&gt; tmp(_mutex);\t\tif (stepNum == 30) break;\t\tif (step % 3 == 2) &#123;\t\t\t++step;\t\t\t++stepNum;\t\t\tcout &lt;&lt; &quot;C&quot; &lt;&lt; endl;\t\t&#125;\t&#125;&#125;int main() &#123;\tthread t1(func1);\tthread t2(func2);\tthread t3(func3);\tt1.join();\tt2.join();\tt3.join();\treturn 0;&#125;\n\n条件变量#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;windows.h&gt;#include &lt;condition_variable&gt;using namespace std;mutex _mutex;condition_variable cv;bool ready = false;// 最开始10个线程会在cv.wait处阻塞，并且会unlock _mutex。// 当cv.notify后，这十个线程便会以随机的顺序尝试lock _mutex继续向下执行void workers(int id) &#123;\tunique_lock&lt;mutex&gt; ulck(_mutex); // 可以灵活unlock\twhile (ready == false) &#123;\t\tcout &lt;&lt; &quot;here: &quot;&lt;&lt; id &lt;&lt; endl;\t\tcv.wait(ulck); // 阻塞\t\t// 其他操作...\t&#125;\tcout &lt;&lt; &quot;thread: &quot; &lt;&lt; id &lt;&lt; endl;&#125;void go() &#123;\tunique_lock&lt;mutex&gt; ulck(_mutex);\tready = true;\tcv.notify_all();&#125;int main() &#123;\tthread mt[10];\tfor (int i = 0; i &lt; 10; ++i)\t\tmt[i] = thread(workers, i);\tcout &lt;&lt; &quot;10 threads ready to race...(already!)&quot; &lt;&lt; endl;\tSleep(50); // 确保前面的线程先到地方wait\tgo();\tfor (auto&amp; e : mt)\t\te.join();\treturn 0;&#125;","tags":["C/C++"]},{"title":"YOLOv4,v5,X理解","url":"/2022/10/20/YOLOv4-v5-X%E7%90%86%E8%A7%A3/","content":"YOLOv4YOLOv4是在YOLOv3的基础上进行了一些改进，但是整个流程依旧是YOLOv3，比如正负样本的划分、忽略样本等等。其中添加的改进主要有如下几点：\n\n跨阶段局部网络（Cross-Stage-Partial, CSP）作为主干网络进行特征提取\nMish激活函数（backbone）和Leaky ReLU（neck）\nMosaic数据增强、MixUP数据增强\n添加注意力机制模块\nCIoU作为边框回归损失\n在neck中添加空间金字塔池化（Spatial Pyramid Pooling, SPP）提升感受野\n在原先YOLOv3 neck的特征金字塔网络（Feature Pyramid Netword, FPN）的基础上改进为路径聚合网络（Path Aggregation Network, PAN）\n\nYOLOv5YOLOv5并无论文，我以开源代码中的实现来说明（version 5.0）。\n新的正样本选择机制网络输出部分xywh的偏移计算公式发生改动，现在xywh都会经过sigmoid归一化。\n\n网络输出xy偏移公式：$pred_x &#x3D; t_x*2-0.5+grid_x$\n网络输出wh偏移公式：$pred_w &#x3D; (t_w*2)^{2}*anchor_w$\n\n这样设计xy的原因是，YOLOv3如果中心点在极边缘，那么网络的输出需要是个比较大的值，才能通过sigmoid得到极边缘的位置，这不好学习，改进的方法则可以消除这个问题。\n这样设计wh的原因是，指数不好控制，容易训练不稳定\n对于每个gt，会先计算它与9个锚框的宽与宽之比，高与高之比，以及倒数；结果会得到每一个gt与9个锚框的4个比值，选择4个比值的最大值作为代表值，代表值比值因子在一定范围内（如4）的先验框作为负责预测该目标的先验框（因此可能会有多个先验框负责预测该gt）。\n进一步，正样本会根据中心点的具体位置，会添加四个角的额外两个特征点来预测，一共每个目标有三个位置的对应大小的先验框来负责预测（可能会有相同大小的先验框的不同位置都负责预测该gt）。当然，过程会有可能某个先验框负责多个gt的预测的矛盾产生，但是不用担心，会根据代表值最低匹配原则来确认它到底负责哪一个gt\n总的来说可能会有多个尺度的多个位置负责预测某个目标，相比较于YOLOv3、YOLOv4，大大提升了正样本数量\n其他改动\nFocus模块，主干网络起始以Focus结构降低特征图宽高，不过该结构在最新版已经弃用\n网络全部采用SiLU激活函数\nCSPLayer相较于YOLOv4发生一点点改动，减少一个卷积模组\n将SPP模块放入到主干网络最后一部分（后续版本提出SPPF，性能优秀）\nneck部分的卷积堆叠用CSPLayer替代，并修改部分通道改变情况\n通过尺度因子：通道深度、残差块层数，来定义网络从而划分s、m、l、x大小不同网络\n\nYOLOXYOLOX的整体网络架构基本上和YOLOv5一致（原论文大多实验也是基于YOLOv3），所以该网络主要创新是在解耦头以及正样本选择方面。\n正样本选择策略（SimOTA）值得一提的是预测xywz的偏移，不需要经过sigmoid归一化\n\n网络输出xy偏移公式：$pred_x &#x3D; t_x+grid_x$\n网络输出wh便宜公式：$pred_w &#x3D; e^{t_w}$\n\n具体的正样本（特征点）选取规则：\n\n其他改动\n计算损失时，类别损失标签不是1，是该特征点对于的预测框与对应gt的IoU\nanchor-free：输出分叉，然后结果堆叠就行了\nDecoupled Head，解耦头预测\n\n","tags":["目标检测"]},{"title":"const要点","url":"/2022/08/19/const%E8%A6%81%E7%82%B9/","content":"const要点\nC的const是虚假的，就是个只读量，只是说不能通过变量名进行修改，但是拿到指针就可修改；\nC++的const会保险一些，会有类似符号表的东西；但是类内的const普通成员变量则依旧会被通过指针改变\n静态const和全局const虽然可以通过指针修改，编译时期可能不会报错，但是运行到那个地方就会报错\nconst只在编译期间保证常量被使用时的不变性，无法保证运行期间的行为。\n\nclass A &#123;public:    const int val2 = 22;    static int val3;    static const int val4 = 44; // !&#125;;int A::val3 = 33;const int val5 = 55;int val6 = 66;int main() &#123;    const int val1 = 11;    int* p1 = (int*)&amp;val1; // 栈区，拿到地址随便改，但是符号表会覆盖    *p1 = 1111;    cout &lt;&lt; &amp;val1 &lt;&lt; &quot; &quot; &lt;&lt; val1 &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; *p1 &lt;&lt; endl;    cout &lt;&lt; &quot;===&quot; &lt;&lt; endl;    A ins;    int* p2 = (int*)&amp;ins.val2;    *p2 = 2222; // 栈区，拿到地址随便改    cout &lt;&lt; &amp;ins.val2 &lt;&lt; &quot; &quot; &lt;&lt; ins.val2 &lt;&lt; endl;    cout &lt;&lt; p2 &lt;&lt; &quot; &quot; &lt;&lt; *p2 &lt;&lt; endl;    cout &lt;&lt; &quot;===&quot; &lt;&lt; endl;    int* p3 = (int*)&amp;A::val3;    *p3 = 3333; // 全局数据区，但是不在常量区，可以修改    cout &lt;&lt; p3 &lt;&lt; &quot; &quot; &lt;&lt; *p3 &lt;&lt; endl;    cout &lt;&lt; &amp;A::val3 &lt;&lt; &quot; &quot; &lt;&lt; A::val3 &lt;&lt; endl;    cout &lt;&lt; &quot;===&quot; &lt;&lt; endl;    int* p4 = (int*)&amp;A::val4;    //*p4 = 4444; // 编译不出错，运行会异常（常量区不能修改）    cout &lt;&lt; p4 &lt;&lt; &quot; &quot; &lt;&lt; *p4 &lt;&lt; endl;    cout &lt;&lt; &amp;A::val4 &lt;&lt; &quot; &quot; &lt;&lt; A::val4 &lt;&lt; endl;    cout &lt;&lt; &quot;===&quot; &lt;&lt; endl;    int* p5 = (int*)&amp;val5;    //*p5 = 5555; // 编译不出错，运行会异常（常量区不能修改）    cout &lt;&lt; p5 &lt;&lt; &quot; &quot; &lt;&lt; *p5 &lt;&lt; endl;    cout &lt;&lt; &amp;val5 &lt;&lt; &quot; &quot; &lt;&lt; val5 &lt;&lt; endl;    cout &lt;&lt; &quot;===&quot; &lt;&lt; endl;    int* p6 = (int*)&amp;val6;    *p6 = 6666; // 全局数据区，但是不在常量区，可以修改    cout &lt;&lt; p6 &lt;&lt; &quot; &quot; &lt;&lt; *p6 &lt;&lt; endl;    cout &lt;&lt; &amp;val6 &lt;&lt; &quot; &quot; &lt;&lt; val6 &lt;&lt; endl;    return 0;&#125;\n输出结果：\n/*00EFFD98 1100EFFD98 1111===00EFFD80 222200EFFD80 2222===0027C038 33330027C038 3333===00279B38 4400279B38 44===00279B30 5500279B30 55===0027C03C 66660027C03C 6666*/\n\nC++内存分区\n参考\nC++：const常量的存储位置\nC&#x2F;C++的四大内存分区和常量的存储位置\n阿秀的笔记\n\n","tags":["C/C++"]},{"title":"Essential C++ note","url":"/2021/08/05/essential-C-note/","content":"\n记录本书（对我来说）的一些重点内容\n\n1 C++编程基础\n初始化方法：构造函数法（constructor syntax）\n\nint var(66);int var2&#123;66&#125;; // ok\n\n\nsrand()随机数种子；rand()则产生一个介于0和int所能表示的最大整数；需包含头文件cstdlib\ncerr（standard error）代表标准错误设备，与cout唯一区别就是不带缓冲，立即显示于用户终端\n\n2 面向过程的编程风格\n使用模板，则声明与定义要放在一起\n函数指针\n\n// 给函数指针赋初值const vector&lt;int&gt;* (*seq_str)(int) = 0;// seq_array是个数组，内放函数指针const vector&lt;int&gt;* (*seq_array[])(int) = &#123;    fibon_seq, lucas_seq, pell_seq,    triang_seq, square_seq, pent_seq&#125;\n\n\ninline函数的声明和定义都需要放在头文件，声明和定义有一个标明inline即可（在类定义中实现则默认是inline）；其他的函数，则必须是**“定义放在程序代码文件”、“声明放在头文件”**\n多文件共享变量\n\n/*    变量只能定义一次，但是可以声明多次    假定main.cpp func.cpp func.h三个文件    1. 在func.cpp有一个int a=1;如果要在main.cpp中使用，要在func.h或main.cpp中写extern int a；    2. const object和inline函数一样，是“一次定义”规则下的例外。const object定义只要一出文件外就       不可见（意味着可以在多个程序代码中加以定义）。因此如果const int a=1想多文件共享，可以直接写       在func.h中，其他的非const object则不可。       可参考：https://www.icode9.com/content-1-915590.html*/\n\n3 泛型编程风格\nlist不支持iterator的偏移运算（+、-）但是有++和–\n对于标准容器，不确保目标空间大小，可使用iterator inserter用插入操作替代赋值操作\n&lt;这章挺多东西，需要结合书本去看&gt;\n\n4 基于对象的编程风格\n如果有必要为某个class编写[拷贝构造]，则同样有必要为它编写[赋值操作]\n没有一个const reference class参数可以调用公开接口中的non-const成分\n类中的变量声明为mutable，标明其不会破坏对象的常量性（constness），即可在const函数中可以修改它\n当定义class的static function时，不可加上关键字static（同理静态成员变量）\n当类中有静态成员变量时，需要及时在类外进行初始化，否则报错：无法解析的外部命令\n通常情况：operator*无参表示解引用；有参表示乘法\nfriend声明可以出现在类定义任意位置，不受public或private影响\n嵌套类型（Nested Type），类中可以定义嵌套类型，再用域解析符（例如每个STL容器类都有自己的iterator）\n重载iostream（看书）\n类的函数指针：\n\nvoid (num_sequence::*pm)(int) = 0;// 如果决定上面一行复杂可以写成：typedef void (num_sequence::*PtrType)(int);PtrType pm = 0;// 成员函数取址要加上class scope限定符和&amp;取地址运算符（不同于一般函数，都不可以省！）PtrType pm = &amp;num_sequence::fibonaci;// 调用，由此要引出pointer to member selection运算符“.*”和&quot;-&gt;*&quot;(ns.*pm)(pos)(pns-&gt;*pm)(pos)\n\n5 面向对象编程风格\n纯虚函数：将虚函数赋值为0\n\nvirtual void gen_elems(int pos) = 0;\n\n\n任何类声明了纯虚函数，那么由于其接口不完整（无定义），程序无法为其产生实体。这种类只能作为派生类的子对象使用，而且前提是这些派生类为所有虚函数提供确切的定义。\n一般规则：凡基类定义了虚函数，则destructor也要声明为virtual\n一般而言，对象的拷贝构造函数开发者如果未提供，则编译器会自动生成默认的拷贝构造函数。然而以下情况默认的拷贝构造函数会被删除：\n\n/*    1、存在非静态的const成员变量    2、存在非静态的引用成员变量    3、存在不能拷贝的成员变量    4、存在不能拷贝的基类    5、存在用户定义的移动构造函数或移动赋值函数*/\n\n\n在基类的constructor中，派生类的虚函数不允许被调用\nstatic_cast和dynamic_cast，前者无条件转换，后者判断（比如基类的指针是否真的指向了该派生类）是否可以转换为目的类型再进行转换\n\n6 以template进行编程\n函数传入一个指针，只能改变指针所指对象的内容，要想改变指针本身（指向）就要传递reference to pointer\n\nBTnode*&amp; prev // 可以看成BTnode* &amp;prev 或 ((BTnode*)&amp;) prev\n\n\n模板类声明友元的问题：\n\n// 下面代码直接运行会报错：无法解析的外部命令\n\ntemplate &lt;typename T&gt;class A &#123;public:    A(T t):dy(t) &#123;&#125;    T dy;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&lt;T&gt;&amp; b);private:    void func(ostream&amp; os) const&#123;        os &lt;&lt; dy &lt;&lt; endl;    &#125;&#125;;template &lt;typename T&gt;ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&lt;T&gt;&amp; b) &#123;    b.func(os);    return os;&#125;int main() &#123;    A&lt;double&gt; a(4.2);    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n/*    原因：    因为&quot;operator&lt;&lt;&quot;这个函数的参数T不应该依赖于class的模板参数，友元本来是可以访问类的所有数据成员的(该模板类的int、double、string对象)，你这样依赖的话，放到外部表名该参数T是属于类内部本身，解决方案是为了更好的支持友元，我们一般单独给友元一个模板参数    1、类中友元声明改为（意义不明不过能用，但是其下绿波浪线提示函数未定义）（不推荐）    friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; os, const A&lt;T&gt;&amp; b);    2、类中友元声明改为（S不同于T）（推荐）    template &lt;typename S&gt;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&lt;S&gt;&amp; b);*/\n\n\n非类型参数\n\n/*    1、这类参数在模板内部都是常量值    2、只允许传入整形、指针和引用这三类    3、调用非类型参数的实参必须为常量表达式（必须在编译时能计算出结果的）*/\n\n7 异常处理\n重新抛出时，只需写下关键字throw即可。它只能出现于catch子句中\n局部资源管理，在易发生异常后释放资源是一件风险很大的事情。虽然可以通过try catch处理，但是释放资源的代码要出现两次，不好。这就引出了resource acquisition is initialization(RAII)策略，即初始化阶段进行资源请求。说人话就是，在构造函数中请求所有资源，在析构函数中释放所有资源：C++保证，在异常处理机制终结某个函数之前，所有局部对象的destructor都会被调用。或者使用智能指针例如：unique_ptr、shared_ptr等。\nptext &#x3D; new vector; 经过以下几个步骤（异常出现，余下不会执行，会沿着调用链抛出）\n\n/*    // 可能会reorder哦~    1、分配足够的空间    2、将vector&lt;string&gt; default constructor应用于heap对象之上    3、将对象地址设置给ptext*/\n\n\n\n\n\n","tags":["C/C++"]},{"title":"二分变种","url":"/2022/03/21/%E4%BA%8C%E5%88%86%E5%8F%98%E7%A7%8D/","content":"540 有序数组中的单一元素我的二分\n与右侧配对失败:\n右侧是奇数: l = m + 1\n右侧是偶数: r = m\n\n\n与右侧配对成功:\n右侧是奇数: l = m + 2\n右侧是偶数: r = m - 1\n\n\n\nclass Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size()-1;        while(l &lt; r)&#123; // 这样可以放心取m+1不越界            int m = (l + r) &gt;&gt; 1;            if(nums[m] != nums[m+1])&#123;                if((r-m) &amp; 1) l = m + 1;                else r = m;            &#125;else&#123;                if((r-m-1) &amp; 1) l = m + 2;                else r = m - 1;            &#125;        &#125;        return nums[l];    &#125;&#125;;\n\n官方的全数组二分查找\n假设要找的是数字X，则在X左边的数，下标是偶数的都是重复数字的第一位，下标是奇数的都是重复数字的第二位；在X右边的数，下标是奇数的都是重复数字的第一位，下标是偶数的都是重复数字的第二位；\n取中值时，若m是偶数，则尝试与m+1比较是否相等，相等则表明[:m+1]正常，X在m+1的右侧，因此l = m + 2；若不相等，则X在[:m]，因此r = m\n取中值时，若m是奇数，则尝试与m-1比较是否相等，相等则表明[:m]正常，X在m的右侧，因此l = m + 1；若不相等，则X在[:m]，因此r = m\n\nclass Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size() - 1;        while (l &lt; r) &#123;            int m = (l + r) &gt;&gt; 1;            if((m &amp; 1) &amp;&amp; nums[m] == nums[m-1])&#123; // 奇数                l = m + 1;            &#125;else if(!(m &amp; 1) &amp;&amp; nums[m] == nums[m+1])&#123; // 偶数                l = m + 2;            &#125;else&#123;                r = m;            &#125;        &#125;        return nums[l];    &#125;&#125;;\n\n\n上述思想可以在代码层面进行简化m ^ 1，对于偶数表示m + 1；对于奇数表示m - 1，同时照顾到短板，每次更新l时，有l = m + 1\n\nclass Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size() - 1;        while (l &lt; r) &#123;            int m = (l + r) &gt;&gt; 1;            if (nums[m] == nums[m ^ 1]) &#123; // 这是技巧                l = m + 1;            &#125;else&#123;                r = m;            &#125;        &#125;        return nums[l];    &#125;&#125;;\n\n官方的偶数范围二分查找\nX的下标一定是偶数\n\nclass Solution &#123;public:    int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size()-1;        while (l &lt; r) &#123;            int m = (r - l) / 2 + l;            m -= m &amp; 1; // 变为偶数            if (nums[m] == nums[m + 1]) &#123; // [...m+1]都ok                l = m + 2;            &#125; else &#123;                r = m;            &#125;        &#125;        return nums[l];    &#125;&#125;;\n","tags":["算法","特殊"]},{"title":"二叉树最大和","url":"/2022/03/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"1. 124 二叉树中的最大路径和1.1 两个递归的笨方法class Solution &#123;public:    int ans = INT_MIN;    int core(TreeNode* root) &#123; // 找到以root为起点，深入向下的最大路径一条线（分叉只走一条）        if(!root) return 0;        int lv = core(root-&gt;left);        int rv = core(root-&gt;right);        int res = max(max(lv, rv), 0) + root-&gt;val;        return res;    &#125;        void recursion(TreeNode* root)&#123; // 遍历树中每个结点，尝试寻找本题答案的“起点根”        if(!root) return;        recursion(root-&gt;left);        recursion(root-&gt;right);        int lv = core(root-&gt;left); // 以左孩子为起点的“线”        int rv = core(root-&gt;right); // 以右孩子为起点的“线”        if(lv &lt; 0) lv = 0;        if(rv &lt; 0) rv = 0;        ans = max(ans, lv + rv + root-&gt;val);    &#125;        int maxPathSum(TreeNode* root) &#123;        recursion(root);        return ans;    &#125;&#125;;\n\n1.2 一个递归的好方法class Solution &#123;public:    int ans = INT_MIN;    int core(TreeNode* root) &#123;        if(!root) return 0;                // 递归计算左右子节点的最大贡献值        // 只有在最大贡献值大于 0 时，才会选取对应子节点        int lv = max(core(root-&gt;left), 0);        int rv = max(core(root-&gt;right), 0);                // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值        int ifAnsRoot = root-&gt;val + lv + rv;        ans = max(ans, ifAnsRoot);                // 返回        return max(lv, rv) + root-&gt;val;    &#125;        int maxPathSum(TreeNode* root) &#123;        core(root);        return ans;    &#125;&#125;;\n\n2. 543 二叉树的直径这些问题都有共性：递归主线依旧，所求是副产物2.1 两个递归的笨方法class Solution &#123;public:    int core(TreeNode* root)&#123;        if(!root) return 0;        int l = core(root-&gt;left);        int r = core(root-&gt;right);        return max(l, r) + 1;    &#125;        int diameterOfBinaryTree(TreeNode* root) &#123;        if(!root) return 0;        int l = diameterOfBinaryTree(root-&gt;left);        int r = diameterOfBinaryTree(root-&gt;right);        int m = core(root-&gt;left) + core(root-&gt;right);        return max(m, max(l, r));    &#125;&#125;;\n\n2.2 一个递归的好方法// 递归主线还是算高度，直径是 [副产品]class Solution &#123;public:    int res = 0;    int core(TreeNode* root)&#123; // 给定根节点，计算最长深度节点数        if(!root) return 0;        int l = core(root-&gt;left); // 左儿子为根的子树的深度        int r = core(root-&gt;right); // 右儿子为根的子树的深度        res = max(res, l + r); // 在这里更新res，不用+1，因为路径长度是总结点长度-1        return max(l, r) + 1; // 返回该节点为根的子树的最长深度节点数    &#125;        int diameterOfBinaryTree(TreeNode* root) &#123;        if(!root) return 0;        core(root);        return res;    &#125;&#125;;","tags":["算法","树"]},{"title":"右值引用详解","url":"/2022/04/08/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/","content":"问题\n临时对象非必要的昂贵的拷贝操作\n在模板函数中如何按照参数的实际类型进行转发\n\n\n关键字：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义、完美转发\n以下用四条代码来阐述C++的右值引用及其思想\n\n1. 第一行代码int i = getVal();\n\n上式代码会产生一个左值和纯右值，右值是不具名的，判断左值和右值的办法就是看能否取地址\n在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。\n\n2. 第二行代码2.1 特点1：重获新生T getVal()&#123;    return T();&#125;T k = getVal();     // F1T&amp;&amp; k = getVal();   // F2\n\nF1：调用一次默认构造、两次拷贝构造（一次函数内到函数外的临时值，一次临时值到k）\nF2：调用一次默认构造、一次拷贝构造（一次函数内到函数外的临时值，并且临时值通过右值引用重获新生）\n现代编译器进行了优化，可能仅仅调用一次默认构造，但这不是C++标准\n当然在C++98&#x2F;03年代，为了相同的目的，可以用常量左值引用这种万能引用：const T&amp; k = getVal();，也能达到减少一次拷贝构造的目的，但是k不能再改变了。\n\n2.2 特点2：右值引用“二相性”\n右值引用独立于左值和右值，即，右值引用类型的变量可能是左值也可能是右值，例如：\n\nint&amp;&amp; val = 1;\n\nval类型为右值引用，但val本身是左值，所有具名变量都是左值\n\ntemplate&lt;typename T&gt;void f(T&amp;&amp; t)&#123;&#125;f(10); // t是右值 T&amp;&amp; t = 10int x = 10;f(x);  // t是左值 (T&amp;)&amp;&amp; t = x，折叠后变为T&amp; t = x;\n\n2.3 特点3：通用引用(universal references)\nT&amp;&amp; t在发生自动类型推断的时候，它是通用引用类型\n通用引用是需要初始化的，如果是左值，那就归为左值引用，如果是右值，那就归为右值引用。\n\n// 注意上述关键词：&quot;发生自动类型推断&quot;时int a = 1;auto&amp;&amp; b = a;  // b类型为左值引用 (int&amp;)&amp;&amp; b -&gt; int&amp; b = aauto&amp;&amp; c = 10; // c类型为右值引用 int&amp;&amp; b = 10\n\n引用折叠\n所有的右值引用叠加到右值引用上仍然还是一个右值引用\n类型 T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;\n\n\n所有的其他引用类型之间的叠加都将变成左值引用\nT&amp; &amp;、T&amp; &amp;&amp; 和 T&amp;&amp; &amp; 都会折叠成类型 T&amp;\n\n\n\n3. 第三行代码MyClass(MyClass&amp;&amp; a) : m_val(a.m_val) &#123; a.m_val=nullptr; &#125;\n\n即，移动构造函数(move constructor)，采用浅拷贝的方式，因为某些临时变量如果没有移动构造函数，则会频繁发生拷贝构造（深拷贝），如果对象内部堆空间很大的话，代价会非常大\n这里介绍move语句，move语句会将一个左值变为一个右值类型。move(val)后，并不会对val本身做出改变。类似上面的代码，将move(val)交给一个构造函数或者一个赋值函数，那么会按照右值类型匹配对应的移动构造函数和移动赋值函数，在移动函数里会将val的资源指针交给别人，val自身资源指针指向nullptr，这个时候val才会发生改变（你在代码里move(val)一百次，但是不交给对应函数匹配处理，那么val就不会有一丁点的变化）。当然，这些操作别人已经实现好了，如果是你自己的类，要自己实现！\n\n4. 第四行代码template &lt;typename T&gt;void f(T&amp;&amp; val)&#123;     foo(std::forward&lt;T&gt;(val));&#125;\n\n4.1 C++11前，调用模板函数的问题template &lt;typename T&gt;void forwardValue(T&amp;&amp; val)&#123;    processValue(val); // 右值参数会变成左值传递给processValue&#125;\n\n因此引入了完美转发std::forward，他会按照参数的实际类型进行转发\n\nvoid processValue(int&amp; a)&#123; cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl; &#125;void processValue(int&amp;&amp; a)&#123; cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl; &#125;template &lt;typename T&gt;void forwardValue(T&amp;&amp; val)&#123;    // 照参数本来的类型进行转发。    processValue(std::forward&lt;T&gt;(val)); &#125;void Testdelcl()&#123;    int i = 0;    forwardValue(i); // 传入左值 输出：lvaue     forwardValue(0); // 传入右值 暑促和：rvalue&#125;\n\nT&amp;&amp;是一个通用引用(universal references)，可以接受左值或者右值，正是这个特性让他适合作为一个参数的路由，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。\n\n4.2 进一步体会完美转发4.2.1 问题\nfunc函数接收的v2是引用，但是引用的却是middle里面的一个局部变量t2，而非main中的t2，应该怎么办？\n\ntemplate &lt;typename F, typename T1, typename T2&gt;void middle(F f, T1 t1, T2 t2) &#123;    f(t1, t2);&#125;void func(int v1, int&amp; v2) &#123;  // v2 是一个引用    ++v1;    ++v2;&#125;int main(int argc, char* argv[]) &#123;    int i = 0;    func(42, i);    // here i = 1    middle(func, 42, i);    // here i = 1&#125;\n\n4.2.2 尝试\nmiddle中t1类型是int&amp;&amp;，t2类型是int&amp; &amp;&amp; -&gt; int&amp;，i的值也如预期般变化\n\ntemplate &lt;typename F, typename T1, typename T2&gt;void middle(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(t1, t2);&#125;void func(int v1, int&amp; v2) &#123;  // v2 是一个引用    ++v1;    ++v2;&#125;int main(int argc, char* argv[]) &#123;    int i = 0;    func(42, i);    // here i = 1    middle(func, 42, i);    // here i = 2&#125;\n\n虽然看似没毛病，但是我们改一下func，就会暴露问题，修改func如下：\n\nvoid func(int&amp;&amp; v1, int&amp; v2) &#123;    ++v1;    ++v2;&#125;\n\n修改func后再用4.2.2的代码运行就会报错，提示：“无法将一个右值引用绑定到左值上”，why？因为，在main中42虽然是右值，传入到middle后t1的类型也确实是int&amp;&amp;，但是t1本身作为具名变量，它是一个左值！而左值是无法与右值进行绑定的。\n\n4.2.3 解决template &lt;typename F, typename T1, typename T2&gt;void middle(F f, T1&amp;&amp; t1, T2&amp;&amp; t2) &#123;    f(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));&#125;\n\nforward就是解决以上问题的关键\n42传入middle后绑定到t1，此时t1类型是int&amp;&amp;（其中T1是int）。通过forward&lt;T1&gt;(t1) -&gt; forward&lt;int&gt;(t1)，将返回int&amp;&amp;成功传给func函数。这里你肯定有疑问，刚才不就是int&amp;&amp;？你绕一大圈子是不是耍人？其实不然，之前的那个啊叫named rvalue，有名字，传参时被当成左值！现在通过forward返回的是无名字的真正的右值，从而右值得到了保留！\ni传入middle后绑定到t2，此时t2类型为int&amp; &amp;&amp;（其中T2是int&amp;，why？因为T2如果是int，那么就变成int&amp;&amp; t2 = i，会导致右值绑定一个左值从而报错！）经过引用折叠变为int&amp;.通过forward&lt;T2&gt;(t2) -&gt; forward&lt;int&amp;&gt;(t2)，将返回一个int&amp; &amp;，折叠后变为int&amp;，左值也得到了保留！\n\n4.3 应用：泛型工厂函数利用forward可以实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：\ntemplate&lt;typename…  Args&gt;T* Instance(Args&amp;&amp;… args)&#123;    return new T(std::forward&lt;Args &gt;(args)…);&#125;\n\n这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。\n\n参考资料\n博客园qicosmos(江南)\nDong’s Blog\n\n","tags":["C/C++"]},{"title":"十大排序总结","url":"/2022/04/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","content":"一、简单排序1. 冒泡排序\n时间复杂度：O(N^2)\n空间复杂度：O(1)\n稳定\n\nvoid bubbleSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    for (int i = 0; i &lt; n - 1; ++i) &#123;        for (int j = 0; j &lt; n - 1 - i; ++j) &#123;            if (arr[j] &gt; arr[j + 1]) swap(arr[j], arr[j + 1]);        &#125;    &#125;&#125;\n\n2. 选择排序\n时间复杂度：O(N^2)\n空间复杂度：O(1)\n不稳定（是不是以为(arr[j] &gt; arr[pos])改为&gt;=就变成稳定的了？那看一下3, 2, 1, 2。所以若想选择排序稳定，需要开辟新的数组空间；或者进行大量移动位置操作；或者是对链表排序）\n\nvoid selectSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    for (int i = 0; i &lt; n - 1; ++i) &#123;        int pos = 0;        for (int j = 1; j &lt; n - i; ++j) &#123;            if (arr[j] &gt; arr[pos]) pos = j;        &#125;        swap(arr[pos], arr[n - i - 1]);    &#125;&#125;\n\n3. 插入排序\n时间复杂度：O(N^2)\n空间复杂度：O(1)\n稳定\n\nvoid insertSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    for (int i = 1; i &lt; n; ++i) &#123;        int cur = arr[i];        int j = i - 1;        for (; j &gt;= 0 &amp;&amp; arr[j] &gt; cur; --j)            arr[j + 1] = arr[j];        arr[j + 1] = cur;    &#125;&#125;\n\n二、高级排序4. 希尔排序\n时间复杂度：O(N^(4&#x2F;3~3&#x2F;2))复杂度非常难以估算\n空间复杂度：O(1)\n不稳定\n下面两个实现都一样，唯一区别就是插入排序外循环里面i增加的形式，第一种分开实现，第二种合并了\n\n4.1 实现1void shellSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了    static vector&lt;int&gt; incre = &#123; 1023, 511, 255, 127, 63, 31, 15, 7, 3, 1 &#125;;    for (int u = 0; u &lt;incre.size(); ++u) &#123; // 增量循环        int width = incre[u];        if (width &gt; n) continue;        for (int v = 0; v &lt; width; ++v) &#123; // 当前增量循环            for (int i = width + v; i &lt; n; i += width) &#123; // 插入排序外循环                int cur = arr[i];                int j = i - width;                for (; j &gt;= 0 &amp;&amp; arr[j] &gt; cur; j -= width) // 插入排序内循环                    arr[j + width] = arr[j];                arr[j + width] = cur;            &#125;        &#125;    &#125;&#125;\n\n4.2 实现2（浙大陈姥姥代码）void shellSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了    static vector&lt;int&gt; incre = &#123; 1023, 511, 255, 127, 63, 31, 15, 7, 3, 1 &#125;;    for (int u = 0; u &lt; incre.size(); ++u) &#123; // 增量循环        int width = incre[u];        for (int i = width; i &lt; n; ++i) &#123; // 插入排序外循环            int cur = arr[i];            int j = i - width;            for (; j &gt;= 0 &amp;&amp; arr[j] &gt; cur; j -= width) // 插入排序内循环                arr[j + width] = arr[j];            arr[j + width] = cur;        &#125;    &#125;&#125;\n\n5. 堆排序\n时间复杂度：O(NlogN)\n空间复杂度：O(1)\n不稳定\n\nvoid downMethod(vector&lt;int&gt;&amp; arr, int f, int sz) &#123;    int s = f * 2 + 1;    int cur = arr[f];    while(s &lt; sz)&#123;        if (s + 1 &lt; sz &amp;&amp; arr[s] &lt; arr[s + 1]) // 兄弟值大，让位            ++s;        if (arr[s] &lt;= cur) break; // 父亲值大，镇压        arr[f] = arr[s]; // 儿子值大，禅位        f = s; // 下一代的父亲        s = f * 2 + 1; // 下一代的儿子    &#125;    arr[f] = cur;&#125;void heapSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    // 数组形成堆    for (int p = (n - 2) / 2; p &gt;= 0; --p)        downMethod(arr, p, n);    // 堆首尾交换进行排序    for (int p = n-1; p &gt; 0; --p) &#123;        swap(arr[0], arr[p]);        downMethod(arr, 0, p);    &#125;&#125;\n\n6. 归并排序\n时间复杂度：O(NlogN)\n空间复杂度：O(N)\n稳定\n\n6.1 递归版本// [l, m] [m+1, r]void mergeTwoArray(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l, int m, int r) &#123;    int i = l, j = m + 1, k = l;    while (i &lt;= m || j &lt;= r) &#123; // k &lt;= r 一样        int a = i &lt;= m ? arr[i] : INT_MAX;        int b = j &lt;= r ? arr[j] : INT_MAX;        if (a &lt; b) ++i; // 每次i和j只能有一个增加        else ++j;        trr[k++] = a &lt; b ? a : b;    &#125;    while (l &lt;= r) &#123; // 拷贝回去        arr[l] = trr[l];        ++l;    &#125;&#125;void mergeRecursion(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l, int r) &#123;    if (l == r) return;    int m = l + ((r - l) &gt;&gt; 1);    mergeRecursion(arr, trr, l, m);    mergeRecursion(arr, trr, m + 1, r);    mergeTwoArray(arr, trr, l, m, r);&#125;void mergeSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    vector&lt;int&gt; trr(arr); // 避免频繁创建子数组    mergeRecursion(arr, trr, 0, n - 1);&#125;\n\n6.2 非递归版本// [l, m] [m+1, r]void mergeTwoArray(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l, int m, int r) &#123;    int i = l, j = m + 1, k = l;    while (i &lt;= m || j &lt;= r) &#123; // k &lt;= r 一样        int a = i &lt;= m ? arr[i] : INT_MAX;        int b = j &lt;= r ? arr[j] : INT_MAX;        if (a &lt; b) ++i; // 每次i和j只能有一个增加        else ++j;        trr[k++] = a &lt; b ? a : b;    &#125;    // 不用拷贝回去...&#125;void mergeSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    int range = 1; // 半径    vector&lt;int&gt; trr(arr); // 避免频繁创建子数组    while (range &lt; n) &#123;        for (int i = 0; i &lt; n; i += range*2) &#123; // arr -&gt; trr            int m = i + range - 1;            if (m &gt;= n - 1) m = n - 1; // 不能break            int r = i + range * 2 - 1;            if (r &gt;= n - 1) r = n - 1;            mergeTwoArray(arr, trr, i, m, r); // arr-&gt;trr        &#125;        range &lt;&lt;= 1;        for (int i = 0; i &lt; n; i += range*2) &#123; // trr -&gt; arr            int m = i + range - 1;            if (m &gt;= n - 1) m = n - 1; // 不能break            int r = i + range * 2 - 1;            if (r &gt;= n - 1) r = n - 1;            mergeTwoArray(trr, arr, i, m, r); // trr-&gt;arr        &#125;        range &lt;&lt;= 1;    &#125;&#125;\n\n7. 快速排序\n时间复杂度：O(NlogN)\n空间复杂度：栈上O(logN)\n不稳定\n注意1：遇到l和r指向相等时，需要交换，不然遇到全1的数组，退化为n^2\n注意2：快排在数据范围较小时（r-l&lt;threshold）直接使用插入排序可有效优化速度\n\n7.1 实现1（朴素版）void quickRecursion(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    if (l &gt;= r) return;    int oldl = l, oldr = r;    // 选 [枢纽]    int pivot = arr[l];    // 排序    ++r;    while (l &lt; r) &#123;        while (l &lt; r &amp;&amp; arr[--r] &gt; pivot); // 右侧先动是安全的        while (l &lt; r &amp;&amp; arr[++l] &lt; pivot); // 左侧后动        if (l &lt; r) swap(arr[l], arr[r]);    &#125;    swap(arr[oldl], arr[l]);    quickRecursion(arr, oldl, r - 1);    quickRecursion(arr, r + 1, oldr);&#125;void quickSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    quickRecursion(arr, 0, n - 1);&#125;\n\n7.2 实现2（改进朴素版）int pivot = arr[l];// 改为int randomPos = l + rand()%(r-l+1);swap(arr[l], arr[randomPos]);int pivot = arr[l];\n\n7.3 实现3（中间值枢纽）// 三数选中间数并将最小值放在l，最大值放在r，中间值(pivot)放在l+1// 陈姥姥代码里是放在r-1的，这样肯定正确因为m肯定&lt;r// 我为了兼容朴素版的大部分代码，选择放在l+1，这样由于m可能等于l，所以需要多一次特殊点判断int median3(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    int m = l + ((r - l) &gt;&gt; 1);    if (arr[l] &gt; arr[m])        swap(arr[l], arr[m]);    if (arr[l] &gt; arr[r])        swap(arr[l], arr[r]);    if (arr[m] &gt; arr[r])        swap(arr[m], arr[r]);    if (l == m) return arr[l]; // 特殊点    swap(arr[m], arr[l + 1]);    return arr[l + 1];&#125;void quickRecursion(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    if (l &gt;= r) return;    int oldl = l, oldr = r;    // 选 [枢纽]    int pivot = median3(arr, l, r);    // 排序    ++l; // 注意：两端收缩了一位    while (l &lt; r) &#123;        while (l &lt; r &amp;&amp; arr[--r] &gt; pivot); // 右侧先动是安全的        while (l &lt; r &amp;&amp; arr[++l] &lt; pivot); // 左侧后动        if (l &lt; r) swap(arr[l], arr[r]);    &#125;    swap(arr[oldl + 1], arr[l]); // 注意：pivot枢纽放在了l+1位置    quickRecursion(arr, oldl, r - 1);    quickRecursion(arr, r + 1, oldr);&#125;void quickSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    quickRecursion(arr, 0, n - 1);&#125;\n\n7.4 实现4（有限制）虽然代码看起来很简洁，但是有如下问题：\n\n极端情况会退化为n^2算法\n正因如此，在我的实验中，对3w个分布0~99的数字排序，会栈溢出（异常结束，main函数return 非0）。其实前面的方法里，移动i和j时如果&gt;改为&gt;=、&lt;改为&lt;=也会出现这种问题哦。因此在数据分布较窄时，这种方法无疑是低效的\n\nvoid quickRecursion(vector&lt;int&gt;&amp; arr, int l, int r) &#123;    if (l &gt;= r) return;    // 选 [枢纽] 可改进随机化但效果还是差    int pivot = arr[l];    // 排序    int j = l;    for (int i = l + 1; i &lt;= r; ++i) &#123;        if (arr[i] &lt; pivot) &#123;            ++j;            swap(arr[i], arr[j]);        &#125;    &#125;    swap(arr[j], arr[l]);    quickRecursion(arr, l, j - 1);    quickRecursion(arr, j + 1, r);&#125;void quickSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    quickRecursion(arr, 0, n - 1);&#125;\n\n三、特殊排序8. 计数排序\n时间复杂度：O(B+N)，B是数据范围一般较小，可认为是O(N)\n空间复杂度：栈上O(B+N) -&gt; O(N)\n稳定（实现的不好则不稳定，比如从前往后填）\n\nvoid countingSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    int maxV = INT_MIN;    for (auto&amp; e : arr) maxV = maxV &gt; e ? maxV : e;    vector&lt;int&gt; counting(maxV + 1); // 计数数组    vector&lt;int&gt; trr(arr); // 留作中转拷贝    for (auto&amp; e : arr) ++counting[e]; // 计数    for (int i = 1; i &lt; counting.size(); ++i) // 累加计数        counting[i] = counting[i - 1] + counting[i];    for (int i = n - 1; i &gt;= 0; --i) &#123; // 从后向前填：稳定的排序        int pos = --counting[arr[i]];        trr[pos] = arr[i];    &#125;    for (int i = 0; i &lt; n; ++i) // 拷回去        arr[i] = trr[i];&#125;\n\n9. 基数排序\n时间复杂度：O(Rs * N)，Rs是数据最大值的位数一般较小，可认为是O(N)\n空间复杂度：栈上O(10 + N) -&gt; O(N)\n稳定（实现的不好则不稳定，比如从前往后填）\n经常利用计数排序实现\n\n9.1 LSD基数排序\n最低位优先(Least Significant Digit first, LSD)，先排低位；再排高位\n由于每一位介于0~9，所以对每一个基位排序时都可看做是分为10个桶的桶排序\n\n// 获得一个int的某一位的数字// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 int getRadix(int num, int r) &#123;    static int radices[] = &#123; 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 &#125;;    num %= radices[r + 1];    return num / radices[r];&#125;void radixSortLSD(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    int maxV = INT_MIN;    for (auto&amp; e : arr) maxV = maxV &gt; e ? maxV : e;    int radixNum = 0;    while (maxV) &#123;        ++radixNum;        maxV /= 10;    &#125;    vector&lt;int&gt; trr(arr); // 留作中转拷贝    for (int r = 0; r &lt; radixNum; ++r) &#123;        vector&lt;int&gt; counting(10); // 计数数组        for (auto&amp; e : arr) ++counting[getRadix(e, r)]; // 计数        for (int i = 1; i &lt; counting.size(); ++i) // 累加计数            counting[i] = counting[i - 1] + counting[i];        for (int i = n - 1; i &gt;= 0; --i) &#123;            int pos = --counting[getRadix(arr[i], r)];            trr[pos] = arr[i];        &#125;        for (int i = 0; i &lt; n; ++i) // 拷回去            arr[i] = trr[i];    &#125;&#125;\n\n9.2 MSD基数排序\n最高位优先(Most Significant Digit first, MSD)，先排高位；再排低位\nMSD一般采用递归写法：按高位分组，形成连续区段，然后在区段内递归处理低一位\n\n// 获得一个int的某一位的数字// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 int getRadix(int num, int r) &#123;    static int radices[] = &#123; 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 &#125;;    num %= radices[r + 1];    return num / radices[r];&#125;void radixRecursion(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l, int r, int d) &#123;    if (l &gt;= r || d &lt; 0) return;    vector&lt;int&gt; counting(10);    for (int i = l; i &lt;= r; ++i)         ++counting[getRadix(arr[i], d)]; // l~r 计数    for (int i = 1; i &lt; counting.size(); ++i)         counting[i] = counting[i - 1] + counting[i]; // 累加计数    for (int i = r; i &gt;= l; --i) &#123;        int pos = --counting[getRadix(arr[i], d)] + l; // + l 偏移别忘了        trr[pos] = arr[i];    &#125;    for (int i = l; i &lt;= r; ++i) // 拷回去        arr[i] = trr[i];    for (int i = 0; i &lt; 10; ++i) &#123;        if (i == 0) radixRecursion(arr, trr, l, l + counting[0] - 1, d - 1);        else radixRecursion(arr, trr, l + counting[i - 1], l + counting[i] - 1, d - 1);    &#125;&#125;void radixSortMSD(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    int maxV = INT_MIN;    for (auto&amp; e : arr) maxV = maxV &gt; e ? maxV : e;    int radixNum = 0;    while (maxV) &#123;        ++radixNum;        maxV /= 10;    &#125;    vector&lt;int&gt; trr(arr); // 留作中转拷贝    radixRecursion(arr, trr, 0, n - 1, radixNum-1);&#125;\n\n10. 桶排序\n桶排序的时间复杂度和空间复杂度以及是不是稳定都看你采取的子排序算法\n桶排序一般用于数据分布均匀的\n桶排序用于遏制N^2、NlogN等复杂度的算法因数据量太大而带来的速度问题\n\nvoid insertSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    for (int i = 1; i &lt; n; ++i) &#123;        int cur = arr[i];        int j = i - 1;        for (; j &gt;= 0 &amp;&amp; arr[j] &gt; cur; --j)            arr[j + 1] = arr[j];        arr[j + 1] = cur;    &#125;&#125;void bucketSort(vector&lt;int&gt;&amp; arr) &#123;    int n = arr.size();    int maxV = INT_MIN;    for (auto&amp; e : arr) maxV = maxV &gt; e ? maxV : e;    ++maxV;    int bckNum = 10; // 分十个桶    vector&lt;vector&lt;int&gt;&gt; buckets(bckNum, vector&lt;int&gt;());    for (auto&amp; e : arr) &#123;        int pos = e * 10 / maxV;        buckets[pos].push_back(e); // 放进桶里    &#125;    for (auto&amp; b : buckets) &#123; // 随意选取排序算法        insertSort(b);    &#125;    int k = 0;    for (int i = 0; i &lt; buckets.size(); ++i)        for (int j = 0; j &lt; buckets[i].size(); ++j)            arr[k++] = buckets[i][j]; // 从桶里面拿出来&#125;\n\n四、辅助代码\n获取数据、判断排序合格、显示已排序frontN等\n\n#pragma once#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;fstream&gt;#include &lt;string&gt;using namespace std;class Data&#123;public:    Data(string fn, int _n) : arr(_n) &#123;        fstream file;        file.open(fn, ios::in);        if (!file) &#123;            throw string(&quot;ERROR!&quot;);        &#125;        for (auto&amp; e : arr)            file &gt;&gt; e;        file.close();    &#125;    vector&lt;int&gt;&amp;&amp; getData() &#123; return move(arr); &#125;private:    vector&lt;int&gt; arr;&#125;;bool isSorted(vector&lt;int&gt;&amp; arr) &#123;    for (int i = 1; i &lt; arr.size(); ++i)        if (arr[i] &lt; arr[i - 1]) return false;    return true;&#125;void showFrontN(vector&lt;int&gt;&amp; arr, int n) &#123;    n = n &gt; arr.size() ? arr.size() : n;    for (int i = 0; i &lt; n;) &#123;        int cnt = 0;        for (; cnt &lt; 10 &amp;&amp; i + cnt &lt; n; ++cnt) // 每行十列显示            cout &lt;&lt; arr[i + cnt] &lt;&lt; &quot;\\t&quot;;        cout &lt;&lt; endl;        i += cnt;    &#125;&#125;\nint main() &#123;    Data dataGenerator(&quot;Data.txt&quot;, 1000);    vector&lt;int&gt; arr = dataGenerator.getData();    // yourSort(arr);    showFrontN(arr, 100);    if (isSorted(arr)) cout &lt;&lt; &quot;排序完成&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;排序出错&quot; &lt;&lt; endl;    return 0;&#125;","tags":["算法","排序"]},{"title":"子集组合排列","url":"/2022/03/20/%E5%AD%90%E9%9B%86%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97/","content":"零. 子集、组合和排列问题汇总\n组合问题和子集问题是等价的\n参考labuladong和优秀题解\n\n一. 子集问题78 子集划分1.1 子集扩张class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty())            return vector&lt;vector&lt;int&gt;&gt;(1, vector&lt;int&gt;());        int last = nums.back(); nums.pop_back();        vector&lt;vector&lt;int&gt;&gt; sub = subsets(nums);        int sz = sub.size();        for(int i=0; i&lt;sz; ++i)&#123;            vector&lt;int&gt; tmp = sub[i];            tmp.push_back(last);            sub.push_back(tmp);        &#125;        return sub;    &#125;&#125;;\n\n1.2 回溯1class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void traceback(vector&lt;int&gt;&amp; nums, int pos)&#123;        if(pos == nums.size())&#123;            ret.push_back(cur);            return;        &#125;        // 选        cur.push_back(nums[pos]);        traceback(nums, pos+1);        cur.pop_back();                // 不选        traceback(nums, pos+1);    &#125;        vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        traceback(nums, 0);        return ret;    &#125;&#125;;\n\n1.3 回溯2(★)class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void traceback(vector&lt;int&gt;&amp; nums, int pos)&#123;        ret.push_back(cur);        for(int i=pos; i&lt;nums.size(); ++i)&#123;            cur.push_back(nums[i]);            traceback(nums, i+1);            cur.pop_back();        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;        traceback(nums, 0);        return ret;    &#125;&#125;;\n\n90 子集划分Ⅱ\n两条值相同的相邻树枝会产生重复，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历（不能让队员越权）\n“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。 我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。（注意：这里的同一树层指的是由同一个父节点引出的子节点，叔伯的子节点可以用相同下一个值，比如下图[1]接2和[2]接2，都可以用2；但是[1]接2就不能接2’了！）\n\n\n2.1 回溯1class Solution &#123;public:    vector&lt;int&gt; cur;    vector&lt;vector&lt;int&gt;&gt; ret;    void traceback(bool choosePre, int pos, vector&lt;int&gt; &amp;nums) &#123;        if (pos == nums.size()) &#123;            ret.push_back(t);            return;        &#125;        // 不选        traceback(false, cur + 1, nums);                // 要在 [选] 之前执行，要在 [不选] 之后执行        if (!choosePre &amp;&amp; pos &gt; 0 &amp;&amp; nums[pos - 1] == nums[pos]) return;                // 选        cur.push_back(nums[pos]);        traceback(true, pos + 1, nums);        cur.pop_back();    &#125;    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt; &amp;nums) &#123;        sort(nums.begin(), nums.end());        traceback(false, 0, nums);        return ret;    &#125;&#125;;\n\n2.2 回溯2(★)class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, int pos)&#123;        ret.push_back(cur);        for(int i=pos; i&lt;nums.size(); ++i)&#123;            // i从pos开始，天然可以判定同一父节点的子节点们不会重复            // 即只让重复段的第一个节点的树向下生长            // 如果i从0开始，无法确定pos-1位置是否使用过，需要            // 借助一个used数组            if(i &gt; pos &amp;&amp; nums[i] == nums[i-1]) continue;            cur.push_back(nums[i]);            backtrack(nums, i+1);            cur.pop_back();        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end()); // 要排序        backtrack(nums, 0);        return ret;    &#125;&#125;;\n\n2.3 回溯2（易读版利用used判断树层重复）也可用used数组来简化理解，nums[i]与nums[i-1]相等，且nums[i-1]没有使用的情况下，表明重复了，因为只有在nums[i-1]用过之后才会不用，而nums[i-1]之前用过，其后的子树是已经加入到结果了，即可跳过当前点\nclass Solution &#123;private:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtracking(vector&lt;int&gt;&amp; nums, int pos, vector&lt;bool&gt;&amp; used) &#123;        ret.push_back(cur);        for (int i = pos; i &lt; nums.size(); i++) &#123;            // used[i-1] == true，说明同一树支nums[i-1]使用过            // used[i-1] == false，说明同一树层nums[i-1]使用过            // 而我们要对同一树层使用过的元素进行跳过            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i-1]) continue;            used[i] = true;            cur.push_back(nums[i]);            backtracking(nums, i + 1, used);            cur.pop_back();            used[i] = false;        &#125;    &#125;public:    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;bool&gt; used(nums.size(), false);        sort(nums.begin(), nums.end()); // 去重需要排序        backtracking(nums, 0, used);        return ret;    &#125;&#125;;\n\n二. 组合问题39 组合总数1.1 回溯nums中的每个数字可以多次使用\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, int pos, int target)&#123;        if(target &lt;= 0)&#123;            if(target == 0) ret.push_back(cur);            return;        &#125;        for(int i=pos; i&lt;nums.size(); ++i)&#123;            cur.push_back(nums[i]);            backtrack(nums, i, target-nums[i]); // 依旧传入i            cur.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; nums, int target) &#123;        backtrack(nums, 0, target);        return ret;    &#125;&#125;;\n\n2. 40 组合总数Ⅱnums中的每个数字在每个组合中只能使用一次 &amp;&amp; 解集不能包含重复的组合。\n说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 candidates 中所有和为 target 的子集。\n2.1 回溯1class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, int pos, int target, bool preUsed)&#123;        if(target &lt; 0) return;        if(target == 0)&#123;            ret.push_back(cur);            return;        &#125;        if(pos &gt;= nums.size()) return; // 不能放前面        if(nums[pos] &gt; target) return; // 剪枝：当前和后面的不可能会选                // 不选        backtrack(nums, pos+1, target, false);                if(pos&gt;0 &amp;&amp; nums[pos-1] == nums[pos] &amp;&amp; !preUsed) return;                // 选        cur.push_back(nums[pos]);        backtrack(nums, pos+1, target - nums[pos], true);        cur.pop_back();    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(), nums.end());        backtrack(nums, 0, target, false);        return ret;    &#125;&#125;;\n\n2.2 回溯2(★)class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, int pos, int target)&#123;        if(target == 0)&#123;            ret.push_back(cur);            return;        &#125;        for(int i=pos; i&lt;nums.size(); ++i)&#123;            if(i&gt;pos &amp;&amp; nums[i-1] == nums[i]) continue; // 值相同的树枝，只遍历第一条，防止重复            if(target &lt; nums[i]) return; // 剪枝：当前和后面的不可能会选            cur.push_back(nums[i]);            backtrack(nums, i+1, target-nums[i]);            cur.pop_back();        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(), nums.end());        backtrack(nums, 0, target);        return ret;    &#125;&#125;;\n\n\n三. 排列问题1. 46 全排列不含重复数字的数组：nums，经典回溯\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used)&#123;        if(cur.size() == nums.size())&#123;            ret.push_back(cur);            return;        &#125;        for(int i=0; i&lt;nums.size(); ++i)&#123;            if(used[i]) continue;            used[i] = true;            cur.push_back(nums[i]);            backtrack(nums, used);            cur.pop_back();            used[i] = false;        &#125;    &#125;    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;bool&gt; used(nums.size(), false);        backtrack(nums, used);        return ret;    &#125;&#125;;\n\n2. 47 全排列Ⅱ含有重复数字的数组：nums\n2.1 哈希（有意思）class Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; res;        void traceback(map&lt;int, int&gt;&amp; hash, vector&lt;int&gt;&amp; cur, int n)&#123;        if(cur.size() == n)&#123;            res.push_back(cur);            return;        &#125;        for(map&lt;int, int&gt;::iterator itr=hash.begin(); itr!=hash.end(); ++itr)&#123;            if(itr-&gt;second)&#123;                --itr-&gt;second;                cur.push_back(itr-&gt;first);                traceback(hash, cur, n);                cur.pop_back();                ++itr-&gt;second;            &#125;        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        map&lt;int, int&gt; hash;        vector&lt;int&gt; cur;        for(auto e: nums) ++hash[e];        traceback(hash, cur, nums.size());        return res;    &#125;&#125;;\n\n2.2 回溯(跟子集问题2.3很像)当出现重复元素时，比如输入 nums &#x3D; [1,2,2’,2’’]，2’ 只有在 2 已经被使用的情况下才会被选择，2’’ 只有在 2’ 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; ret;    vector&lt;int&gt; cur;    void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used)&#123;        if(cur.size() == nums.size())&#123;            ret.push_back(cur);            return;        &#125;        for(int i=0; i&lt;nums.size(); ++i)&#123;            // i从0开始，固定相同的元素在排列中的相对位置            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1]) continue;            if(used[i]) continue;            used[i] = true;            cur.push_back(nums[i]);            backtrack(nums, used);            cur.pop_back();            used[i] = false;        &#125;    &#125;        vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end()); // 必须排序        vector&lt;bool&gt; used(nums.size(), false);        backtrack(nums, used);        return ret;    &#125;&#125;;","tags":["算法"]},{"title":"带限制的最短路","url":"/2022/09/07/%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF/","content":"带限制的最短路\n错误示例（Dijkstra）全局的dist记录着最短距离，但它并未记录是几跳获得的。例如，到达终点的前一跳，从X-&gt;dst，我的代码中只限制了到达X最多k+1跳，此时更新了dist[X]，当更新到dst时，利用的dist[X]是经过k跳的X作为跳板，则结果是经过了k+2跳，超出了限制，因此结果必然是错误的。\nclass Item &#123;public:    int node, skip, dis;    Item(int a, int b, int c):node(a),skip(b),dis(c)&#123;&#125;    bool operator&gt;(const Item&amp; R) const &#123;        return this-&gt;dis &gt; R.dis;    &#125;&#125;;class Solution &#123;public:    int INF = 0x3f3f3f3f;    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n);        for (auto&amp; e : flights) g[e[0]].push_back(&#123; e[1], e[2] &#125;);        vector&lt;int&gt; dist(n, INF);        dist[src] = 0;        priority_queue&lt;Item, vector&lt;Item&gt;, greater&lt;Item&gt;&gt; pq;        pq.emplace(src, 0, 0);        while (!pq.empty()) &#123;            auto cur = pq.top(); pq.pop();            int node = cur.node;            int dis = cur.dis;            int skip = cur.skip;            if (skip &gt; k) continue;            for (auto&amp; e : g[node]) &#123;                int w_node = e.first;                int w_weight = e.second;                if (dist[w_node] &gt; dist[node] + w_weight) &#123;                    dist[w_node] = dist[node] + w_weight;                    pq.emplace(w_node, skip + 1, dist[w_node]);                &#125;            &#125;        &#125;        return dist[dst];    &#125;&#125;;\n\n再次尝试Dijkstra（完全没必要）需要扔掉dist，在自定义的结构体中保存dis的值，另外，每次出堆的元素的邻接节点不用判断，全部加入堆。\n值得注意的是，由于k的限制存在，堆在这道题完全没有作用，反而会有副作用：\n\n假如，题目要求k&#x3D;0，并且答案经过的这条直接相邻的边权值巨高，则堆会将该方法引向歧途\n抑或是k的限制，根本不存在答案，需要返回-1，但是由于不加判断，堆会不停进元素，导致死循环\n\nclass Item &#123;public:    int node, skip, dis;    Item(int a, int b, int c):node(a),skip(b),dis(c)&#123;&#125;    bool operator&gt;(const Item&amp; R) const &#123;        return this-&gt;dis &gt; R.dis;    &#125;&#125;;class Solution &#123;public:    int INF = 0x3f3f3f3f;    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n);        for (auto&amp; e : flights) g[e[0]].push_back(&#123; e[1], e[2] &#125;);        priority_queue&lt;Item, vector&lt;Item&gt;, greater&lt;Item&gt;&gt; pq;        pq.emplace(src, 0, 0);        while (!pq.empty()) &#123;            auto cur = pq.top(); pq.pop();            int node = cur.node;            int dis = cur.dis;            int skip = cur.skip;            if (node == dst) return dis;            if (skip &gt; k) continue;            for (auto&amp; e : g[node]) &#123;                int w_node = e.first;                int w_weight = e.second;                // 不管，全部加入队列                pq.emplace(w_node, skip + 1, dis + w_weight);            &#125;        &#125;        return -1;    &#125;&#125;;\n\nbellman(邻接矩阵)Bellman Ford 核心操作需要遍历所有的边\nclass Solution &#123;public:    int INF = 0x3f3f3f3f;    int bf(vector&lt;vector&lt;int&gt;&gt;&amp; g, int src, int dst, int k) &#123;        int n = g.size();        vector&lt;int&gt; dist(g.size(), INF);        dist[src] = 0;        while (k--) &#123;            vector&lt;int&gt; tmp(dist);            for (int i = 0; i &lt; n; ++i) &#123;                for (int j = 0; j &lt; n; ++j) &#123;                    dist[j] = min(dist[j], tmp[i] + g[i][j]);                &#125;            &#125;        &#125;        return dist[dst];    &#125;    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;        vector&lt;vector&lt;int&gt;&gt; g(n, vector&lt;int&gt;(n, INF));        for (int i = 0; i &lt; n; ++i) g[i][i] = 0;        for (auto&amp; e : flights) g[e[0]][e[1]] = e[2];        int ret = bf(g, src, dst, k+1);        return ret == INF ? -1 : ret;    &#125;&#125;;\n\nbellman(flights本身就是边)class Solution &#123;public:    int INF = 0x3f3f3f3f;    int bf(vector&lt;vector&lt;int&gt;&gt;&amp; edg, int src, int dst, int k) &#123;        int n = edg.size();        vector&lt;int&gt; dist(edg.size(), INF);        dist[src] = 0;        while (k--) &#123;            vector&lt;int&gt; tmp(dist);            for (int i = 0; i &lt; n; ++i) &#123;                for (auto&amp; e : edg) &#123;                    int x = e[0], y = e[1], w = e[2];                    dist[y] = min(dist[y], tmp[x] + w);                &#125;            &#125;        &#125;        return dist[dst];    &#125;    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;        int ret = bf(flights, src, dst, k+1);        return ret == INF ? -1 : ret;    &#125;&#125;;\n\nBFSclass Solution &#123;public:    int INF = 0x3f3f3f3f;    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) &#123;        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g(n);        for (auto&amp; e : flights) g[e[0]].push_back(&#123; e[1], e[2] &#125;);        vector&lt;int&gt; dist(n, INF);        queue&lt;int&gt; q;        q.push(src);        dist[src] = 0;        while (!q.empty() &amp;&amp; k-- &gt;= 0) &#123;            int sz = q.size();            vector&lt;int&gt; tmp(dist); // 保留上一时刻的快照            for (int i = 0; i &lt; sz; ++i) &#123;                int cur = q.front(); q.pop();                for (auto&amp; w : g[cur]) &#123;                    if (dist[w.first] &gt; tmp[cur] + w.second) &#123; // dist!                        dist[w.first] = tmp[cur] + w.second;                        q.push(w.first); // 放到if里面（发生更新时才添加元素）                    &#125;                &#125;            &#125;        &#125;        return dist[dst] == INF ? -1 : dist[dst];    &#125;&#125;;\n","tags":["算法","图"]},{"title":"字符串匹配","url":"/2022/04/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","content":"BF(Brute Force)算法\nBF是最符合人类直觉的字符串匹配算法，但是主串的下标i经常要往回走，无法利用已匹配信息，效率不够好\n\nint bruteForce(const string&amp; t, const string&amp; p) &#123;    int i = 0, j = 0;    // i和j都是非负数，所以可以和无符号直接比较    while (i &lt; t.size() &amp;&amp; j &lt; p.size()) &#123;        if (t[i] == p[j]) &#123;            ++i; ++j;        &#125; else &#123;            i = i - j + 1;            j = 0;        &#125;    &#125;    if (j == p.size())        return i - j;    else        return -1;&#125;\n\nKMP算法\n思想：“利用已部分匹配的信息，保持i指针不回溯，通过修改j指针，让模式串尽量移动到有效的位置”\n定义next数组： next[j] = d 表示当 t[i] != p[j] 时，j下一次匹配的位置。注意到，下标从0开始，d值实际上是下标j前的最长前后缀子串的长度\n求取next的过程本身就是p串与自己匹配的过程\n当 p[i]==p[j] ，则 p[++i] = ++j\n当 p[i]!=p[j] ，则利用前面已求得的next数组，j=next[j] ；直到无法找到，此时 j=-1 ，自动进入第一个if语句，此时i往后走一步，妙\n\n\n\nvector&lt;int&gt; getNext(const string&amp; p) &#123;    int n = p.size();    vector&lt;int&gt; next(n);    next[0] = -1;    int i = 0, j = -1;    // !!! i &lt; n 则会在下面越界，因为0已经求过了，循环只会进行n-1次    while (i &lt; n - 1) &#123;        if (j == -1 || p[i] == p[j]) &#123;            ++i, ++j;            next[i] = j;        &#125; else &#123;            j = next[j];        &#125;    &#125;    return next;&#125;int KMP(const string&amp; t, const string&amp; p) &#123;    vector&lt;int&gt; next = getNext(p);    int n = t.size(), m = p.size();    int i = 0, j = 0;    // !!! j可以为负数，和无符号比较会转换为无符号比较法(南辕北辙)    while (i &lt; n &amp;&amp; j &lt; m) &#123;        if (j == -1 || t[i] == p[j]) &#123;            ++i; ++j;        &#125; else &#123;            j = next[j];        &#125;    &#125;    if (j == p.size())        return i - j;    else        return -1;&#125;\n\nKMP之Next优化\n比如[ A B A B ]这个串，按照上面所述KMP得到的结果是[-1, 0, 0, 1]，然而，例如匹配的是[ A B A B D E]，在下标为3处失败了，next指导去下标1处继续匹配，但是，下标1和下标3都是B，没有必要再进行比较了。诸如此类的例子还有[ A A A A B]，用上述KMP得到的next是[-1, 0, 1, 2, 3]\n方法就是在 ++i, ++j 后加一步判断，本来直接 next[i]=j 但是如果 p[i]==p[j] 则如果以后匹配 p[i] 失败，则匹配 p[j] 肯定也失败啊，所以如果两者相等，直接 next[i] = next[j] 。此时的结果对于[ A B A B ]产生的是[-1, 0, -1, 0]；对于[ A A A A B]产生的是[-1, -1, -1, -1, 3]\n加三行代码就行了\n\nvector&lt;int&gt; getNext(const string&amp; p) &#123;    int n = p.size();    vector&lt;int&gt; next(n);    next[0] = -1;    int i = 0, j = -1;    while (i &lt; n - 1) &#123;        if (j == -1 || p[i] == p[j]) &#123;            ++i, ++j;            if (p[i] == p[j]) // new                 next[i] = next[j]; // new             else // new                next[i] = j;        &#125;        else &#123;            j = next[j];        &#125;    &#125;    return next;&#125;int KMP(const string&amp; t, const string&amp; p) &#123;    vector&lt;int&gt; next = getNext(p);    int n = t.size(), m = p.size();    int i = 0, j = 0;    while (i &lt; n &amp;&amp; j &lt; m) &#123;        if (j == -1 || t[i] == p[j]) &#123;            ++i; ++j;        &#125;        else &#123;            j = next[j];        &#125;    &#125;    if (j == p.size())        return i - j;    else        return -1;&#125;\n\n参考资料\n博客园博主：sofu6\n\n","tags":["算法","特殊"]},{"title":"数据库小知识（持续更新）","url":"/2022/05/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%8F%E7%9F%A5%E8%AF%86%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"1. 缓存雪崩：布隆过滤器(1970)、分布式锁\n比如说双十一某宝，redis缓存中key大面积失效，导致某宝直接和数据库进行沟通，把请求直接打到数据库解决方法：\n\n随机初始化缓存失效时间，让其不要在同一时间失效\nredis一般都是集群部署，我们把热点key放到不同的节点上去，让热点的缓存平均的分布在不同的redis节点上\n最暴力的方法：不设置缓存的失效时间，让它永远不失效，或者跑定时任务，让它定时刷这个缓存让其不失效\n\n2. 缓存穿透：指缓存与数据库中都没有所要请求的数据：比如请求id&#x3D;-1的数据，redis没有，直接打到数据库，数据库返回空。大量的这种请求导致数据库繁忙（数据库的主键从0开始递增，没有负数）解决方法：\n\n每次无论数据库查出什么结果，是空还是有值，都会缓存到redis里面。\n把对面IP拉黑\n对参数合法性做检测\n使用布隆过滤器（好方法）\n\n3. 缓存击穿：比如说某宝，某个商品秒杀(该key事先存入redis缓存)，大量用户抢购，但是某时刻该redis缓存到达失效时间失效了，一瞬间大量该key的请求打到数据库上\n\n让这个缓存永远不过期（不好）\n分布式锁：失效时某个查询数据库，然后加锁，其他的查询就不能查询数据库了，就先睡几毫米然后重新去redis里面查（好方法，实现方式有互斥锁、zookeeper、redis）\n（雪崩是多key失效，击穿是单key）\n\n4. 布隆过滤器插入时利用多个hash函数映射到一串二进制数组中，从0置1；查询时，多个hash对应的二进制位置必须都是1才能证明该数据存在\n改造加强版：布谷鸟过滤器\n优点：\n\n二进制数组组成的数据，占用空间很小\n插入和查询的速度很快\n保密性很好\n\n缺点：\n\n很难做删除操作\n存在误判的情况（解决不了，只能减少出现的概率）\n\n存在就再去查一次数据库，误判也没关系；但不存在，那就是真的不存在。性能也比每次都查询数据库好得多。\n代码中可以设置误判率，但是设置太小，性能速度就变得太差了（要增大布隆过滤器二进制数组的大小以及要采用更多的hash函数）\n5. 索引如何查到真实数据的InnoDB是聚簇索引（即将索引和数据放在一个文件里）MyISAM是非聚簇索引\ninnodb\n主索引树和辅助索引树\n主索引树：以主键id位key，叶子节点直接存储数据记录（一行）\n\n辅助索引树：例如select * from user_info where user_name = &#39;Jim&#39;会创建以user_name为key的索引树。其叶子节点存储的是主键key，拿到key后再去主索引树去查找相应的数据（即，回表查询）\nMyISAM无论是主键索引还是普通索引，查找数据的流程都是一样的，叶子节点存储的是数据的物理地址，拿到地址后再去内存或磁盘获得数据\n延伸话题1、为什么不要使用select *，而是尽量用覆盖索引\n6. 索引为什么会失效索引失效主要针对联合索引。联合索引在B+树上的排序是按照字典序，即第一个字段、第二个字段…比如说(a, b)，只有a相同下，b才是有序的；如果a有多个值，那b基本上就无序了(1, 1)(1, 2)(1, 3)(1, 4)(2, 1)(2, 2)(2, 3)(2, 4)...\n最佳左前缀法则EXPLAIN SELECT * from test_user where a = 1 and b = 1\n范围查找的右边它索引会失效：EXPLAIN SELECT * from test_user where a&gt;1 and b=1\nlike会失效EXPLAIN SELECT * from test_user where a like &quot;1%&quot;\n\n“1%”: 查找以1开头的数据\n“%1”: 查找以1结尾的数据\n“%1%”: 查找任意位置有1的数据\n\n7. 为什么采用B+树索引hash索引：\n虽然单次的访问很快，但是是无序的，如果采用hash索引的话，无法进行范围查找以及排序操作\n存在hash碰撞问题，速度就慢下来了。\n\n平衡二叉树索引：\n随着树深增加，查找速度逐渐变慢\n致命缺点：每次都是一个一个查找，不好进行范围查找\n\nB树索引：\n虽然解决了树高问题，但是依旧不好进行范围查找（优点一个结点多放几个值，树可以变矮，虽然有内部查找，即一个节点内进行顺序查找的情况存在，但是内部可以理解为内存比较，不同节点可以理解为磁盘IO，内存比较就可以忽略不计了！）\n\nB+树索引：\n解决了范围查找问题\n最下层 [叶子节点] 采用链表的方式顺序排序，上面的 [非叶子节点] 只存储索引key，不存储数据value，因此也不会浪费很多空间，[叶子结点] 既存key也存value(数据地址)\n排序的时候要使用索引排序，因为已经排序好了，按照索引排序就不会产生文件的排序\n\n","tags":["Others"]},{"title":"并查集","url":"/2022/05/23/%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"并查集\n一般用于快速判断两个元素是否同属于一个集合\n数组形式表示树结构\n插入元素会被映射到从0开始的顺序整数中\n\n实现技巧\n路径压缩：在find时，通过递归并返回找到的祖宗节点并赋值，可以达成find后降低树高的功效\n按秩归并：在unite时，其中一方会挂在另一方的门下，所以希望“小的挂到大的上面”，以此来产生结果高度更小的树，有两种方式：\n高度：树高：S[Root]&#x3D;-树高，代码多一步判断：即：两个树相同高度时，增加树高\n数目（推荐）：S[Root]&#x3D;-元素个数。子孙节点数目，可以通过利用根节点来达成，根节点之前是-1，现在改为-n，其中n是包含根节点的整个树的节点数目\n\n\n\nLC.990class UF &#123;public:    UF(int _n) :count(_n), parent(_n, -1) &#123;&#125;    int getCount() &#123; return count; &#125;    bool isConnected(int a, int b) &#123;        int class1 = find(a);        int class2 = find(b);        return class1 == class2;    &#125;    void unite(int a, int b) &#123;        int class1 = find(a);        int class2 = find(b);        if (class1 == class2)            return;        if (parent[class1] &lt; parent[class2]) &#123; // 按秩归并            parent[class1] += parent[class2];            parent[class2] = class1;        &#125;        else &#123;            parent[class2] += parent[class1];            parent[class1] = class2;        &#125;        --count;    &#125;private:    int find(int pos) &#123;        if (parent[pos] &lt; 0)            return pos;        return parent[pos] = find(parent[pos]); // 路径压缩    &#125;    int count;    vector&lt;int&gt; parent;&#125;;// leetcode 990class Solution &#123;public:    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;        UF a(26);        for (int i = 0; i &lt; equations.size(); i++) &#123;            if (equations[i][1] == &#x27;=&#x27;) &#123;                a.unite(equations[i][0] - 97, equations[i][3] - 97);            &#125;        &#125;        for (int i = 0; i &lt; equations.size(); i++) &#123;            if (equations[i][1] == &#x27;!&#x27;) &#123;                if (a.isConnected(equations[i][0] - 97, equations[i][3] - 97))                    return false;            &#125;        &#125;        return true;    &#125;&#125;;","tags":["算法","特殊","树"]},{"title":"字符串相乘","url":"/2022/03/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","content":"43 字符串相乘两数A位和B位，相加后位数最大为max(A, B)+1；相乘后最大位数为A+B\n1.1 常规法将两个串的指针位置m和n、进位c统一放入while循环，代码就会很优美。 代码可以继续优化速度存储：addtion函数改为原地相加，但是会破坏代码的逻辑性，就不改了。\nclass Solution &#123;public:    string addtion(string&amp; num1, string&amp; num2)&#123;        int m = num1.size()-1, n = num2.size()-1;        int c = 0;        string ret;        while(m&gt;=0 || n&gt;=0 || c)&#123;            int a = m&gt;=0 ? num1[m]-&#x27;0&#x27; : 0; // 越界定0技巧            int b = n&gt;=0 ? num2[n]-&#x27;0&#x27; : 0; // 越界定0技巧            int s = a + b + c;            ret.push_back(&#x27;0&#x27; + s % 10);            c = s / 10;            --m, --n;        &#125;        reverse(ret.begin(), ret.end()); // 反转        return ret;    &#125;        string multiply(string num1, string num2) &#123;        if(num1==&quot;0&quot; || num2==&quot;0&quot;) return &quot;0&quot;;        string res = &quot;0&quot;;        int cnt = 0; // 记录表示每次乘完左移的0的个数        int m = num2.size()-1;        while(m &gt;= 0)&#123;            int n = num1.size()-1;            int b = num2[m] - &#x27;0&#x27;;            int c = 0;            string ret(cnt, &#x27;0&#x27;); // 初始化&quot;左移&quot;0            while(n&gt;=0 || c)&#123;                int a = n&gt;=0 ? num1[n]-&#x27;0&#x27; : 0; // 越界定0技巧                int s = a * b + c;                ret.push_back(&#x27;0&#x27; + s % 10);                c = s / 10;                --n;            &#125;            reverse(ret.begin(), ret.end()); // 反转            res = addtion(res, ret);            --m, ++cnt;        &#125;        return res;    &#125;&#125;;\n\n1.2 优化竖式 (LC高赞)(很难想到啊)num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。\nclass Solution &#123;public:    string multiply(string num1, string num2) &#123;        if(num1 == &quot;0&quot; || num2 == &quot;0&quot;) return &quot;0&quot;;        int m = num1.size(), n = num2.size();        vector&lt;int&gt; temp(m+n, 0); // 数组哦        for(int i=m-1; i&gt;=0; --i)&#123;            for(int j=n-1; j&gt;=0; --j)&#123;                int cur = (num1[i]-&#x27;0&#x27;) * (num2[j]-&#x27;0&#x27;) + temp[i+j+1];                temp[i+j+1] = cur % 10; // 存储计算结果低位 =                temp[i+j] += cur / 10; // 存储计算结果高位 +=            &#125;        &#125;        string ret; ret.reserve(m+n);        int i = 0;        for(; i&lt;temp.size(); ++i) // 去掉前缀0            if(temp[i] != 0) break;        for(; i&lt;temp.size(); ++i) // 放入字符串            ret.push_back(char(temp[i] + &#x27;0&#x27;));        return ret;    &#125;&#125;;","tags":["算法"]},{"title":"数组指针与指针数组","url":"/2021/09/12/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","content":"数组指针和指针数组s的类型是二维数组，但是其本身也是一个一维指针（数组指针），其静态类型是char(*)[10]，每次移动是10个char长度也就是10字节。其解引用后静态类型是char*，每次移动是1个char长度也就是1字节。\n值得注意的是，类似函数指针，s、*s、&amp;s其值都是一样的，都是该二维数组首个元素的地址，因此不能将数组名当成是一个值为元素首地址的常规变量！因为永远无法取得其地址。\n因此，下面代码中将s赋值给双重指针ps是完全错误的；双重指针要经过两次间接跳转访问元素：比如ps的值为0x0000ff33，*ps首先跳转到该位置后取其值，比如说那个地址的值为0x0000eedd，将*ps当成字符串输出时，会再次跳转到地址为0x0000eedd的位置取出char，完全乱了。\n而作为对比，数组指针解引用不会跳转，只会修改其步幅跨度\nchar s[][10] = &#123; &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot; &#125;;char** ps = (char**)s;cout &lt;&lt; (decltype(*s))*ps &lt;&lt; endl;\t// OK 强行改变了类型cout &lt;&lt; *(char(*)[10])ps &lt;&lt; endl;\t// OK 强行改变了类型cout &lt;&lt; (char(&amp;)[10])*ps &lt;&lt; endl;\t// OK 强行改变了类型cout &lt;&lt; *ps &lt;&lt; endl;\t\t\t\t// ERROR! 两次跳转乱了\n\n这里s是一个指针数组(确定类型要从内而外，从右向左)，因此可以将其赋给双重指针，他们取char都要经过两次跳转。\nconst char* s[] = &#123; &quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot; &#125;;char** ps = (char**)s;cout &lt;&lt; *ps &lt;&lt; endl;\t// OK","tags":["C/C++"]},{"title":"拓扑排序和二分图","url":"/2022/09/12/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E5%9B%BE/","content":"1 拓扑排序（有向图）课程表Ⅱ1.1 BFS（易理解）创建一个表示入度的数组，初始将入度为0的节点加入队列，后续依次弹出队列，每次弹出node，减小node指向的节点的入度，入度为0的加入队列，直到队列为空，结果需要判定出队列的节点数和图的总节点数相同，不同则代表有循环\nclass Solution &#123;public:    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;vector&lt;int&gt;&gt; g(numCourses);        vector&lt;int&gt; inDegree(numCourses);        for (auto&amp; e : prerequisites) &#123;            g[e[1]].push_back(e[0]);            ++inDegree[e[0]];        &#125;        queue&lt;int&gt; q;        vector&lt;int&gt; ret;        for (int i = 0; i &lt; numCourses; ++i)            if (inDegree[i] == 0) q.push(i);        while (!q.empty()) &#123;            int node = q.front(); q.pop();            ret.push_back(node);            for (auto e : g[node]) &#123;                --inDegree[e];                if (inDegree[e] == 0)                    q.push(e);            &#125;        &#125;        return ret.size() == numCourses ? ret : vector&lt;int&gt;();    &#125;&#125;;\n\n1.2 DFS（递归）后序遍历的结果进行反转，就是拓扑排序的结果\n\n// visited防止重复处理节点// used用来判断成环class Solution &#123;public:    vector&lt;bool&gt; visited; // 不重置    vector&lt;bool&gt; used; // 每次递归，回溯重置    vector&lt;int&gt; postOrder; // 结果数组    // 判断有环，顺便记录下后序遍历的节点    bool isCircle(vector&lt;vector&lt;int&gt;&gt;&amp; g, int node) &#123;        if (used[node]) return true;        if (visited[node]) return false;        visited[node] = true;        used[node] = true;        for (auto e : g[node])            if (isCircle(g, e)) return true; // 有环直接返回        postOrder.push_back(node); // 后序遍历位置（递归后面）        used[node] = false;        return false;    &#125;    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;        vector&lt;vector&lt;int&gt;&gt; g(numCourses);        for (auto&amp; e : prerequisites) g[e[1]].push_back(e[0]);        visited.resize(numCourses, false);        used.resize(numCourses, false);        for (int i = 0; i &lt; numCourses; ++i)            if (isCircle(g, i)) return vector&lt;int&gt;(); // 有环直接返回        reverse(postOrder.begin(), postOrder.end()); // 最后反序很重要        return postOrder;    &#125;&#125;;\n\n2 二分图（无向图?）图的节点只有两种颜色：红和蓝，相同颜色不能相邻，判断是否是二分图，可有两种方法：DFS和BFS\n可能的二分法2.1 DFS注意visited不要重置\nclass Solution &#123;public:    vector&lt;bool&gt; visited;    vector&lt;bool&gt; color;    bool core(vector&lt;vector&lt;int&gt;&gt;&amp; g, int node) &#123;        visited[node] = true;        for (auto e : g[node]) &#123;            if (!visited[e]) &#123;                color[e] = !color[node];                if (core(g, e) == false)                    return false;            &#125;            else &#123;                if (color[e] == color[node])                    return false;            &#125;        &#125;        return true;    &#125;    bool possibleBipartition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) &#123;        vector&lt;vector&lt;int&gt;&gt; g(n + 1);        for (auto&amp; e : dislikes) &#123;            g[e[0]].push_back(e[1]);            g[e[1]].push_back(e[0]);        &#125;        visited.resize(n + 1, false);        color.resize(n + 1, false);        for (int i = 1; i &lt;= n; ++i) &#123;            if (visited[i]) continue;            if (core(g, i) == false) return false;        &#125;        return true;    &#125;&#125;;\n\n2.2 BFSclass Solution &#123;public:    vector&lt;bool&gt; visited;    vector&lt;bool&gt; color;    bool core(vector&lt;vector&lt;int&gt;&gt;&amp; g, int node) &#123;        queue&lt;int&gt; q;        q.push(node);        while (!q.empty()) &#123;            int cur = q.front(); q.pop();            visited[cur] = true;            for (auto e : g[cur]) &#123;                if (!visited[e]) &#123;                    color[e] = !color[cur];                    q.push(e);                &#125;                else &#123;                    if (color[e] == color[cur])                        return false;                &#125;            &#125;        &#125;        return true;    &#125;    bool possibleBipartition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) &#123;        vector&lt;vector&lt;int&gt;&gt; g(n + 1);        for (auto&amp; e : dislikes) &#123;            g[e[0]].push_back(e[1]);            g[e[1]].push_back(e[0]);        &#125;        visited.resize(n + 1, false);        color.resize(n + 1, false);        for (int i = 1; i &lt;= n; ++i) &#123;            if (visited[i]) continue;            if (core(g, i) == false) return false;        &#125;        return true;    &#125;&#125;;\n\n参考\n二分图判定算法\n环检测及拓扑排序算法\n\n","tags":["算法","特殊","排序","图"]},{"title":"最长有效括号","url":"/2022/03/19/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","content":"32 最长有效括号方法1：动态规划1.1 错误1无法解决诸如(())的问题。 要考虑到当前碰到右括号后，前面的是左括号还是右括号，然后分别进行处理\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n = s.size();        int l = 0;        vector&lt;int&gt; dp(n);        int ret = 0;        for(int i=0; i&lt;n; ++i)&#123;            if(s[i] == &#x27;(&#x27;)&#123;                ++l;                 continue;            &#125;            if(l)&#123;                --l;                dp[i] = 2;                if(i-2 &gt;= 0) dp[i] += dp[i-2]; // BUG                ret = max(ret, dp[i]);            &#125;        &#125;        return ret;    &#125;&#125;;\n\n1.2 错误2无法解决诸如()(())的问题。 \n\n*****() 好解决直接 dp[i] += dp[i-2];\n*****)) 需要额外判断找到与当前右括号i对应的左括号t，然后t的左边要继续判断\n\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n = s.size();        int l = 0;        vector&lt;int&gt; dp(n);        int ret = 0;        for(int i=0; i&lt;n; ++i)&#123;            if(s[i] == &#x27;(&#x27;)&#123;                ++l;                 continue;            &#125;            if(l)&#123;                --l;                dp[i] = 2;                if(s[i-1] == &#x27;(&#x27; &amp;&amp; i-2 &gt;= 0) dp[i] += dp[i-2];                else if(s[i-1] == &#x27;)&#x27;) dp[i] += dp[i-1]; // 这里要继续修改                ret = max(ret, dp[i]);            &#125;        &#125;        return ret;    &#125;&#125;;\n\n1.3 正确答案class Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n = s.size();        int l = 0;        vector&lt;int&gt; dp(n);        int ret = 0;        for(int i=0; i&lt;n; ++i)&#123;            if(s[i] == &#x27;(&#x27;)&#123;                ++l;                 continue;            &#125;            if(l)&#123;                --l;                dp[i] = 2;                if(s[i-1] == &#x27;(&#x27; &amp;&amp; i-2 &gt;= 0) dp[i] += dp[i-2];                else if(s[i-1] == &#x27;)&#x27;)&#123;                    dp[i] += dp[i-1];                    if(i-dp[i]&gt;=0) //添加这里                        dp[i] += dp[i-dp[i]];                &#125;                ret = max(ret, dp[i]);            &#125;        &#125;        return ret;    &#125;&#125;;\n\n1.4 官方的DP（LC官方）(Elegant)class Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n = s.size();        vector&lt;int&gt; dp(n, 0);        int res = 0;        for(int i=1; i&lt;n; ++i)&#123;            if(s[i] == &#x27;(&#x27;) continue;            // 只有以&#x27;)&#x27;结尾的才有效            if(s[i-1] == &#x27;(&#x27;)&#123;                if(i-2 &lt; 0) dp[i] = 2; // 防止越界                else dp[i] = dp[i-2] + 2; // 转移函数            &#125;else&#123;                if(i-dp[i-1]-1&gt;=0 &amp;&amp; s[i-dp[i-1]-1] == &#x27;(&#x27;)&#123;                    dp[i] = dp[i-1] + 2; // 转移函数                    if(i-dp[i-1]-2 &gt;= 0)                        dp[i] += dp[i-dp[i-1]-2];                &#125;            &#125;            res = max(res, dp[i]);        &#125;        return res;    &#125;&#125;;\n\n方法2：栈（LC官方）保持栈底元素为当前已经遍历过的元素中 「最后一个没有被匹配的右括号的下标」 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int n = s.size();        stack&lt;int&gt; stk;        stk.push(-1);        int res = 0;        for(int i=0; i&lt;n; ++i)&#123;            if(s[i] == &#x27;(&#x27;) stk.push(i);            else&#123;                stk.pop();                if(stk.empty()) // 更新「最后一个没有被匹配的右括号的下标」                    stk.push(i);                else                    res = max(res, i-stk.top()); // 以i结尾的有效性括号长度            &#125;        &#125;        return res;    &#125;&#125;;\n\n方法3：贪心（LC官方）利用两个计数器l和r，从左到右遍历字符串，遇到左括号则l加1，遇到右括号则r加1；当l和r相等时更新最长长度，当r&gt;l时将l和r置0\n这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。\n解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：当r&lt;l时将l和r置0。\n这样我们就能涵盖所有情况从而求解出答案。\nclass Solution &#123;public:    int longestValidParentheses(string s) &#123;        int l = 0, r = 0;        int res = 0;        for(int i=0; i&lt;s.size(); ++i)&#123;            if(s[i] == &#x27;(&#x27;) ++l;            else ++r;            if(l == r) res = max(res, l + r);            else if(r &gt; l) l = r = 0;        &#125;        l = r = 0; // 重置！        for(int i=s.size()-1; i&gt;=0; --i)&#123;            if(s[i] == &#x27;(&#x27;) ++l;            else ++r;            if(l == r) res = max(res, l + r);            else if(l &gt; r) l = r = 0;        &#125;        return res;    &#125;&#125;;","tags":["算法","动态规划"]},{"title":"旋转数组二分","url":"/2022/03/21/%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86/","content":"1 寻找峰值找到任意一个峰值，你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。\n1.1 二分法（不怎么优雅）class Solution &#123;public:    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size()-1;        while(l &lt;= r)&#123;            int m = (l + r) / 2;            if(m-1&gt;=0 &amp;&amp; nums[m-1]&gt;nums[m])                r = m - 1;            else if(m+1&lt;nums.size() &amp;&amp; nums[m+1]&gt;nums[m])                l = m + 1;            else                return m;        &#125;        return 0; // 永远不会走    &#125;&#125;;\n\n1.2 二分法（优雅）其实只要搞清楚我们「二分」什么内容，根本不会存在说用哪种方式才能写过的情况。\nclass Solution &#123;public:    int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size()-1;        while(l &lt; r)&#123;            int m = (l + r) &gt;&gt; 1;            // 这里m+1不会越界，因为l &lt;= m &lt; r，所以m-1是可能越界的，m+1必然不会越界            if(nums[m] &gt; nums[m+1])                r = m;  // 注意            else                l = m + 1;  // 注意        &#125;        return l;    &#125;&#125;;\n\n2 搜索旋转排序数组（无重复）2.1 二分法（有点丑，但好理解）class Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int n = nums.size(), l = 0, r = n - 1;        while(l &lt;= r)&#123;            int m = (l + r) &gt;&gt; 1;            if(nums[m] == target) return m;                        // 因为如果就俩数，除以二肯定l == m, r == m+1            if(nums[l] == nums[m])&#123;                if(r &lt; n &amp;&amp; nums[r] == target) return r;                else return -1;            &#125;            else if(nums[l] &lt; nums[m])&#123; // 左边正常                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[m])                     r = m - 1;                else                     l = m + 1;            &#125;            else&#123; // 右边正常                if(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])                    l = m + 1;                else                    r = m - 1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n2.2 二分法（优雅）（与l比较）\n牢记：左区间是[l, m]，右区间是(m+1, r]，所以“左区间正常”包含等号\n由于前一步 if(nums[m] == target) return m; 已经判定了nums[m] != target，所以后面对target和nums[m]的比较不带等号\n\nclass Solution &#123;public:    int search(vector&lt;int&gt;&amp; nums, int target) &#123;        int n = nums.size(), l = 0, r = n - 1;        while(l &lt;= r)&#123;            int m = (l + r) &gt;&gt; 1;            if(nums[m] == target) return m;            if(nums[l] &lt;= nums[m])&#123; // 左边正常                if(target &gt;= nums[l] &amp;&amp; target &lt; nums[m])                     r = m - 1;                else                     l = m + 1;            &#125;            else&#123; // 右边正常                if(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])                    l = m + 1;                else                    r = m - 1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n2022.08.10（与r比较）// while等号和不等号class Solution &#123;public:    int search(const vectorr&lt;int&gt;&amp; arr, int target) &#123;        int l = 0, r = arr.size() - 1;        while(l &lt; r)&#123;            int m = (l+r)/2;            if(arr[m] == target) return m;            if(arr[m] &lt; arr[r])&#123; // 右边正常（互不相同所以没等于）                if(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + 1;                else r = m - 1;            &#125;else&#123; // 左边正常                if(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - 1;                else l = m + 1;            &#125;        &#125;        return arr[l] == target ? l : -1;    &#125;&#125;;class Solution &#123;public:    int search(vector&lt;int&gt;&amp; arr, int target) &#123;        int l = 0, r = arr.size() - 1;        while(l &lt;= r)&#123;            int m = (l+r)/2;            if(arr[m] == target) return m;            if(arr[m] &lt; arr[r])&#123; // 右边正常（互不相同所以没等于）                if(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + 1;                else r = m - 1;            &#125;else&#123; // 左边正常                if(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - 1;                else l = m + 1;            &#125;        &#125;        return -1;    &#125;&#125;;\n\n3 寻找旋转排序数组中的最小值（无重复）\n3.1 二分法\n如上图所示，如果每次以nums[l] &lt; nums[m]为条件虽然可以认定左区间是单调的，但是就全局最小值而言无法区分图1和图2的；但是以nums[m] &lt; nums[r]可以认定右区间单调，且可以区分所有最小值情况。一定要理解二分时收缩区间的含义。\n不能动不动l = m + 1，r = m - 1这种大起大和的方式，因为目的是求极值而不是target，target不等于的时候，某一边确实可以跳；但是求极值时，例如下面代码中r = m，因为不确定nums[m]是不是极值，所以不能写成r = m - 1\n\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; nums) &#123;        int l = 0, r = nums.size()-1;        while(l &lt; r)&#123;            int m = (l + r) / 2;            if(nums[m] &lt; nums[r])                r = m; // 注意            else                l = m + 1;  // 注意        &#125;        return nums[l];    &#125;&#125;;\n\n\n为什么左右不对称？为什么比较mid与right而不比较mid与left？能不能通过比较mid与left来解决问题？左右不对称的原因是：这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。为什么比较mid与right而不比较mid与left？具体原因前面已经分析过了，简单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。那么能不能通过比较mid与left来解决问题？能，转换思路，不直接找最小值，而是先找最大值，最大值偏右，可以通过比较mid与left来找到最大值，最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）。\n\n4 寻找旋转排序数组中的最小值 II（有重复）4.1 二分由于相等时无法确认二分的方向，所以选择慎重地小幅度收缩1步\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; arr) &#123;        int l = 0, r = arr.size()-1;        while(l &lt; r)&#123;            int m = (l + r) / 2;            if(arr[m] &lt; arr[r]) r = m;            else if(arr[m] &gt; arr[r]) l = m + 1;            else --r;        &#125;        return arr[l];    &#125;&#125;;\n\n4.2 栈+二分由于相等时无法确认二分的方向，所以用栈保存下来可能的区间，留作继续二分\nclass Solution &#123;public:    int findMin(vector&lt;int&gt;&amp; arr) &#123;        stack&lt;int&gt; stk;        stk.push(0);        stk.push(arr.size()-1);        int l=0, r=0;        int res = 0x3f3f3f3f;        while(!stk.empty())&#123;            r = stk.top(); stk.pop();            l = stk.top(); stk.pop();            while(l &lt; r)&#123;                int m = (l + r) / 2;                if(arr[m] == arr[r])&#123;                    stk.push(l);                    stk.push(m-1);                    l = m + 1;                &#125;else if(arr[m] &lt; arr[r])&#123;                    r = m;                &#125;else if(arr[m] &gt; arr[r])&#123;                    l = m + 1;                &#125;            &#125;            if(l &lt;= r) // !                res = min(res, arr[r]);        &#125;        return res;    &#125;&#125;;","tags":["算法","特殊"]},{"title":"树状数组","url":"/2022/08/21/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","content":"需求\n随机修改数组中一个数字\n求前缀和\n以上操作需要频繁操作\n\n预备知识：lowbitlowbit指数字的二进制最低位1及后续0取出后的数字\nint lowbit(int a)&#123;    return a &amp; -a;&#125;\n例如:10：1010 &amp; 0110 = 0010，即10的lowbit为2。\n\n\n\nx\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\nlowbit(x)\n1\n2\n1\n4\n1\n2\n1\n8\n1\n2\n\n\n注意：0不存在lowbit，所以数组的下标需要右偏移一位（使用时偏移或初始化多1位）\n树状数组\n\ntarr从1开始，arr从0开始\n树状数组的每一个元素tarr[i]：其值为a[j]+...a[i-1]+a[i-1]，其中连加的项总共lowbit(i)个\n在树状数组中，为什么需要寻找其父节点？有两个用处：1、初始化树状数组。2、修改某个数同时修改其祖上一系列树状数组的值。对于tarr[i]而言，其直接父节点即为tarr[i + lowbit(i)]，通过这种方式逐步向上迭代，即可探寻祖上一条链\n对于给定数组：arr = [1,3,2,6,4,1]，可得其对应的树状数组：tarr = [1, 1+3, 2, 1+3+2+6, 4, 4+1] -&gt; [1, 4, 2, 12, 4, 5]\n求和时，例如sum(idx=13)\n先得到res += tarr[13]，随后idx -= lowbit(idx)，此时idx==12\n再得到res += tarr[12]，随后idx -= lowbit(12)，此时idx==8\n再得到res += tarr[8]，随后idx -= lowbit(8)，此时idx==0结束循环\n最终，res = tarr[13] + tarr[12] + tarr[8] = (arr[12]) + (arr[8]+...+arr[11]) + (arr[0]+...+arr[7])\n\n\n总之，对于树状数组tarr\nidx += lowbit(idx)是为了寻找祖上，修改和初始化用到\nidx -= lowbit(idx)是为了求和\n\n\n\n代码class TreeArr &#123;public:    TreeArr(vector&lt;int&gt; arr) :arr(arr), tarr(arr.size()+1) &#123;        // 初始化树状数组，arr中的每个元素被加到其祖上所有节点中        for (size_t i = 0; i &lt; arr.size(); ++i) &#123;            size_t idx = i + 1; // 偏移1位            while (idx &lt; tarr.size()) &#123;                tarr[idx] += arr[i];                idx += lowbit(idx);            &#125;        &#125;    &#125;    void update(int i, int val) &#123;        int diff = val - arr[i];        size_t idx = i + 1;        // 修改时也要修改其祖上所有节点 + lowbit(idx)        while (idx &lt; tarr.size()) &#123;            tarr[idx] += diff;            idx += lowbit(idx);        &#125;        arr[i] = val; // 勿忘    &#125;    int getSum(int i) &#123;        int idx = i + 1;        int res = 0;        // 求和时则是 - lowbit(idx)        while (idx &gt; 0) &#123;            res += tarr[idx];            idx -= lowbit(idx);        &#125;        return res;    &#125;    int getRange(int l, int r) &#123;        return getSum(r) - getSum(l - 1); //!    &#125;    static int lowbit(int a) &#123;        return a &amp; -a;    &#125;private:    vector&lt;int&gt; arr;    vector&lt;int&gt; tarr;&#125;;\n\n参考\n什么是树状数组？让这个12岁年轻人为你讲解\n数据结构：树状数组\n307. 区域和检索 - 数组可修改\n剑指 Offer 51. 数组中的逆序对\n315. 计算右侧小于当前元素的个数\n\n","tags":["算法","特殊","树"]},{"title":"最长子序列子数组","url":"/2022/03/20/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E6%95%B0%E7%BB%84/","content":"1143 最长公共子序列\n子序列是可以不连续的\ndp[i][j]的含义是text1[:i]和text2[:j]最长公共子序列，这个最长公共子序列不一定包含text1[i]和text2[j]\n\nclass Solution &#123;public:    int longestCommonSubsequence(string text1, string text2) &#123;        int m = text1.size(), n = text2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); // 多一行一列        for(int i=1; i&lt;=m; ++i)&#123;            for(int j=1; j&lt;=n; ++j)&#123;                if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; // 别忘了坐标偏移                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);            &#125;        &#125;        return dp[m][n];    &#125;&#125;;\n\n718 最长重复子数组\n子数组是连续的\ndp[i][j]的含义是以nums1[i]结尾的nums1[:i]和以nums2[j]结尾的nums2[:j]的最长重复子数组\n\nclass Solution &#123;public:    int findLength(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int m = nums1.size(), n = nums2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(n+1, 0));        int ret = 0;        for(int i=1; i&lt;=m; ++i)&#123;            for(int j=1; j&lt;=n; ++j)&#123;                if(nums1[i-1] == nums2[j-1])&#123;                    dp[i][j] = dp[i-1][j-1] + 1;                    ret = max(ret, dp[i][j]);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;\n\n错误1如果里面写成这样：\nif(nums1[i-1] == nums2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);...return dp[m][n];\n则是处理非连续的“数组子序列”，对于[0,1,1,1,1]和[1,0,1,0,1]给出的答案是3，但是正确答案应该是2\n// 错误DP图X | X   1   0   1   0   1——————————————————————————X | 0   0   0   0   0   00 | 0   0   1   *1  1   *11 | 0   1   *1  2   *2  21 | 0   1   *1  *2  *2  *31 | 0   1   *1  *2  *2  *31 | 0   1   *1  *2  *2  *3\n// 正确DP图X | X   1   0   1   0   1——————————————————————————X | 0   0   0   0   0   00 | 0   0   1   0   1   01 | 0   1   0   2   0   21 | 0   1   0   1   0   11 | 0   1   0   1   0   11 | 0   1   0   1   0   1\n\n错误2如果里面写成这样：\ndp[i][j] == max(max(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]+1);ret = max(ret, dp[i][j]);...return ret;\n则属于彻底混淆了自己对于dp数组的定义，一定要是以nums1[i]结尾的子数组和以nums1[j]结尾的子数组的最长子数组，对于[1,0,0,0,1]和[1,0,0,1,1]给出的答案是4，但是正确答案应该是3\n// 错误DP图X | X   1   0   0   0   1——————————————————————————X | 0   0   0   0   0   01 | 0   1   0   0   0   10 | 0   0   2   *2  *2  00 | 0   0   *2  3   *3  01 | 0   1   0   0   0   *41 | 0   1   0   0   0   *4\n// 正确DP图X | X   1   0   0   0   1——————————————————————————X | 0   0   0   0   0   01 | 0   1   0   0   0   10 | 0   0   2   1   1   00 | 0   0   1   3   2   01 | 0   1   0   0   0   31 | 0   1   0   0   0   1","tags":["算法","动态规划"]},{"title":"目标检测SSD","url":"/2021/11/23/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BSSD/","content":"\n目标检测SSD\n\n1. 锚框的长和宽1.1 书上代码解析s指的是长宽的缩放比例而非面积的缩放比例，比如s&#x3D;0.5，则面积就是原图像的0.5^2&#x3D;0.25倍。r是宽高比，指的是将原图像归一化为正方形后截取的锚框的宽高比；或者说是在原图像的宽高比基础上乘以r，才是锚框的宽高比。锚框的实际宽高比即$\\frac{w}{h}r$。之所以r&#x3D;1时你看到的是方形，之后会解释。由此，可得以下方程组$$\\begin{cases}w_0h_0&#x3D;s^2wh\\\\frac{w_0}{h_0}&#x3D;\\frac{w}{h} * r\\end{cases}$$解得$$\\begin{cases}w_0&#x3D;sw\\sqrt{r}\\h_0&#x3D;sh&#x2F;\\sqrt{r}\\end{cases}$$$w_0和h_0$分别处以w和h进行归一化，可得$$\\begin{cases}w_0&#x3D;s\\sqrt{r} \\h_0&#x3D;s&#x2F;\\sqrt{r}\\end{cases}$$而在代码中我们可以看到：\nw0 = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),                   sizes[0] * torch.sqrt(ratio_tensor[1:])))\\                   * in_height / in_widthh0 = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),                   sizes[0] / torch.sqrt(ratio_tensor[1:])))\n\n先不看in_height / in_width。上面解得的归一化后的公式与代码所写的一模一样。代码中的$w_0$和$h_0$就是锚框归一化后的宽高（此时消除了原图像w和h的影响，可以认为，r所代表的宽高比就是此时锚框的宽高比，r&#x3D;1时，是一个正方形锚框，也即此时$w_0$和$h_0$的值是一样的）。但是呢，由于我们显示的时候需要乘以图像的实际宽高所以，乘后的锚框实际宽高比就不是1了，所以才要乘以in_height / in_width，作用就是抵消乘以实际图像长宽后r会改变的问题，当然这样做存粹是为了显示方便（也让你误以为r是指锚框的宽高比），带来的副作用就是，锚框的实际面积就不再是原始图像的$s^2$。(￣ε(#￣)。\n由于实际在我们进行目标检测时，特征图长和宽都是相同的，比如(19, 19)、(7, 7)，所以in_height / in_width恒等于1，因此对于实际的使用并不会带来副作用。但此时，如果要将锚框显示出来，归一化后的锚框再乘以图像实际长宽后，所显示的锚框的长宽比会改变。如下图所示，特征图宽高是(1, 1)，当r&#x3D;1，s&#x3D;0.5时，最终锚框的宽高比并不是r&#x3D;1，而是$\\frac{w}{h}*r$。即上述代码中in_height / in_width这部分失效了。好消息是，面积是原图的$s^2$，又符合定义了。\\(￣︶￣\\))\n\n1.2 尝试的改动所以如果r宽高比的定义按照原图像的宽高比*r来定义，那么沐神的代码和书上的公式在实际使用时都是没问题的。只是将这个函数作用于特征图宽高不相同的实例时（比如为了给观众显示方便，直接作用上面这幅图像），会产生一丢丢歧义：此时的r的定义居然又变回了锚框的宽高比。\n我们可以尝试来重新定义宽高比r（s定义不变），直接认定它代表锚框的宽高比，会有如下公式：$$\\begin{cases}\\frac{w_0}{h_0}&#x3D;r\\w_0h_0 &#x3D; s^2wh\\end{cases}$$解得$$\\begin{cases}w_0&#x3D;s\\sqrt{whr}\\h_0&#x3D;s*\\sqrt{\\frac{wh}{r}}\\end{cases}$$$w_0和h_0$分别处以w和h进行归一化，可得$$\\begin{cases}w_0&#x3D;s\\sqrt{\\frac{hr}{w}}\\h_0&#x3D;s\\sqrt{\\frac{w}{r*h}}\\end{cases}\\$$这样定义的话，就要求multibox_prior()函数要传入原图像的长度和宽度。下面实验验证，不论特征图的长宽怎么变，r和s的定义都是一致的。\n\n2. 锚框偏移假设$\\hat{g}_j$是某个标签目标，$d_i$是某个anchor，边框回归与Faster-RCNN类似回归的偏移相对的是$d_i$的中点和宽高(cx, cy, w, h)$$\\begin{cases}\\hat{g}^{cx}_j &#x3D; (g^{cx}_j - d^{cx}_i)&#x2F;d^w_i\\\\hat{g}^{cy}_j &#x3D; (g^{cy}_j - d^{cy}_i)&#x2F;d^h_i\\\\hat{g}^{cw}_j &#x3D; log(g^{cw}_j &#x2F; d^{cw}_i)\\\\hat{g}^{ch}_j &#x3D; log(g^{ch}_j &#x2F; d^{ch}_i)\\\\end{cases}\\$$解释：\n\n激活的锚框（即给分配了某gt的正样本），其与某gt的IOU肯定不低，则其x、y、w、h也肯定差不大，这是前提\nx、y：做差后分布于零点对称，除以锚框宽或高起到归一化作用，值分布变窄\nw、h：做除法后用log，可近似线性，且使得结果的分布呈现零点对称，使得网络回归更简单\n\n","tags":["目标检测"]},{"title":"线段树","url":"/2022/08/27/%E7%BA%BF%E6%AE%B5%E6%A0%91/","content":"需求\n数组区间内经常发生修改，但是又要频繁求得区间的各类统计信息例如最大值、最小值、区间和等等。\n对于一个数组频繁求区间和和修改的情况下：\n普通操作：修改：O(1)；区间和：O(n)\n前缀和：修改：O(n)；区间和：O(1)\n线段树：修改：O(nlogn)；区间和：O(nlogn)\n\n\n\n线段树\n将数组以二分的形式建成一棵二叉树，叶子节点为数组的值，非叶子节点保存相应的统计信息。这棵树近似完全二叉树的结构，所以可以用数组来构建\n下面所列举的代码只需要改变给tree[node]赋值相关代码即可实现求最大值、最小值、区间和，肥肠方便\n307. 区域和检索 - 数组可修改\n\n1、数组版\n粗略而言，数组版线段树的大小初始化为4N即可\n这里_buildTree, _update, _sumRange都传入了参数int start, int end。是通过形参来维护每个树节点的管理范围，事实上，也可以创建一个tree.shape == (3, 4N)的线段树，第一行是统计信息，第二三行是范围起点和终点，代码可见数组版v2\n\nclass NumArray &#123;public:    NumArray(vector&lt;int&gt;&amp; nums):arr(nums), tree(arr.size()*4) &#123;        _buildTree(0, 0, arr.size() - 1);    &#125;    void update(int index, int val) &#123;        _update(0, 0, arr.size() - 1, index, val);    &#125;    int sumRange(int left, int right) &#123;        return _sumRange(0, 0, arr.size() - 1, left, right);    &#125;private:    void _buildTree(int node, int start, int end) &#123;        if (start == end) &#123;            tree[node] = arr[start];            return;        &#125;        int mid = (start + end) / 2;        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        _buildTree(node_left, start, mid);        _buildTree(node_right, mid + 1, end);        // 这里可以改为求最大值、最小值        tree[node] = tree[node_left] + tree[node_right];    &#125;    void _update(int node, int start, int end, int idx, int val) &#123;        if (start == end) &#123;            arr[idx] = val;            tree[node] = val;            return;        &#125;        int mid = (start + end) / 2;        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        if (idx &lt;= mid) _update(node_left, start, mid, idx, val);        else _update(node_right, mid + 1, end, idx, val);        // 这里可以改为求最大值、最小值        tree[node] = tree[node_left] + tree[node_right]; // 修改路径上的值，类似树状数组的寻祖    &#125;    int _sumRange(int node, int start, int end, int l, int r) &#123;        if (l &gt; end || r &lt; start) return 0; // 不在区间内        if (start &gt;= l &amp;&amp; end &lt;= r) return tree[node];        int mid = (start + end) / 2;        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        // 这里可以改为求最大值、最小值        return _sumRange(node_left, start, mid, l, r) + _sumRange(node_right, mid + 1, end, l, r);    &#125;    vector&lt;int&gt; arr;    vector&lt;int&gt; tree;&#125;;\n\n2、真建树struct TNode &#123;    int start;    int end;    int val;    TNode* left;    TNode* right;&#125;;class NumArray &#123;public:    NumArray(vector&lt;int&gt;&amp; nums) &#123;        tree = _buildTree(nums, 0, nums.size()-1);    &#125;    void update(int index, int val) &#123;        _update(tree, index, val);    &#125;    int sumRange(int left, int right) &#123;        return _sumRange(tree, left, right);    &#125;private:    TNode* _buildTree(vector&lt;int&gt;&amp; arr, int l, int r) &#123;        TNode* p = new TNode;        if (l == r) &#123;            p-&gt;val = arr[l];            p-&gt;left = p-&gt;right = nullptr;        &#125;        else &#123;            int m = (l + r) / 2;            p-&gt;left = _buildTree(arr, l, m);            p-&gt;right = _buildTree(arr, m + 1, r);            p-&gt;val = p-&gt;left-&gt;val + p-&gt;right-&gt;val;        &#125;        p-&gt;start = l; p-&gt;end = r;        return p;    &#125;    void _update(TNode* root, int idx, int val) &#123;        int start = root-&gt;start, end = root-&gt;end;        if (start == end) &#123;            root-&gt;val = val;            return;        &#125;        int mid = (start + end) / 2;        if (idx &lt;= mid) _update(root-&gt;left, idx, val);        else _update(root-&gt;right, idx, val);        root-&gt;val = root-&gt;left-&gt;val + root-&gt;right-&gt;val;    &#125;    int _sumRange(TNode* root, int l, int r) &#123;        int start = root-&gt;start, end = root-&gt;end;        if (l &gt; end || r &lt; start) return 0; // 不在区间内        if (start &gt;= l &amp;&amp; end &lt;= r) return root-&gt;val;        return _sumRange(root-&gt;left, l, r) + _sumRange(root-&gt;right, l, r);    &#125;    TNode* tree;&#125;;\n\n3、数组版v2\n效率相较于v1是低了，占用内存也高了~\n\nclass NumArray &#123;public:    NumArray(vector&lt;int&gt;&amp; nums):arr(nums), tree(3, vector&lt;int&gt;(arr.size() * 4)) &#123;        _buildTree(0, 0, arr.size() - 1);    &#125;    void update(int index, int val) &#123;        _update(0, index, val);    &#125;    int sumRange(int left, int right) &#123;        return _sumRange(0, left, right);    &#125;private:    void _buildTree(int node, int start, int end) &#123;        if (start == end) &#123;            tree[0][node] = arr[start];            tree[1][node] = start; // 赋值            tree[2][node] = end; // 赋值            return;        &#125;        int mid = (start + end) / 2;        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        _buildTree(node_left, start, mid);        _buildTree(node_right, mid + 1, end);        // 这里可以改为求最大值、最小值        tree[0][node] = tree[0][node_left] + tree[0][node_right];        tree[1][node] = start; // 赋值        tree[2][node] = end; // 赋值    &#125;    void _update(int node, int idx, int val) &#123;        int start = tree[1][node], end = tree[2][node];        if (start == end) &#123;            arr[idx] = val;            tree[0][node] = val;            return;        &#125;        int mid = (start + end) / 2;        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        if (idx &lt;= mid) _update(node_left, idx, val);        else _update(node_right, idx, val);        // 这里可以改为求最大值、最小值        tree[0][node] = tree[0][node_left] + tree[0][node_right]; // 修改路径上的值，类似树状数组的寻祖    &#125;    int _sumRange(int node, int l, int r) &#123;        int start = tree[1][node], end = tree[2][node];        if (l &gt; end || r &lt; start) return 0; // 不在区间内        if (start &gt;= l &amp;&amp; end &lt;= r) return tree[0][node];        int node_left = node * 2 + 1;        int node_right = node * 2 + 2;        // 这里可以改为求最大值、最小值        return _sumRange(node_left, l, r) + _sumRange(node_right, l, r);    &#125;    vector&lt;int&gt; arr;    vector&lt;vector&lt;int&gt;&gt; tree;&#125;;\n\n参考\n正月点灯笼\n\n","tags":["算法","特殊","树"]},{"title":"生成树","url":"/2022/07/20/%E7%94%9F%E6%88%90%E6%A0%91/","content":"Prim：从一颗小树长大思路和Dijkstra基本一致，唯一不同就是dist记录的是与集合的距离而非与起点的距离\n// Leetcode 1584 连接所有点的最小费用// points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 求坐标轴上这几个点的最小生成树的路径和struct Node&#123; // 用来在优先队列里用    int node;    int dis;    bool operator&gt;(const Node&amp; ano) const &#123;        return this-&gt;dis &gt; ano.dis;    &#125;&#125;;class Solution &#123;public:    int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(); // 节点数        vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;(n, INT_MAX));        for (int i = 0; i &lt; n; ++i)&#123; // 建图            for (int j = 0; j &lt; i; ++j)&#123;                graph[i][j] = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]);                graph[j][i] = graph[i][j];            &#125;        &#125;          priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq;        vector&lt;int&gt; dist(n, INT_MAX);        pq.push(Node(&#123;0, 0&#125;)); // 从0开始， 0到0的距离是0        int ret = 0;        while(!pq.empty())&#123;            Node cur = pq.top(); pq.pop();            // 跟Dijkstra一样，但人家遇到终点直接可以break            // 因为采用优先队列的方式，队列里会有重复，第一次接触的肯定是最优解，后面            // 重复的都是大于最优解的，直接跳过，或者你用一个数组，存储对应节点最优dist            // 每次存储比较取最小值，但是空间浪费太大了，不如这样好            if(dist[cur.node] == 0) continue;            dist[cur.node] = 0;            ret += cur.dis;            for(int i=0; i&lt;n; ++i)&#123;                if(dist[i] &gt; graph[cur.node][i])&#123;                    dist[i] = graph[cur.node][i];                    pq.push(Node(&#123;i, graph[cur.node][i]&#125;));                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;\n\nKruskal利用并查集的思想\n// Leetcode 1584 连接所有点的最小费用// points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 求坐标轴上这几个点的最小生成树的路径和class UFSet&#123;public:    UFSet(int _n):count(_n), parent(_n, -1)&#123;&#125;    int getCount()&#123;return count;&#125;    void unite(int a, int b)&#123;        int f1 = find(a);        int f2 = find(b);        if(f1 == f2) return;        if(parent[f1] &lt; parent[f2])&#123;            parent[f1] += parent[f2];            parent[f2] = f1;        &#125;else&#123;            parent[f2] += parent[f1];            parent[f1] = f2;        &#125;        -- count;    &#125;    bool isConnected(int a, int b)&#123;        return find(a) == find(b);    &#125;    private:    int find(int pos)&#123;        if(parent[pos] &lt; 0) return pos;        return parent[pos] = find(parent[pos]);    &#125;    int count; // 连通集的个数    vector&lt;int&gt; parent;&#125;;struct Edge&#123;    int from;    int to;    int weight;    bool operator&gt;(const Edge&amp; ano) const &#123;        return this-&gt;weight &gt; ano.weight;    &#125;&#125;;class Solution &#123;public:    // 都不用建图，直接把边放进去就行了    int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size();        UFSet ufs(n);        priority_queue&lt;Edge, vector&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;        for(int i=0; i&lt;n; ++i)&#123;            for(int j=0; j&lt;i; ++j)&#123;                int weight = abs(points[i][0]-points[j][0]) + abs(points[i][1]-points[j][1]);                pq.push(Edge(&#123;i, j, weight&#125;));            &#125;        &#125;        int res = 0, cnt = 0;        while(!pq.empty() &amp;&amp; cnt&lt;n-1)&#123;            Edge cur = pq.top(); pq.pop();            if(ufs.isConnected(cur.from, cur.to) == false)&#123; // from和to是图节点名，这里直接以points顺序的下标来表示                ufs.unite(cur.from, cur.to);                res += cur.weight;                ++cnt;            &#125;        &#125;        return res;    &#125;&#125;;","tags":["算法","树"]},{"title":"线程安全智能指针","url":"/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"线程安全的share指针1. 代码部分#include &lt;iostream&gt;#include &lt;mutex&gt;using namespace std;class Counter&#123;public:    Counter(): m_Counter(0) &#123;&#125;    Counter(const Counter&amp;) = delete;    Counter&amp; operator=(const Counter&amp;) = delete;    ~Counter() &#123;&#125;    void reset() &#123; m_Counter = 0; &#125;    unsigned int get() const &#123; return m_Counter; &#125;    void operator++() &#123; m_Counter++; &#125;    void operator++(int) &#123; m_Counter++; &#125;    void operator--() &#123; m_Counter--; &#125;    void operator--(int) &#123; m_Counter--; &#125;private:    unsigned int m_Counter&#123;&#125;; // 花括号也可以初始化&#125;;template&lt;typename T&gt;class SharedPtr&#123;public:    explicit SharedPtr(T *ptr = nullptr): // explicit        pData(ptr),        pCounter(new Counter()),        pMutex(new std::mutex)    &#123;        if (ptr) &#123;            addCount();        &#125;    &#125;    SharedPtr(const SharedPtr&lt;T&gt;&amp; sp) &#123;        pData = sp.pData;        pCounter = sp.pCounter;        pMutex = sp.pMutex;        addCount();    &#125;    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&lt;T&gt;&amp; sp) &#123;        if (pData != sp.pData) &#123;            subCount();            pData = sp.pData;            pCounter = sp.pCounter;            pMutex = sp.pMutex;            addCount();        &#125;    &#125;    T* operator-&gt;() &#123; return pData; &#125;    T&amp; operator*() &#123; return *pData; &#125;    T* get() &#123; return pData; &#125;    unsigned int getCount() &#123; return pCounter-&gt;get(); &#125;    ~SharedPtr() &#123; subCount(); &#125;private:    void addCount() &#123;        pMutex-&gt;lock();        ++(*pCounter);        pMutex-&gt;unlock();    &#125;    void subCount() &#123;        bool deleteflag = false;        pMutex-&gt;lock();        --(*pCounter);        if (pCounter-&gt;get() == 0) &#123;            delete pCounter;            delete pData;            deleteflag = true;        &#125;        pMutex-&gt;unlock();        if (deleteflag == true) delete pMutex;    &#125;private:    T *pData;    std::mutex *pMutex;    Counter *pCounter;&#125;;class MyClass &#123;public:    MyClass() &#123;        cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; endl;    &#125;    ~MyClass() &#123;        cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    SharedPtr&lt;MyClass&gt; p(new MyClass());    SharedPtr&lt;MyClass&gt; p2 = p;    cout &lt;&lt; &quot;END&quot; &lt;&lt; endl;    return 0;&#125;\n\n2. 参考资料\n1. 线程安全智能指针\n2. 智能指针\n\n","tags":["C/C++"]},{"title":"背包问题","url":"/2022/06/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"01背包经典动态规划问题，输入重量数组weight、价值数组value和背包可承载的最大重量整数maxW\nclass Solution &#123;public:\tint knapsack(vector&lt;int&gt;&amp; weight, vector&lt;int&gt;&amp; value, int maxW) &#123;\t\t// 物品数目\t\tint kinds = weight.size();\t\t// dp数组初始化为二维数组\t\tvector&lt;vector&lt;int&gt;&gt; dp(kinds + 1, vector&lt;int&gt;(maxW + 1, 0));\t\t// 状态一：可选的目标：0个可选，前一个可选、前两个可选、前三个可选，以此类推（与找零钱不同，物品不能重复选）\t\tfor (int c = 1; c &lt;= kinds; c++) &#123;\t\t\t// 状态二：当前的可承载重量，0、1、2...maxW\t\t\tfor (int w = 1; w &lt;= maxW; w++) &#123;\t\t\t\t// 该物品太大以至于当前重量超标：下标越界，直接赋值为“没有该物品时的最优答案”\t\t\t\tif (w - weight[c - 1] &lt; 0) \t\t\t\t\tdp[c][w] = dp[c - 1][w];\t\t\t\t// 比较，“不选择该物品”和“选择该物品”时，哪个价值大\t\t\t\telse\t\t\t\t\tdp[c][w] = max(dp[c - 1][w], dp[c - 1][w - weight[c - 1]] + value[c - 1]);\t\t\t&#125;\t\t&#125;\t\treturn dp[kinds][maxW];\t&#125;&#125;;\n\n完全背包标准DPclass Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        int n = coins.size();        vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(amount+1, 0));\t\t// base case 这里也可以只dp[0][0]=1，但下面的二重循环的j必须从0开始了\t\t// 从含义上来说，还是在这里初始化一列全1比较符合定义\t\tfor(int s = 0; s&lt;=n; ++s)\t\t\tdp[s][0] = 1;        for(int i=1; i&lt;=n; ++i)&#123;            for(int j=1; j&lt;=amount; ++j)&#123;                if(coins[i-1] &gt; j)\t\t\t\t\tdp[i][j] = dp[i-1][j];                else // dp[i][j] = dp[i-1][j] + dp[i-1][j-coins[i-1]];一个数字之差就变成不可重复选取了                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];            &#125;        &#125;        return dp[n][amount];    &#125;&#125;;\n\n压缩一下class Solution &#123;public:    int change(int amount, vector&lt;int&gt;&amp; coins) &#123;        int n = coins.size();        vector&lt;int&gt; dp(amount+1, 0);\t\tdp[0] = 1;        for(int i=1; i&lt;=n; ++i)&#123;            for(int j=1; j&lt;=amount; ++j)&#123;                if(coins[i-1] &lt;= j)                    dp[j] = dp[j] + dp[j-coins[i-1]]; // 由于需要用到当前行更新的值，正好不用倒过来了，和下面子集背包压缩做对比            &#125;        &#125;        return dp[amount];    &#125;&#125;;\n\n子集背包标准DP// 子集背包问题class Solution &#123;public:    // sum(A1) == sum(A2) -&gt; target = sum(A)/2    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum = 0;        for (auto e : nums) sum += e;        if (sum % 2) // 和必须是偶数            return false;        int target = sum &gt;&gt; 1;        int n = nums.size();        vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(target + 1, 0)); // 用布尔        dp[0][0] = 1; // 初始化        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = 0; j &lt;= target; j++) &#123;                if (nums[i - 1] &gt; j)                    dp[i][j] = dp[i - 1][j];                else                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];            &#125;        &#125;        return dp[n][target] &gt; 0;    &#125;&#125;;\n\n压缩一下// 子集背包问题class Solution &#123;public:    // sum(A1) == sum(A2) -&gt; target = sum(A)/2    bool canPartition(vector&lt;int&gt;&amp; nums) &#123;        int sum = 0;        for (auto e : nums) sum += e;        if (sum % 2) // 和必须是偶数            return false;        int target = sum &gt;&gt; 1;        int n = nums.size();        vector&lt;bool&gt; dp(target + 1, false); // 用布尔        dp[0] = true; // 初始化        for (int i = 1; i &lt;= n; i++) &#123;            for (int j = target; j &gt;= 0; j--) &#123; // 必须从后往前，不然会覆盖之前的数据                if (nums[i - 1] &gt; j)                    dp[j] = dp[j];                else                    dp[j] = dp[j] || dp[j - nums[i - 1]];            &#125;        &#125;        return dp[target] &gt; 0;    &#125;&#125;;\n\n参考labuladong\n","tags":["算法","动态规划"]},{"title":"计算器","url":"/2022/04/05/%E8%AE%A1%E7%AE%97%E5%99%A8/","content":"功能说明\n实现+、-、*、&#x2F;、括号的整数运算\n实现处理多余空格\n\n实现1（更高效）\n用引用l指针的方式逐步处理\n\nint core(string&amp; s, int&amp; l) &#123;    stack&lt;int&gt; stk;    int n = s.size();    int num = 0;    char sign = &#x27;+&#x27;;    for (; l &lt; n; ++l) &#123;        char c = s[l];        if (isdigit(c))             num = num * 10 + (c - &#x27;0&#x27;);        // if(c == &#x27; &#x27;) continue是不对的，因为l=n-1时一定要最后来一次        if ((!isdigit(c) &amp;&amp; c != &#x27; &#x27;) || l == n - 1) &#123;            if (c == &#x27;(&#x27;)                 num = core(s, ++l); // 理解这种递归思想很重要            int prev;            switch (sign) &#123;            case &#x27;+&#x27;:                stk.push(num); break;            case &#x27;-&#x27;:                stk.push(-num); break;            case &#x27;*&#x27;:                prev = stk.top(); stk.pop();                stk.push(prev * num);                break;            case &#x27;/&#x27;:                prev = stk.top(); stk.pop();                stk.push(prev / num);                break;            default: break;            &#125;            sign = c;            num = 0;            if (c == &#x27;)&#x27;)                 break;        &#125;    &#125;    int ret = 0;    while (!stk.empty()) &#123;        ret += stk.top();        stk.pop();    &#125;    return ret;&#125;int caculator(string s) &#123;    int tmp = 0;    return core(s, tmp);&#125;\n\n实现2（更优雅）\n由于需要不停pop首部，所以采用deque代替移动的l，更优雅\n\nint core(deque&lt;char&gt;&amp; s) &#123;    stack&lt;int&gt; stk;    int num = 0;    char sign = &#x27;+&#x27;;    while (!s.empty()) &#123;        char c = s[0]; s.pop_front();        if (isdigit(c))            num = num * 10 + (c - &#x27;0&#x27;);        if ((!isdigit(c) &amp;&amp; c != &#x27; &#x27;) || s.empty()) &#123;            if (c == &#x27;(&#x27;)                num = core(s);            int prev;            switch (sign) &#123;            case &#x27;+&#x27;:                stk.push(num); break;            case &#x27;-&#x27;:                stk.push(-num); break;            case &#x27;*&#x27;:                prev = stk.top(); stk.pop();                stk.push(prev * num);                break;            case &#x27;/&#x27;:                prev = stk.top(); stk.pop();                stk.push(prev / num);                break;            default: break;            &#125;            sign = c;            num = 0;            if (c == &#x27;)&#x27;)                break;        &#125;    &#125;    int ret = 0;    while (!stk.empty()) &#123;        ret += stk.top();        stk.pop();    &#125;    return ret;&#125;int caculator(string s) &#123;    deque&lt;char&gt; dq;    for (auto&amp; e : s) dq.push_back(e);    return core(dq);&#125;\n\n参考\nlabuladong的算法小抄\n\n","tags":["算法","特殊"]},{"title":"设计模式-单例模式","url":"/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"单例模式0、静态函数变量版本利用C++特性\ntemplate &lt;class T&gt;class SingleTon &#123;public:    static T&amp; GetInstance() &#123;        static T ins;        return ins;    &#125;    SingleTon(const SingleTon&amp;) = delete;    SingleTon&amp; operator=(const SingleTon&amp;) = delete;    virtual ~SingleTon() &#123;&#125;protected:    SingleTon() &#123;&#125;&#125;;class Apple : public SingleTon&lt;Apple&gt; &#123;    friend SingleTon&lt;Apple&gt;; // 友元public:    void show() &#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &#125;    ~Apple() &#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &#125;protected:    Apple() &#123;&#125;&#125;;class Orange : public SingleTon&lt;Orange&gt; &#123;    friend SingleTon&lt;Orange&gt;; // 友元public:    ~Orange() &#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &#125;    void show() &#123;        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;    &#125;protected:    Orange() &#123;&#125;&#125;;int main() &#123;    Apple::GetInstance().show();    cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl;    Apple::GetInstance().show();    cout &lt;&lt; &amp;Apple::GetInstance() &lt;&lt; endl;    Orange::GetInstance().show();    Orange::GetInstance().show();    return 0;&#125;\n\n\n1、普通版本（高并发效率不足）（安全）\n在类中添加一个私有静态成员单例实例的指针。\n声明一个公有静态构建方法用于获取单例实例的指针。\n在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。\n将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。\n检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。\n\nclass Singleton &#123;protected:\tSingleton(const string&amp; val) : data(val) &#123;&#125; // 构造函数\t~Singleton() &#123;&#125;\tstatic Singleton* _instance; // 静态：实例的指针\tstatic mutex _mutex;\tstring data; // 代表类内的资源public:\tSingleton(const Singleton&amp; another) = delete; // 禁止拷贝构造\tSingleton&amp; operator=(const Singleton&amp; another) = delete; // 禁止赋值\tstatic Singleton* getInstance(const string&amp; val); // 静态：获取实例\tvoid show() &#123; cout &lt;&lt; &quot;data: &quot; &lt;&lt; data &lt;&lt; endl; &#125; // 测试&#125;;// 静态成员需要在类外定义Singleton* Singleton::_instance = nullptr;mutex Singleton::_mutex;Singleton* Singleton::getInstance(const string&amp; val) &#123;\tlock_guard&lt;mutex&gt; lock(_mutex); // 出作用域自动释放\tif (_instance == nullptr) &#123;\t\t_instance = new Singleton(val);\t&#125;\treturn _instance;&#125;int main() &#123;\tSingleton* a = Singleton::getInstance(&quot;aaa&quot;);\ta-&gt;show(); // &quot;aaa&quot; ok\tSingleton* b = Singleton::getInstance(&quot;bbb&quot;);\tb-&gt;show(); // &quot;aaa&quot; ok\treturn 0;&#125;\n\n2、双检查锁（有隐患）reorder问题：通常new通常有三步：1、分配一块内存空间；2、执行构造器；3、返回指针；但是由于编译器有时会进行优化，执行顺序变为132：即分配空间后先返回指针，再执行构造器这样就会到来危险，比如线程A执行new，132，3执行完；线程B发现m_instance非空返回，然后外部直接用这个指针会出错\n//双检查锁，但由于内存读写reorder不安全（不安全）Singleton* Singleton::getInstance() &#123;    if(m_instance==nullptr)&#123; // 第一次检查，主要解决性能问题，毕竟读操作不需要上锁        Lock lock;        if (m_instance == nullptr) &#123; // 第二次检查，解决核心问题：只能new单个            m_instance = new Singleton();        &#125;    &#125;    return m_instance;&#125;\n\n3、双检查锁（安全）//C++ 11版本之后的跨平台实现 (volatile)（安全）std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123;    Singleton* tmp = m_instance.load(std::memory_order_relaxed);    std::atomic_thread_fence(std::memory_order_acquire); // 获取内存fence    if (tmp == nullptr) &#123;        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);        tmp = m_instance.load(std::memory_order_relaxed);        if (tmp == nullptr) &#123;            tmp = new Singleton;            std::atomic_thread_fence(std::memory_order_release); // 释放内存fence            m_instance.store(tmp, std::memory_order_relaxed);        &#125;    &#125;    return tmp;&#125;\n\n参考资料\nRefactoring.Guru\n李建忠设计模式\nC++ 23种设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-工厂模式","url":"/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"1 工厂模式\n父类决定实例的生成方式，但并不决定所要生成具体的类，具体处理全部交给子类处理。 将生成实例的框架与具体的实例类解耦。\n在软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化\n如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“具体对象创建工作”的紧耦合？\n\n2 问题// FileSplitter.cppclass ISplitter&#123;public:    virtual void split()=0;    virtual ~ISplitter()&#123;&#125;&#125;;// 多个具体的文件分割器class BinarySplitter : public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class TxtSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class PictureSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class VideoSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;\n\n// MainForm.cppclass MainForm : public Form&#123;public:\tvoid Button1_Click()&#123;\t\t// 抽象依赖* ptr = new 具体依赖(); 违背依赖倒置原则，这样肯定不行的！\t\tISplitter * splitter = new BinarySplitter(); //依赖具体类        splitter-&gt;split();\t&#125;&#125;;\n\n3 工厂模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类\n\n// ---- 抽象基类 ----class ISplitter&#123;public:    virtual void split()=0;    virtual ~ISplitter()&#123;&#125;&#125;;// ---- 工厂基类 ----class SplitterFactory&#123;public:    virtual ISplitter* CreateSplitter()=0;    virtual ~SplitterFactory()&#123;&#125;&#125;;//  ---- 具体类 ----class BinarySplitter : public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class TxtSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class PictureSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;class VideoSplitter: public ISplitter&#123;    virtual void split()&#123;        // ...    &#125;&#125;;// ---- 具体工厂 ----class BinarySplitterFactory: public SplitterFactory&#123;public:    virtual ISplitter* CreateSplitter()&#123;        return new BinarySplitter();    &#125;&#125;;class TxtSplitterFactory: public SplitterFactory&#123;public:    virtual ISplitter* CreateSplitter()&#123;        return new TxtSplitter();    &#125;&#125;;class PictureSplitterFactory: public SplitterFactory&#123;public:    virtual ISplitter* CreateSplitter()&#123;        return new PictureSplitter();    &#125;&#125;;class VideoSplitterFactory: public SplitterFactory&#123;public:    virtual ISplitter* CreateSplitter()&#123;        return new VideoSplitter();    &#125;&#125;;\n\n// 虽然具体工厂总会在某个地方new出来，但是MainForm没有具体类的依赖了，变化的地方被赶出去了（变化没法消灭），猫被关进笼子里class MainForm : public Form&#123;    SplitterFactory*  factory; // 工厂public:    MainForm(SplitterFactory*  factory)&#123;        this-&gt;factory=factory;    &#125;\tvoid Button1_Click()&#123;\t\tISplitter * splitter = factory-&gt;CreateSplitter(); // 形式上叫“多态new”        splitter-&gt;split();\t&#125;&#125;;\n4 总结\nFactory Method模式用于隔离类对象的使用者和具体类型之间的 耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导 致软件的脆弱。\nFactory Method模式通过面向对象的手法，将所要创建的具体对 象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。\nFactory Method模式解决“单个对象”的需求变化。缺点在于要 求创建方法&#x2F;参数相同。\n\n5 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-模板方法模式","url":"/2022/07/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","content":"1 模板方法模式\n模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n在父类中定义处理流程的框架，在子类中实现具体处理\n在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。\n定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。\n\n2 问题//程序库开发人员class Library&#123;public:\tvoid Step1()&#123;\t\t//...\t&#125;    void Step3()&#123;\t\t//...    &#125;    void Step5()&#123;\t\t//...    &#125;&#125;;\n//应用程序开发人员class Application&#123;public:\tbool Step2()&#123;\t\t//...    &#125;    void Step4()&#123;\t\t//...    &#125;&#125;;int main()&#123;\tLibrary lib();\tApplication app();\t\tlib.Step1();\tif (app.Step2())&#123;\t\tlib.Step3();\t&#125;\tfor (int i = 0; i &lt; 4; i++)&#123;\t\tapp.Step4();\t&#125;\tlib.Step5();&#125;\n\n3 模板方法\n//程序库开发人员class Library&#123;public:\t//稳定 template method，要求Run方法稳定    void Run()&#123;        Step1();        if (Step2()) &#123; // 支持变化 ==&gt; 虚函数的多态调用            Step3();         &#125;        for (int i = 0; i &lt; 4; i++)&#123;            Step4(); // 支持变化 ==&gt; 虚函数的多态调用        &#125;        Step5();    &#125;\tvirtual ~Library()&#123; &#125;    // 这些步骤一般单独调用没意义，所以设为protectedprotected:\tvoid Step1() &#123; // 稳定        //.....    &#125;\tvoid Step3() &#123;// 稳定        //.....    &#125;\tvoid Step5() &#123; // 稳定\t\t//.....\t&#125;\tvirtual bool Step2() = 0; // 变化    virtual void Step4() = 0; // 变化&#125;;\n//应用程序开发人员class Application : public Library &#123;protected:\tvirtual bool Step2()&#123;\t\t//... 子类重写实现    &#125;    virtual void Step4() &#123;\t\t//... 子类重写实现    &#125;&#125;;int main()&#123;\tLibrary* pLib = new Application();\tlib-&gt;Run();\tdelete pLib;&#125;\n\n4 总结\nTemplate Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。\n除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。\n在具体实现方面，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将它们设置为protected方法。\n\n5 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-状态模式","url":"/2022/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/","content":"1 状态模式\n在软件构建过程中，某些对象的状态如果改变，其行为也会随之改变，比如文档处于只读状态，其支持的行为和读写状态支持的行为可能完全不同\n允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为\n用类表示状态，通过切换类改变对象状态\n跟Strategy模式很像，区别是：状态模式采用单例模式，抽象类包含指向下一个状态的指针\n\n2 问题enum NetworkState&#123;    Network_Open,    Network_Close,    Network_Connect    // 假设未来有新状态：Network_Wait，怎么办？&#125;;class NetworkProcessor&#123;    NetworkState state;public:    void Operation1()&#123;        if (state == Network_Open)&#123;            //**********            state = Network_Close;        &#125;        else if (state == Network_Close)&#123;            //..........            state = Network_Connect;        &#125;        else if (state == Network_Connect)&#123;            //$$$$$$$$$$            state = Network_Open;        &#125;    &#125;    void Operation2()&#123;        if (state == Network_Open)&#123;            //**********            state = Network_Connect;        &#125;        else if (state == Network_Close)&#123;            //..........            state = Network_Open;        &#125;        else if (state == Network_Connect)&#123;            //$$$$$$$$$$            state = Network_Close;        &#125;    &#125;    void Operation3()&#123;        // ...    &#125;&#125;;\n\n3 状态v1\n// 把以前的枚举类型转换为抽象基类// 再把以前的所有操作，作为状态对象的行为// 最后再塞一个状态对像的指针class NetworkState&#123;protected:    NetworkState* pNext; // next指针public:    virtual void Operation1()=0;    virtual void Operation2()=0;    virtual void Operation3()=0;    virtual ~NetworkState()&#123;&#125;&#125;;class OpenState: public NetworkState&#123;    static NetworkState* m_instance; // 存放该类唯一实例的指针public:    static NetworkState* getInstance()&#123; // 单例模式        if (m_instance == nullptr) &#123;            m_instance = new OpenState();        &#125;        return m_instance;    &#125;    void Operation1()&#123;        // **********        pNext = CloseState::getInstance();    &#125;        void Operation2()&#123;        // ..........        pNext = ConnectState::getInstance();    &#125;        void Operation3()&#123;        // $$$$$$$$$$        pNext = OpenState::getInstance();    &#125;&#125;;class CloseState: public NetworkState&#123;    // ...&#125;class ConnectionState: public NetworkState&#123;    // ...&#125;// 可以非常方便的添加扩展class WaitState: public NetworkState&#123;    // ...&#125;class NetworkProcessor&#123;    NetworkState* pState;    public:    NetworkProcessor(NetworkState* pState)&#123; // 构造函数        this-&gt;pState = pState;    &#125;        void Operation1()&#123;        // ...        pState-&gt;Operation1(); // 多态调用        pState = pState-&gt;pNext; // 精妙        // ...    &#125;        void Operation2()&#123;        // ...        pState-&gt;Operation2(); // 多态调用        pState = pState-&gt;pNext; // 精妙        // ...    &#125;        void Operation3()&#123;        // ...        pState-&gt;Operation3(); // 多态调用        pState = pState-&gt;pNext; // 精妙        // ...    &#125;&#125;;\n\n4 状态v2（可执行）class IContext;class IState &#123; // 某版直接包含IContext指针public:\tvirtual ~IState() &#123;&#125;\tvirtual void doColock(IContext *ctx, int hour) = 0;\tvirtual void doUse(IContext *ctx) = 0;\tvirtual void doAlarm(IContext *ctx) = 0;\tvirtual void doPhone(IContext *ctx) = 0;&#125;;class IContext &#123;public:\tenum class ActionType &#123;\t\tUse,\t\tAlarm,\t\tPhone\t&#125;;\tvirtual ~IContext() &#123;&#125;\tvirtual void doAction(ActionType actionType) = 0;\tvirtual void setClock(int hour) = 0;\tvirtual void stateChange(IState *state) = 0;\tvirtual void callSecurityCenter(const std::string &amp;msg) = 0;\tvirtual void recoderLog(const std::string &amp;msg) = 0;&#125;;class DayState : public IState&#123;public:\tstatic DayState &amp;GetInstance()&#123;\t\tstatic DayState s;\t\treturn s;\t&#125;\tvirtual void doColock(IContext *ctx, int hour) override;\tvirtual void doUse(IContext *ctx) override&#123;\t\tctx-&gt;recoderLog(&quot;Day use &quot;);\t&#125;\tvirtual void doAlarm(IContext *ctx) override&#123;\t\tctx-&gt;callSecurityCenter(&quot;Day alarm&quot;);\t&#125;\tvirtual void doPhone(IContext *ctx) override&#123;\t\tctx-&gt;callSecurityCenter(&quot;Day phone&quot;);\t&#125;\t~DayState() = default;\tDayState(const DayState &amp;) = delete;\tDayState(DayState &amp;&amp;) = delete;\tDayState &amp;operator=(const DayState &amp;) = delete;\tDayState &amp;operator=(DayState &amp;&amp;) = delete;protected:\tDayState() &#123;&#125;&#125;;class NightState : public IState &#123;public:\tstatic NightState &amp;GetInstance() &#123;\t\tstatic NightState s;\t\treturn s;\t&#125;\tvirtual void doColock(IContext *ctx, int hour) override;\tvirtual void doUse(IContext *ctx) override &#123;\t\tctx-&gt;callSecurityCenter(&quot;Night use &quot;);\t&#125;\tvirtual void doAlarm(IContext *ctx) override &#123;\t\tctx-&gt;callSecurityCenter(&quot;Night alarm&quot;);\t&#125;\tvirtual void doPhone(IContext *ctx) override &#123;\t\tctx-&gt;recoderLog(&quot;Night phone&quot;);\t&#125;\t~NightState() = default;\tNightState(const NightState &amp;) = delete;\tNightState(NightState &amp;&amp;) = delete;\tNightState &amp;operator=(const NightState &amp;) = delete;\tNightState &amp;operator=(NightState &amp;&amp;) = delete;protected:\tNightState() &#123;&#125;&#125;;void DayState::doColock(IContext *ctx, int hour) &#123;\tif (hour &lt; 9 || hour &gt;= 17) &#123;\t\tctx-&gt;stateChange(&amp;NightState::GetInstance());\t&#125;&#125;void NightState::doColock(IContext *ctx, int hour) &#123;\tif (hour &gt;= 9 &amp;&amp; hour &lt; 17) &#123;\t\tctx-&gt;stateChange(&amp;DayState::GetInstance());\t&#125;&#125;class SafeFrame : public IContext&#123;public:\tSafeFrame();\tvirtual void setClock(int hour) override;\tvirtual void doAction(ActionType actionType) override;\tvirtual void stateChange(IState *state) override;\tvirtual void callSecurityCenter(const std::string &amp;msg) override;\tvirtual void recoderLog(const std::string &amp;msg) override;private:\tIState *m_state;&#125;;SafeFrame::SafeFrame() : m_state(&amp;DayState::GetInstance()) &#123;&#125; // 初始化白天void SafeFrame::setClock(int hour)&#123;\tstd::cout &lt;&lt; &quot;now timw is &quot; &lt;&lt; hour &lt;&lt; std::endl;\tm_state-&gt;doColock(this, hour);&#125;void SafeFrame::doAction(ActionType actionType)&#123;\tswitch (actionType)&#123;\tcase ActionType::Alarm:\t\tm_state-&gt;doAlarm(this);\t\tbreak;\tcase ActionType::Phone:\t\tm_state-&gt;doPhone(this);\t\tbreak;\tcase ActionType::Use:\tdefault:\t\tm_state-&gt;doUse(this);\t\tbreak;\t&#125;&#125;void SafeFrame::stateChange(IState *state)&#123;\tstd::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\tm_state = state;&#125;void SafeFrame::callSecurityCenter(const std::string &amp;msg)&#123;\tstd::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;void SafeFrame::recoderLog(const std::string &amp;msg)&#123;\tstd::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot; &quot; &lt;&lt; msg &lt;&lt; std::endl;&#125;int main() &#123;\tIContext *ctx = new SafeFrame;\tfor (int i = 0; i &lt; 24; ++i) &#123;\t\tctx-&gt;setClock(i);\t\tctx-&gt;doAction(IContext::ActionType::Use);\t\tctx-&gt;doAction(IContext::ActionType::Phone);\t\tctx-&gt;doAction(IContext::ActionType::Alarm);\t&#125;\tdelete ctx;\treturn 0;&#125;\n\n5 总结\nState模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。\n为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。\n如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。\n\n6 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-抽象工厂","url":"/2022/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/","content":"1 抽象工厂模式\n在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。\n如何应对这种变化？如何绕过常规的对象创建方法(new)，提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？\n提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。\n\n2 问题class EmployeeDAO&#123;public:    vector&lt;EmployeeDO&gt; GetEmployees()&#123;        SqlConnection* connection = new SqlConnection(); // 耦合        connection-&gt;ConnectionString(&quot;...&quot;);        SqlCommand* command = new SqlCommand(); // 耦合        command-&gt;CommandText(&quot;...&quot;);        command-&gt;SetConnection(connection);        SqlDataReader* reader = command-&gt;ExecuteReader();        while (reader-&gt;Read())&#123;            // ...        &#125;    &#125;&#125;;\n\n3 尝试简单工厂模式系列对象的关联性丢失，产生大量类，代码臃肿不堪\n// 先尝试用简单工厂模式解决...// 数据库访问有关的基类class IDBConnection&#123;    // ...&#125;;class IDBConnectionFactory&#123;public:    virtual IDBConnection* CreateDBConnection()=0;&#125;;class IDBCommand&#123;    // ...&#125;;class IDBCommandFactory&#123;public:    virtual IDBCommand* CreateDBCommand()=0;&#125;;class IDBDataReader&#123;    // ...&#125;;class IDBDataReaderFactory&#123;public:    virtual IDBDataReader* CreateDataReader()=0;&#125;;// 支持SQL Serverclass SqlConnection: public IDBConnection&#123;    // ...&#125;;class SqlConnectionFactory:public IDBConnectionFactory&#123;    // ...&#125;;class SqlCommand: public IDBCommand&#123;    // ...&#125;;class SqlCommandFactory:public IDBCommandFactory&#123;    // ...&#125;;class SqlDataReader: public IDataReader&#123;    // ...&#125;;class SqlDataReaderFactory:public IDBDataReaderFactory&#123;    // ...&#125;;// 支持Oracleclass OracleConnection: public IDBConnection&#123;    // ...&#125;;class OracleConnectionFactory: public IDBConnectionFactory&#123;    // ...&#125;class OracleCommand: public IDBCommand&#123;    // ...&#125;;class OracleCommandFactory: publc IDBCommandFactory&#123;    // ...&#125;class OracleDataReader: public IDataReader&#123;    // ...&#125;;class OracleDataReaderFactory: public IDBDataReaderFactory&#123;    // ...&#125;class EmployeeDAO&#123;    IDBConnectionFactory* dbConnectionFactory;    IDBCommandFactory* dbCommandFactory;    IDBDataReaderFactory* dataReaderFactory;    public:    vector&lt;EmployeeDO&gt; GetEmployees()&#123;        IDBConnection* connection = dbConnectionFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(&quot;...&quot;);        IDBCommand* command = dbCommandFactory-&gt;CreateDBCommand();        command-&gt;CommandText(&quot;...&quot;);        command-&gt;SetConnection(connection); //关联性        IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性        while (reader-&gt;Read())&#123;            // ...        &#125;    &#125;&#125;;\n\n4 抽象工厂（family factory）\n// family factory// 数据库访问有关的基类class IDBConnection&#123;    &#125;;class IDBCommand&#123;    &#125;;class IDBDataReader&#123;    &#125;;// 抽象工厂基类class IDBFactory&#123;public:    virtual IDBConnection* CreateDBConnection()=0;    virtual IDBCommand* CreateDBCommand()=0;    virtual IDBDataReader* CreateDataReader()=0;    &#125;;// 支持SQL Serverclass SqlConnection: public IDBConnection&#123;    &#125;;class SqlCommand: public IDBCommand&#123;    &#125;;class SqlDataReader: public IDBDataReader&#123;    &#125;;// SQL工厂class SqlDBFactory:public IDBFactory&#123;public:    virtual IDBConnection* CreateDBConnection()&#123;        return new SqlConnection();    &#125;    virtual IDBCommand* CreateDBCommand()&#123;        return new SqlCommand();    &#125;    virtual IDBDataReader* CreateDataReader()&#123;        return new SqlDataReader();    &#125;&#125;;// 支持Oracleclass OracleConnection: public IDBConnection&#123;    &#125;;class OracleCommand: public IDBCommand&#123;    &#125;;class OracleDataReader: public IDBDataReader&#123;    &#125;;// Oracle工厂class OracleDBFactory: public IDBFactory&#123;public:    virtual IDBConnection* CreateDBConnection()&#123;        return new OracleConnection();    &#125;    virtual IDBCommand* CreateDBCommand()&#123;        return new OracleCommand();    &#125;    virtual IDBDataReader* CreateDataReader()&#123;        return new OracleDataReader();    &#125;&#125;class EmployeeDAO&#123;    IDBFactory* dbFactory; // 抽象工厂指针    public:    vector&lt;EmployeeDO&gt; GetEmployees()&#123;        IDBConnection* connection = dbFactory-&gt;CreateDBConnection();        connection-&gt;ConnectionString(&quot;...&quot;);        IDBCommand* command = dbFactory-&gt;CreateDBCommand();        command-&gt;CommandText(&quot;...&quot;);        command-&gt;SetConnection(connection); //关联性        IDBDataReader* reader = command-&gt;ExecuteReader(); //关联性        while (reader-&gt;Read())&#123;            // ...        &#125;    &#125;&#125;;\n\n5 总结\n如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory模式，这时候使用简单的工厂完全可以。\n“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。\nAbstract Factory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。（新系列数据库：OK；新方法IDBMethod：NO！）\n\n6 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-策略模式","url":"/2022/05/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/","content":"1 策略模式\n定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。\n将算法与其它部分分离开，只定义与算法相关的接口，然后在程序中以委托的方式来使用。使用委托这种弱关联关系可以很方便地整体替换算法。程序运行过程中也可以替换算法\n策略模式是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n2 问题enum TaxBase &#123;\tCN_Tax,\tUS_Tax,\tDE_Tax,\tFR_Tax //更改：新添加&#125;;class SalesOrder&#123;    TaxBase tax;public:    double CalculateTax()&#123;        //...                if (tax == CN_Tax)&#123;            //CN***********        &#125;        else if (tax == US_Tax)&#123;            //US***********        &#125;        else if (tax == DE_Tax)&#123;            //DE***********        &#125;\t\telse if (tax == FR_Tax)&#123;  //更改\t\t\t//...\t\t&#125;        //....     &#125;&#125;;\n\n3 策略v1\n// 抽象基类class TaxStrategy&#123; // 一般就放一个方法，当然也会放几个相关的方法，但是一般方法数都不多public:    virtual double Calculate(const Context&amp; context)=0;    virtual ~TaxStrategy()&#123;&#125;&#125;;// 具体类class CNTax : public TaxStrategy&#123;public:    virtual double Calculate(const Context&amp; context)&#123;        // ***********    &#125;&#125;;class USTax : public TaxStrategy&#123;public:    virtual double Calculate(const Context&amp; context)&#123;        // ***********    &#125;&#125;;class DETax : public TaxStrategy&#123;public:    virtual double Calculate(const Context&amp; context)&#123;        // ***********    &#125;&#125;;// 从而方便地进行扩展// *********************************class FRTax : public TaxStrategy&#123;public:\tvirtual double Calculate(const Context&amp; context)&#123;\t\t//.........\t&#125;&#125;;class SalesOrder&#123; // 稳定private:    TaxStrategy* strategy;public:    SalesOrder(StrategyFactory* strategyFactory)&#123;        this-&gt;strategy = strategyFactory-&gt;NewStrategy(); // 工厂模式    &#125;    ~SalesOrder()&#123;        delete this-&gt;strategy;    &#125;    public double CalculateTax()&#123;        //...        Context context();        double val = strategy-&gt;Calculate(context); //多态调用        //...    &#125;&#125;;\n\n4 策略v2（可执行）/** * The Strategy interface declares operations common to all supported versions * of some algorithm. * * The Context uses this interface to call the algorithm defined by Concrete * Strategies. */class Strategy &#123;public:\tvirtual ~Strategy() = default;\tvirtual std::string doAlgorithm(const std::string&amp; data) const = 0;&#125;;// The Context defines the interface of interest to clients.class Context &#123;\t/**\t * The Context maintains a reference to one of the Strategy\t * objects. The Context does not know the concrete class of a strategy. It\t * should work with all strategies via the Strategy interface.\t */private:\tstd::unique_ptr&lt;Strategy&gt; strategy_;\t/**\t * Usually, the Context accepts a strategy through the constructor, but also\t * provides a setter to change it at runtime.\t */public:\texplicit Context(std::unique_ptr&lt;Strategy&gt; &amp;&amp;strategy = &#123;&#125;) : strategy_(std::move(strategy)) &#123;&#125;\t// Usually, the Context allows replacing a Strategy object at runtime.\tvoid set_strategy(std::unique_ptr&lt;Strategy&gt; &amp;&amp;strategy) &#123;\t\tstrategy_ = std::move(strategy);\t&#125;\t/**\t * The Context delegates some work to the Strategy object instead of\t * implementing +multiple versions of the algorithm on its own.\t */\tvoid doSomeBusinessLogic() const &#123;\t\tif (strategy_) &#123;\t\t\tstd::cout &lt;&lt; &quot;Context: Sorting data using the strategy (not sure how it&#x27;ll do it)\\n&quot;;\t\t\tstd::string result = strategy_-&gt;doAlgorithm(&quot;aecbd&quot;);\t\t\tstd::cout &lt;&lt; result &lt;&lt; &quot;\\n&quot;;\t\t&#125;\t\telse &#123;\t\t\tstd::cout &lt;&lt; &quot;Context: Strategy isn&#x27;t set\\n&quot;;\t\t&#125;\t&#125;&#125;;/** * Concrete Strategies implement the algorithm while following the base Strategy * interface. The interface makes them interchangeable in the Context. */class ConcreteStrategyA : public Strategy &#123;public:\tstd::string doAlgorithm(const std::string&amp; data) const override &#123;\t\tstd::string result(data);\t\tstd::sort(std::begin(result), std::end(result));\t\treturn result;\t&#125;&#125;;class ConcreteStrategyB : public Strategy &#123;\tstd::string doAlgorithm(const std::string&amp; data) const override &#123;\t\tstd::string result(data);\t\tstd::sort(std::begin(result), std::end(result), std::greater&lt;&gt;());\t\treturn result;\t&#125;&#125;;/** * The client code picks a concrete strategy and passes it to the context. The * client should be aware of the differences between strategies in order to make * the right choice. */void clientCode() &#123;\tContext context(std::make_unique&lt;ConcreteStrategyA&gt;());\tstd::cout &lt;&lt; &quot;Client: Strategy is set to normal sorting.\\n&quot;;\tcontext.doSomeBusinessLogic();\tstd::cout &lt;&lt; &quot;\\n&quot;;\tstd::cout &lt;&lt; &quot;Client: Strategy is set to reverse sorting.\\n&quot;;\tcontext.set_strategy(std::make_unique&lt;ConcreteStrategyB&gt;());\tcontext.doSomeBusinessLogic();&#125;int main() &#123;\tclientCode();\treturn 0;&#125;\n\n5 总结\nStrategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。\nStrategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。\n如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。（单例模式）\n\n6 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-迭代器模式","url":"/2022/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"1 迭代器模式\n在软件构建过程中，集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素;同时这种“诱明遍历”也为“同一种算法在多种集合对象上进行操作”提供了可能。\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（稳定）该对象的内部表示\n访问一个聚合对象的内容而无需暴露其内部实现；支持对聚合对象的多种遍历；为遍历不同的聚合结构提供统一的接口；健壮性考虑：遍历的同时更改迭代器所在聚合结构，会导致问题\n该篇介绍的是基于面向对象的迭代器实现，但是C++泛型编程迭代器已经淘汰掉面向对象的迭代器，然而思想一样，技术更新而已\n\n2 迭代器v1\n/*C++现在都是基于模板的迭代器，模板又称为编译时多态，速度肯定比虚函数的运行时多态要好很多但是java、C#、PHP、Swift还是这种基于虚函数的迭代器（因为不支持编译时的模板机制）*/template&lt;typename T&gt;class Iterator&#123;public:    virtual void first() = 0;    virtual void next() = 0;    virtual bool isDone() const = 0;    virtual T&amp; current() = 0;&#125;;template&lt;typename T&gt;class MyCollection&#123;public:    Iterator&lt;T&gt;* GetIterator()&#123;        // ...    &#125;&#125;;template&lt;typename T&gt;class CollectionIterator : public Iterator&lt;T&gt;&#123;    MyCollection&lt;T&gt; mc;public:    CollectionIterator(const MyCollection&lt;T&gt;&amp; c): mc(c)&#123; &#125;        void first() override &#123;        // ...    &#125;    void next() override &#123;        // ...    &#125;    bool isDone() const override&#123;        // ...    &#125;    T&amp; current() override&#123;        // ...    &#125;&#125;;void MyAlgorithm()&#123;    MyCollection&lt;int&gt; mc;    Iterator&lt;int&gt;* iter = mc.GetIterator();    for (iter-&gt;first(); !iter-&gt;isDone(); iter-&gt;next())&#123; // 多态        cout &lt;&lt; iter-&gt;current() &lt;&lt; endl; // 多态    &#125;&#125;\n\n3 迭代器v2（可执行）/** * C++ has its own implementation of iterator that works with a different * generics containers defined by the standard library. */template &lt;typename T, typename U&gt;class Iterator &#123;public:\ttypedef typename std::vector&lt;T&gt;::iterator iter_type;\tIterator(U *p_data) : m_p_data_(p_data) &#123;\t\tm_it_ = m_p_data_-&gt;m_data_.begin();\t&#125;\tvoid First() &#123;\t\tm_it_ = m_p_data_-&gt;m_data_.begin();\t&#125;\tvoid Next() &#123;\t\tm_it_++;\t&#125;\tbool IsDone() &#123;\t\treturn (m_it_ == m_p_data_-&gt;m_data_.end());\t&#125;\titer_type Current() &#123;\t\treturn m_it_;\t&#125;private:\tU *m_p_data_;\titer_type m_it_;&#125;;/** * Generic Collections/Containers provides one or several methods for retrieving * fresh iterator instances, compatible with the collection class. */template &lt;class T&gt;class Container &#123;\tfriend class Iterator&lt;T, Container&gt;;public:\tvoid Add(T a) &#123;\t\tm_data_.push_back(a);\t&#125;\tIterator&lt;T, Container&gt; *CreateIterator() &#123;\t\treturn new Iterator&lt;T, Container&gt;(this);\t&#125;private:\tstd::vector&lt;T&gt; m_data_;&#125;;class Data &#123;public:\tData(int a = 0) : m_data_(a) &#123;&#125;\tvoid set_data(int a) &#123;\t\tm_data_ = a;\t&#125;\tint data() &#123;\t\treturn m_data_;\t&#125;private:\tint m_data_;&#125;;/** * The client code may or may not know about the Concrete Iterator or Collection * classes, for this implementation the container is generic so you can used * with an int or with a custom class. */void ClientCode() &#123;\tstd::cout &lt;&lt; &quot;__________Iterator with int__________&quot; &lt;&lt; std::endl;\tContainer&lt;int&gt; cont;\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tcont.Add(i);\t&#125;\tIterator&lt;int, Container&lt;int&gt;&gt; *it = cont.CreateIterator();\tfor (it-&gt;First(); !it-&gt;IsDone(); it-&gt;Next()) &#123;\t\tstd::cout &lt;&lt; *it-&gt;Current() &lt;&lt; std::endl;\t&#125;\tContainer&lt;Data&gt; cont2;\tData a(100), b(1000), c(10000);\tcont2.Add(a);\tcont2.Add(b);\tcont2.Add(c);\tstd::cout &lt;&lt; &quot;__________Iterator with custom Class__________&quot; &lt;&lt; std::endl;\tIterator&lt;Data, Container&lt;Data&gt;&gt; *it2 = cont2.CreateIterator();\tfor (it2-&gt;First(); !it2-&gt;IsDone(); it2-&gt;Next()) &#123;\t\tstd::cout &lt;&lt; it2-&gt;Current()-&gt;data() &lt;&lt; std::endl;\t&#125;\tdelete it;\tdelete it2;&#125;int main() &#123;\tClientCode();\treturn 0;&#125;\n\n4 迭代器v3（可执行）template &lt;class Item&gt;class Iterator &#123;public:\tvirtual ~Iterator() &#123;&#125;\tvirtual bool hasNext() = 0;\tvirtual Item next() = 0;&#125;;template &lt;class Item&gt;class Aggregate&#123;public:\tvirtual ~Aggregate() &#123;&#125;\tvirtual Iterator&lt;Item&gt; *CreateIterator() = 0;&#125;;// 前置声明template &lt;class Item&gt;class BookSelfIterator;template &lt;class Item&gt;class BookSelf : public Aggregate&lt;Item&gt; &#123;public:\tBookSelf(int maxSize) &#123;\t\tm_books.resize(maxSize, std::string(&quot;&quot;));\t&#125;\tIterator&lt;Item&gt;* CreateIterator() override &#123;\t\treturn new BookSelfIterator&lt;Item&gt;(this); // 传入this\t&#125;\tItem GetBookAt(int index) const &#123;\t\treturn m_books.at(index);\t&#125;\tvoid appendBoox(const Item &amp;book) &#123;\t\tm_books.emplace_back(book);\t&#125;\tint length() const &#123;\t\treturn static_cast&lt;int&gt;(m_books.size());\t&#125;private:\tstd::vector&lt;Item&gt; m_books;&#125;;template &lt;class Item&gt;class BookSelfIterator : public Iterator&lt;Item&gt; &#123;public:\tBookSelfIterator(BookSelf&lt;Item&gt; *bookSelf) : m_bookSelf(bookSelf) &#123;&#125;\tvirtual bool hasNext() override &#123;\t\treturn m_bookSelf-&gt;length() &gt; 0 &amp;&amp; m_currentIndex &lt; m_bookSelf-&gt;length() - 1;\t&#125;\tvirtual Item next() override &#123;\t\tm_currentIndex++;\t\treturn m_bookSelf-&gt;GetBookAt(m_currentIndex);\t&#125;private:\tBookSelf&lt;Item&gt; *m_bookSelf;\tint m_currentIndex = -1;&#125;;class Book &#123;public:\tBook(const std::string &amp;name) : m_name(name) &#123;&#125;\tconst std::string &amp;GetName() &#123;\t\treturn m_name;\t&#125;private:\tstd::string m_name;&#125;;int main() &#123;\tBookSelf&lt;Book&gt; container(0);\tcontainer.appendBoox(Book(string(&quot;name1&quot;)));\tcontainer.appendBoox(Book(string(&quot;name2&quot;)));\tcontainer.appendBoox(Book(string(&quot;name3&quot;)));\tauto itor = container.CreateIterator();\twhile (itor-&gt;hasNext()) &#123;\t\tBook book = itor-&gt;next();\t\tcout &lt;&lt; book.GetName() &lt;&lt; endl;\t&#125;\tdelete itor;\treturn 0;&#125;\n\n5 总结\n迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。\n迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。\n迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。\n\n6 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-观察者模式","url":"/2022/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/","content":"1 观察者模式\n在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。\n定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。\n观察对象的状态发生变化时，通知给观察者。 观察者模式适用于根据对象状态进行相应处理的场景。\n\n2 问题// FileSplitter.cppclass FileSplitter&#123;\tstring m_filePath;\tint m_fileNumber;\tProgressBar* m_progressBar; // 不能应对变化，和具体某个平台的进度条绑死：例如UI进度条、无界面的Shell进度条等等public:\tFileSplitter(const string&amp; filePath, int fileNumber, ProgressBar* progressBar) :\t\tm_filePath(filePath), \t\tm_fileNumber(fileNumber),\t\tm_progressBar(progressBar)&#123;\t&#125;\tvoid split()&#123;\t\t//1.读取大文件\t\t// ...\t\t//2.分批次向小文件中写入\t\tfor (int i = 0; i &lt; m_fileNumber; i++)&#123;\t\t\t//...\t\t\tfloat progressValue = m_fileNumber;\t\t\tprogressValue = (i + 1) / progressValue;\t\t\tm_progressBar-&gt;setValue(progressValue);\t\t&#125;\t&#125;&#125;;\n// MainForm.cppclass MainForm : public Form&#123;\tTextBox* txtFilePath;\tTextBox* txtFileNumber;\tProgressBar* progressBar;public:\tvoid Button1_Click()&#123;\t\tstring filePath = txtFilePath-&gt;getText();\t\tint number = atoi(txtFileNumber-&gt;getText().c_str());\t\tFileSplitter splitter(filePath, number, progressBar);\t\tsplitter.split();\t&#125;&#125;;\n\n3 观察者v1\n// FileSplitter.cppclass FileSplitter&#123;\tstring m_filePath;\tint m_fileNumber;\tList&lt;IProgress*&gt;  m_iprogressList; // 抽象通知机制，支持注册多个观察者！！！\tpublic:\tFileSplitter(const string&amp; filePath, int fileNumber) :\t\tm_filePath(filePath), \t\tm_fileNumber(fileNumber)&#123;\t&#125;\tvoid split()&#123;\t\t//1.读取大文件\t\t// ...\t\t//2.分批次向小文件中写入\t\tfor (int i = 0; i &lt; m_fileNumber; i++)&#123;\t\t\t//...\t\t\tfloat progressValue = m_fileNumber;\t\t\tprogressValue = (i + 1) / progressValue;\t\t\tonProgress(progressValue); // 发送通知\t\t&#125;\t&#125;\tvoid addIProgress(IProgress* iprogress)&#123; // 添加观察者\t\tm_iprogressList.push_back(iprogress);\t&#125;\tvoid removeIProgress(IProgress* iprogress)&#123; // 移除观察者\t\tm_iprogressList.remove(iprogress);\t&#125;protected:\tvirtual void onProgress(float value)&#123;\t\tList&lt;IProgress*&gt;::iterator itor=m_iprogressList.begin();\t\twhile (itor != m_iprogressList.end())\t\t\t(*itor)-&gt;DoProgress(value); //更新进度条\t\t\titor++;\t\t&#125;\t&#125;&#125;;\n\n// MainForm.cppclass IProgress&#123;public:\tvirtual void DoProgress(float value)=0;\tvirtual ~IProgress()&#123;&#125;&#125;;// C++不推荐多继承，但是推荐的唯一一种多继承的形式是：一个主集成、其他都是接口或者抽象基类// MainForm是观察者class MainForm : public Form, public IProgress&#123;\tTextBox* txtFilePath;\tTextBox* txtFileNumber;\tProgressBar* progressBar;public:\tvoid Button1_Click()&#123;\t\tstring filePath = txtFilePath-&gt;getText();\t\tint number = atoi(txtFileNumber-&gt;getText().c_str());\t\tFileSplitter splitter(filePath, number);\t\tsplitter.addIProgress(this); // 订阅通知\t\tConsoleNotifier cn; // 观察者二\t\tsplitter.addIProgress(&amp;cn); // 订阅通知\t\tsplitter.split();\t\tsplitter.removeIProgress(this);\t&#125;\tvirtual void DoProgress(float value)&#123;\t\tprogressBar-&gt;setValue(value);\t&#125;&#125;;// 另一个观察者class ConsoleNotifier : public IProgress &#123;public:\tvirtual void DoProgress(float value)&#123;\t\tcout &lt;&lt; &quot;.&quot;; // 无UI：打点\t&#125;&#125;;\n\n4 观察者v2（可执行）#include &quot;Header.h&quot;#include &lt;random&gt;#include &lt;thread&gt;class NumGen;class NumGenObserver &#123;public:\tvirtual ~NumGenObserver() &#123;&#125;\tvirtual void update(NumGen *numGen) = 0;&#125;;class NumGen &#123;public:\tvirtual ~NumGen() &#123;&#125;\tvoid addObserve(NumGenObserver *observe) &#123;\t\tm_observeList.push_back(observe);\t&#125;\tvoid deleteObserve(NumGenObserver *observe) &#123;\t\tm_observeList.erase(std::remove(m_observeList.begin(), m_observeList.end(), observe));\t&#125;\tvoid notifyObverses() &#123;\t\tfor (auto gen : m_observeList) &#123;\t\t\tgen-&gt;update(this);\t\t&#125;\t&#125;\tvirtual int getNumber() = 0;\tvirtual void execute() = 0;private:\tstd::vector&lt;NumGenObserver *&gt; m_observeList;&#125;;class RandomNumGen : public NumGen &#123;public:\tvirtual int getNumber() override &#123;\t\treturn m_number;\t&#125;\tvirtual void execute() override &#123;\t\tfor (int i = 0; i &lt; 20; ++i) &#123;\t\t\tm_number = m_dis(m_gen);\t\t\tnotifyObverses();\t\t&#125;\t&#125;private:\tstd::random_device m_rd;\tstd::mt19937 m_gen&#123; m_rd() &#125;;\tstd::uniform_int_distribution&lt;int&gt; m_dis&#123; 0, 100 &#125;;\tint m_number&#123; 0 &#125;;&#125;;class DigitObserver : public NumGenObserver &#123;public:\tvirtual void update(NumGen *numGen) override &#123;\t\tstd::cout &lt;&lt; &quot;DigitObserver:&quot;;\t\tstd::cout &lt;&lt; numGen-&gt;getNumber() &lt;&lt; std::endl;\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\t&#125;&#125;;class GraphObserver : public NumGenObserver &#123;public:\tvirtual void update(NumGen *numGen) override &#123;\t\tauto num = numGen-&gt;getNumber();\t\tstd::cout &lt;&lt; &quot;GraphObserver:&quot;;\t\tfor (int i = 0; i &lt; num; ++i) &#123;\t\t\tstd::cout &lt;&lt; &quot;*&quot;;\t\t&#125;\t\tstd::cout &lt;&lt; std::endl;\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(10));\t&#125;&#125;;int main() &#123;\tNumGen *gen = new RandomNumGen;\tNumGenObserver *ob1 = new DigitObserver;\tNumGenObserver *ob2 = new GraphObserver;\tgen-&gt;addObserve(ob1);\tgen-&gt;addObserve(ob2);\tgen-&gt;execute();\tdelete gen;\tdelete ob1;\tdelete ob2;\treturn 0;&#125;\n\n5 观察者v3（配合模板更通用的观察者模式）template&lt;typename ObserverType&gt;class Subject &#123;    vector&lt;ObserverType*&gt; _list;public:    // 订阅    void subscribe(ObserverType* obs) &#123;        auto itor = std::find(_list.begin(), _list.end(), obs);        if (_list.end() == itor) &#123;            _list.push_back(obs);        &#125;    &#125;        // 取消订阅    void unSubscribe(ObserverType* obs) &#123;        // erase配合remove        _list.erase(std::remove(_list.begin(), _list.end(), obs));    &#125;    // 发布    template&lt;typename FuncType&gt;    void publish(FuncType func) &#123;        for (auto obs : _list) &#123;            // 调用回调函数，将obs作为一个参数传入            func(obs);        &#125;    &#125;&#125;;// CatObserver接口 猫的观察者class CatObserver &#123;public:    virtual void onMiaow() = 0;    virtual ~CatObserver() &#123;&#125;&#125;;// Tom继承自Subject，模板参数CatObserver// 这样Tom就可以订阅、发布对应类型class Tom : public Subject&lt;CatObserver&gt; &#123;public:    void miaow() &#123;        cout &lt;&lt; &quot;喵&quot; &lt;&lt; endl;        // 这里CatObserver的成员函数，所以第一个参数需要this指针，这里悬置-&gt;对应publish的object        publish(std::bind(&amp;CatObserver::onMiaow, std::placeholders::_1));    &#125;&#125;;// Jerry继承自CatObserver，可以被订阅class Jerry : public CatObserver &#123;public:    void onMiaow() override &#123;        RunAway();    &#125;    void RunAway() &#123;        cout &lt;&lt; &quot;那只笨又猫来了，快跑！&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    Tom tom;    Jerry jerry1, jerry2, jerry3;    // 拿一堆jerry去订阅tom的 猫叫 事件    tom.subscribe(&amp;jerry1);    tom.subscribe(&amp;jerry2);    tom.subscribe(&amp;jerry3);        tom.miaow();&#125;\n输出结果：\n喵那只笨又猫来了，快跑！那只笨又猫来了，快跑！那只笨又猫来了，快跑！\n\n6 总结\n使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。\n目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。\n观察者自己决定是否需要订阅通知，目标对象对此一无所知。\nObserver模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。\n\n7 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"设计模式-适配器模式","url":"/2022/07/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","content":"1 适配器模式\n在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。\n将一个类的接口转换成客户希望的另一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n\n2 适配器v1\n// 目标接口（新接口）class ITarget&#123;public:    virtual void process() = 0;&#125;;// 遗留接口（老接口）class IAdaptee&#123;public:    virtual void foo(int data) = 0;    virtual int bar() = 0;&#125;;// 遗留类型class OldClass: public IAdaptee&#123;public:    virtual void foo(int data)&#123;        // ...    &#125;    virtual int bar()&#123;        // ...    &#125;&#125;;// 对象适配器（推荐）class Adapter: public ITarget&#123; // 继承protected:    IAdaptee* pAdaptee; // 组合（多态）    public:    Adapter(IAdaptee* pAdaptee)&#123;        this-&gt;pAdaptee=pAdaptee;    &#125;        virtual void process()&#123;        int data=pAdaptee-&gt;bar();        pAdaptee-&gt;foo(data);    &#125;&#125;;// 类适配器（十分不推荐）class Adapter: public ITarget, protected OldClass&#123; // 多继承（无复用性，绑死OldClass）    // ...&#125;int main()&#123;    IAdaptee* pAdaptee = new OldClass(); // 老接口    ITarget* pTarget = new Adapter(pAdaptee);    pTarget-&gt;process();&#125;class stack&#123; // STL中stack包含deque，看作是种适配器    deqeue container;    // ...&#125;;class queue&#123; // STL中queue包含deque，看作是种适配器    deqeue container;    // ...&#125;;\n\n3 适配器v2（可执行）对象适配器（继承新+组合旧）\n// The Target defines the domain-specific interface used by the client code.class Target &#123;public:\tvirtual ~Target() = default;\tvirtual std::string Request() const &#123;\t\treturn &quot;Target: The default target&#x27;s behavior.&quot;;\t&#125;&#125;;/** * The Adaptee contains some useful behavior, but its interface is incompatible * with the existing client code. The Adaptee needs some adaptation before the * client code can use it. */class Adaptee &#123;public:\tstd::string SpecificRequest() const &#123;\t\treturn &quot;.eetpadA eht fo roivaheb laicepS&quot;;\t&#125;&#125;;/** * The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s * interface. */class Adapter : public Target &#123;private:\tAdaptee *adaptee_;public:\tAdapter(Adaptee *adaptee) : adaptee_(adaptee) &#123;&#125;\tstd::string Request() const override &#123;\t\tstd::string to_reverse = this-&gt;adaptee_-&gt;SpecificRequest();\t\tstd::reverse(to_reverse.begin(), to_reverse.end());\t\treturn &quot;Adapter: (TRANSLATED) &quot; + to_reverse;\t&#125;&#125;;// The client code supports all classes that follow the Target interface.void ClientCode(const Target *target) &#123;\tstd::cout &lt;&lt; target-&gt;Request();&#125;int main() &#123;\tstd::cout &lt;&lt; &quot;Client: I can work just fine with the Target objects:\\n&quot;;\tTarget *target = new Target;\tClientCode(target);\tstd::cout &lt;&lt; &quot;\\n\\n&quot;;\tAdaptee *adaptee = new Adaptee;\tstd::cout &lt;&lt; &quot;Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:\\n&quot;;\tstd::cout &lt;&lt; &quot;Adaptee: &quot; &lt;&lt; adaptee-&gt;SpecificRequest();\tstd::cout &lt;&lt; &quot;\\n\\n&quot;;\tstd::cout &lt;&lt; &quot;Client: But I can work with it via the Adapter:\\n&quot;;\tAdapter *adapter = new Adapter(adaptee);\tClientCode(adapter);\tstd::cout &lt;&lt; &quot;\\n&quot;;\tdelete target;\tdelete adaptee;\tdelete adapter;\treturn 0;&#125;\n\n\n4 总结\nAdapter模式主要应用于“希望复用一些现存的类，但是接口又与复用坏境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。\nGoF-23定义了两种Adapter模式的实现结构∶对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。\nAdapter模式可以实现的非常寻活，不必拘泥于GoF-23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的\n\n5 参考\n《设计模式》 GoF\n李建忠设计模式\nC++ 23种设计模式\n设计模式\n\n","tags":["设计模式"]},{"title":"读者写者问题","url":"/2021/08/27/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/","content":"\n经典读者写者问题\n\n读者写者问题1、读者优先int readcount=0; semaphore RCSignal=1, fileSrc=1;// RCSignal readcount修改互斥量// fileSrc 文件资源互斥量：实现读者优先// 读者进程：    P(RCSignal);    readcount++;\t    if (readcount == 1)        P(fileSrc);    V(RCSignal);    // ...    // reading is performed    // ...    P(RCSignal);    readcount--;    if (readcount == 0)        V(fileSrc);    V(RCSignal); // 写者进程：         P(fileSrc);    //...    //writing is performed    //...    V(fileSrc);\n\n2、写者优先int readcount=0, writecount=0; semaphore RCSignal=1, WCSignal=1, read=1, fileSrc;// RCSignal readcount修改互斥量// WCSignal writecount修改互斥量// read 实现写者优先：拦截读者// fileSrc 文件资源互斥量：保护剩余读者（拦截写者），以及写者唯一// 读者进程：P(read);    P(RCSignal);        readcount++;        if(readcount == 1 )             P(fileSrc);    V(RCSignal);V(read);    // ...    // reading is performed    // ...P(RCSignal);    readcount--;    if (readcount == 0 )        V(fileSrc);V(RCSignal);// 写者进程：     P(WCSingal);    writecount++;    if (writecount == 1 )        P(read);V(WCSingal);P(fileSrc);    // writing is performedV(fileSrc);P(WCSingal);    writecount --;    if (writecount == 0)        V(read);V(WCSingal); \n\n\n参考资料https://www.bilibili.com/video/av21593625https://blog.csdn.net/c1194758555/article/details/52805918https://blog.csdn.net/william_munch/article/details/84256690      （有问题？）\n","tags":["OS"]},{"title":"路径搜索","url":"/2022/04/07/%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2/","content":"辅助代码（全局变量）typedef pair&lt;int, int&gt; node;vector&lt;vector&lt;int&gt;&gt; G = &#123;    &#123;1,1,1,1,1,1,1,1,1,1,1&#125;,    &#123;1,1,1,1,1,1,1,1,1,1,1&#125;,    &#123;1,1,1,1,1,2,1,1,1,1,1&#125;,    &#123;1,1,1,1,2,3,2,1,1,1,1&#125;,    &#123;1,1,1,2,3,4,3,2,1,1,1&#125;,    &#123;1,1,2,3,4,5,4,3,2,1,1&#125;,    &#123;1,1,1,2,3,4,3,2,1,1,1&#125;,    &#123;1,1,1,1,2,3,2,1,1,1,1&#125;,    &#123;1,1,1,1,1,2,1,1,1,1,1&#125;,    &#123;1,1,1,1,1,1,1,1,1,1,1&#125;,    &#123;1,1,1,1,1,1,1,1,1,1,1&#125;&#125;;int row = (int)G.size();int col = (int)G[0].size();node S = &#123; 5,0 &#125;;node E = &#123; 5,10 &#125;;int dir[] = &#123; -1, 0, 1, 0, -1 &#125;;\n\nDFS\nDFS是无法找到最优路径的（理论上可以，但是复杂度巨高，如果是四个方向搜索的话，那么就是四叉树，高度是图中结点数，也就是说如果是10x10的图，那就是大约4^100复杂度）\n下面代码只表示找到任意一条路后直接返回\n\nvector&lt;vector&lt;bool&gt;&gt; visited(row, vector&lt;bool&gt;(col, false));vector&lt;node&gt; path;bool END = false;void dfs(node cur) &#123;    if (cur == E)         END = true;    visited[cur.first][cur.second] = true;    path.push_back(cur);    for (int i = 0; i &lt; 4 &amp;&amp; !END; ++i) &#123;        int ix = cur.first + dir[i];        int iy = cur.second + dir[i + 1];        if (ix &lt; 0 || ix &gt;= row || iy &lt; 0 || iy &gt;= col || visited[ix][iy]) continue;        dfs(&#123; ix, iy &#125;);    &#125;    if (END) return; // 保留路径    path.pop_back();    visited[cur.first][cur.second] = false;&#125;\n\nBFS\nBFS是可以找到最优路径的，每次到某点的距离变小时就将其加入队列\n不可以提前结束，无法确定是否能够通过后面的点来缩短到终点的距离\n\nvoid bfs() &#123;    queue&lt;node&gt; qe;    qe.push(S);    vector&lt;vector&lt;int&gt;&gt; dist(row, vector&lt;int&gt;(col, 10000));    dist[S.first][S.second] = 0;    while (!qe.empty()) &#123;        node cur = qe.front(); qe.pop();        for (int i = 0; i &lt; 4; ++i) &#123;            int ix = cur.first + dir[i];            int iy = cur.second + dir[i + 1];            if (ix &lt; 0 || ix &gt;= row || iy &lt; 0 || iy &gt;= col) continue;            if (dist[ix][iy] &gt; dist[cur.first][cur.second] + G[ix][iy]) &#123;                dist[ix][iy] = dist[cur.first][cur.second] + G[ix][iy];                qe.emplace(ix, iy);            &#125;        &#125;    &#125;&#125;\n\nDijkstra\n每次弹出优先队列的都是确定下来的最优解，因此可以接触终点时直接break提前结束\n也不需要visited数组，因为遇到重复的x和y时，优先队列会依照priority排列，大的自动排到后面，由于接触到终点直接break，那些非最优的都没机会弹出队列。\n你可能会想到有没有这种可能绕一个大圈然后使得到达终点的距离进一步降低？其实不可能的，因为优先队列的贪心思想，反证法：如果之前已经将E弹出，后面又经过X到达E使得dist(E)降低；但是既然后面再弹出的X，那证明X的dist比之前第一次弹出的E的dist要大(优先队列先弹出dist小的)，那如何能使得经过X后让E的dist减小呢？矛盾！\n\nstruct item&#123; // 存放在优先队列的结构体    int x;    int y;    int priority;    bool operator&gt;(const item&amp; ano) const &#123;        return this-&gt;priority &gt; ano.priority;    &#125;&#125;;void dijkstra() &#123;    priority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;    vector&lt;vector&lt;int&gt;&gt; dist(row, vector&lt;int&gt;(col, 1000)); // dist二维数组    qe.push(&#123; S.first, S.second, 0 &#125;); // 初始化    dist[S.first][S.second] = 0; // 初始化    while (!qe.empty()) &#123;        item cur = qe.top(); qe.pop();        // 找到后可以直接返回，这里贪心算法，确保是最优解        if (cur.x == E.first &amp;&amp; cur.y == E.second) break;        for (int i = 0; i &lt; 4; ++i) &#123;            int ix = cur.x + dir[i];            int iy = cur.y + dir[i + 1];            if (ix &lt; 0 || ix &gt;= row || iy &lt; 0 || iy &gt;= col) continue;            if (dist[ix][iy] &gt; cur.priority + G[ix][iy]) &#123;                dist[ix][iy] = cur.priority + G[ix][iy];                qe.push(&#123; ix, iy, dist[ix][iy] &#125;);            &#125;        &#125;    &#125;&#125;\n\nA星\nA星的思想是对Dijkstra的一点改进。首先BFS是没有方向的，Dijkstra是在BFS之上加入了贪心思想，但是同样没有方向，A星则是增加了终点方向的属性，并入到Dijkstra的优先级中，参与优先队列的弹出选择，对于能明确表明与终点距离的图问题来说，效果相当不错。\n\nstruct item&#123; // 存放在优先队列的结构体    int x;    int y;    int p1; // 从起点到该点的 dist (与实际图权值相关，如果无权图则退化为曼哈顿距离)    int p2; // 从该点到终点的 [曼哈顿距离]     bool operator&gt;(const item&amp; ano) const &#123;        return p1 + p2 &gt; ano.p1 + ano.p2;    &#125;&#125;;// 获取曼哈顿距离的函数auto getP2 = [&amp;](int x, int y) &#123;return abs(E.first - x) + abs(E.second - y); &#125;;void aStar() &#123;    priority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;    vector&lt;vector&lt;int&gt;&gt; dist(row, vector&lt;int&gt;(col, 1000)); // dist二维数组    qe.push(&#123; S.first, S.second, 0, getP2(S.first, S.second)&#125;); // 初始化    dist[S.first][S.second] = 0; // 初始化    while (!qe.empty()) &#123;        item cur = qe.top(); qe.pop();        // 找到后可以直接返回，这里贪心算法，确保是最优解        if (cur.x == E.first &amp;&amp; cur.y == E.second) break;        for (int i = 0; i &lt; 4; ++i) &#123;            int ix = cur.x + dir[i];            int iy = cur.y + dir[i + 1];            if (ix &lt; 0 || ix &gt;= row || iy &lt; 0 || iy &gt;= col) continue;            if (dist[ix][iy] &gt; cur.p1 + G[ix][iy]) &#123;                dist[ix][iy] = cur.p1 + G[ix][iy];                qe.push(&#123; ix, iy, dist[ix][iy], getP2(ix, iy) &#125;);            &#125;        &#125;    &#125;&#125;","tags":["算法","图"]},{"title":"逆序对","url":"/2022/09/01/%E9%80%86%E5%BA%8F%E5%AF%B9/","content":"逆序对计算1 归并排序归并排序天然就可统计逆序对，在归并时有以下两种方式统计：\n当左侧当前指针指向位置的数字CUR较小时，本轮将其加入归并后的数组，注意到右数组当前指针左边的都是小于CUR的，但是他们位置却在其右侧，所以逆序对贡献为l2-old_l2\nif (a &lt;= b) &#123; // 这里包含等于 可以用全1数组模拟想想    trr[p++] = arr[l1++];    ret += (l2-old_l2);&#125;else     trr[p++] = arr[l2++];\n当右侧当前指针指向位置的数字CUR较小时，本轮将其加入归并后的数组，注意到左数组当前指针及其右边都是大于CUR的，但是他们的位置却在其左侧，所以逆序对的贡献为old_l2 - l1\nif (a &lt;= b)  // 这里包含等于 可以用全1数组模拟想想    trr[p++] = arr[l1++];else &#123;    trr[p++] = arr[l2++];    ret += (old_l2 - l1);&#125;\n下面是完整代码\nclass Solution &#123;public:    int ret = 0;    void merge(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l1, int r1, int l2, int r2) &#123;        int l = l1, r = r2;        int p = l1, old_l2 = l2;        while (l1 &lt;= r1 || l2 &lt;= r2) &#123;            long long a = l1 &lt;= r1 ? arr[l1] : LLONG_MAX;            long long b = l2 &lt;= r2 ? arr[l2] : LLONG_MAX;            if (a &lt;= b) &#123; // !!!!! &lt;= 等于时也必须，不然右侧添加一堆等于的，再计算，结果肯定大了呀                trr[p++] = arr[l1++];                ret += (l2-old_l2); // 只需要在这里加上这句，收集逆序对            &#125;            else                 trr[p++] = arr[l2++];        &#125;        for (int i = l; i &lt;= r; ++i)            arr[i] = trr[i];    &#125;    void core(vector&lt;int&gt;&amp; arr, vector&lt;int&gt;&amp; trr, int l, int r) &#123;        if (l &gt;= r) return;        int m = (l + r) / 2;        core(arr, trr, l, m);        core(arr, trr, m + 1, r);        merge(arr, trr, l, m, m + 1, r);    &#125;    int reversePairs(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; trr(nums.size());        core(nums, trr, 0, (int)nums.size() - 1);        return ret;    &#125;&#125;;\n\n2 离散化+树状数组树状数组可以非常方便进行区间统计和单点修改，对于原数组，我们从后往前遍历，依次将其加入树状数组（计数），并求其左侧（小于的）之前的所有已插入的数字的和，最终即可求得总的逆序对。然而，原数组的数值范围波动较大，不能直接用树状数组去记录，其间必有许多0表现出极大的稀疏性，因此需要对原数组进行离散化。所谓离散化，即将原数组映射到1~N的数据范围，让数据的范围全部聚集在一起，减少空间浪费，有利于树状数组发挥。因为在该问题中我们不关心数据的绝对大小，仅关心数据的相对大小，所以可以离散化。离散化需要借助偏向的二分查找进行。\n对于数组[1,3,2,4,1]，离散化后的结果是1,4,3,5,1，程序处理过程中树状数组的变化为（树状数组0位弃用）：\n对于原数组 [1,4,3,5,1]从后往前遍历 1-&gt;5-&gt;3-&gt;4-&gt;1X    [0,0,0,0,0,0]   ret = 0 初始1    [0,1,1,0,1,0]   ret = 05    [0,1,1,0,1,1]   ret = 13    [0,1,1,1,2,1]   ret = 24    [0,1,1,1,3,1]   ret = 41    [0,2,2,1,4,1]   ret = 4最终逆序对即为4\n// 树状数组class Trr &#123;    vector&lt;int&gt; trr;public:    static int lowbit(int a) &#123; return a &amp; -a; &#125;    Trr(const vector&lt;int&gt;&amp; arr) : trr(arr.size() + 1) &#123;        for (int i = 0; i &lt; arr.size(); ++i) &#123;            int t = i + 1;            while (t &lt; trr.size()) &#123;                trr[t] += arr[i];                t += lowbit(t);            &#125;        &#125;    &#125;    int query(int n) &#123; // from 1        int ret = 0;        while (n) &#123;            ret += trr[n];            n -= lowbit(n);        &#125;        return ret;    &#125;    void update(int pos, int diff) &#123; // from 1        while (pos &lt; trr.size()) &#123;            trr[pos] += diff;            pos += lowbit(pos);        &#125;    &#125;&#125;;class Solution &#123;public:    int reversePairs(vector&lt;int&gt;&amp; nums) &#123;        // 离散化(nlogn)        vector&lt;int&gt; tmp(nums);        sort(tmp.begin(), tmp.end());        for (auto&amp; e : nums)            e = lower_bound(tmp.begin(), tmp.end(), e) - tmp.begin() + 1;        // 树状数组统计逆序对(nlogn)        Trr trr(vector&lt;int&gt;(nums.size())); // 初始化全0        int ret = 0;        for (int i = nums.size() - 1; i &gt;= 0; --i) &#123;            trr.update(nums[i], 1);            ret += trr.query(nums[i] - 1);        &#125;        return ret;    &#125;&#125;;\n\n小记\n已知的树状数组的两种用途\n原数组的下标作为索引，进行区间统计和修改\n原数组的值作为下标，进行区间计数（本题）\n\n\n\n","tags":["算法","特殊","树","排序"]},{"title":"链表去重","url":"/2022/03/20/%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","content":"83 删除排序链表中重复元素前序遍历class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head) return head;        ListNode* ptr = head-&gt;next;        while(ptr &amp;&amp; head-&gt;val == ptr-&gt;val) ptr = ptr-&gt;next;        // 下面俩方式效果一样        head-&gt;next = deleteDuplicates(ptr);        // head-&gt;next = ptr;        // deleteDuplicates(ptr);        return head;    &#125;&#125;;\n\n后续遍历class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head) return head;        // 有点像并查集里的路径压缩        head-&gt;next = deleteDuplicates(head-&gt;next);        if(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)            return head-&gt;next;        return head;    &#125;&#125;;\n\n迭代法class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (!head) return head;        ListNode* cur = head;        while (cur-&gt;next) &#123;            if (cur-&gt;val == cur-&gt;next-&gt;val)                 cur-&gt;next = cur-&gt;next-&gt;next;            else                 cur = cur-&gt;next;        &#125;        return head;    &#125;&#125;;\n\n迭代法：双指针class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        if (!head) return head;        ListNode* slow = head, *fast = head;        while(fast)&#123;            if(fast-&gt;val != slow-&gt;val)&#123;                slow-&gt;next = fast;                slow = slow-&gt;next;            &#125;            fast = fast-&gt;next;        &#125;        slow-&gt;next = nullptr; // 别忘了        return head;    &#125;&#125;;// 类似于数组去重，一模一样class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        if(nums.empty()) return 0;        int slow = 0, fast = 0;        while(fast &lt; nums.size())&#123;            if(nums[slow] != nums[fast])&#123;                nums[++slow] = nums[fast];            &#125;            ++fast;        &#125;        return slow + 1;    &#125;&#125;;\n\n82 删除排序链表中的重复元素Ⅱ递归class Solution &#123;public:    int prev = INT_MAX;    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head || !head-&gt;next)&#123;            if(head) prev = head-&gt;val;            return head;        &#125;        head-&gt;next = deleteDuplicates(head-&gt;next);        while(head &amp;&amp; head-&gt;val == prev) // 如果要delete，在这里            head = head-&gt;next;        if(head &amp;&amp; head-&gt;val &lt; prev) // 小于号很重要，因为是递增链表，防止prev更新旧值            prev = head-&gt;val;        return head;    &#125;&#125;;\n\n递归2(类似83后续遍历)class Solution &#123;public:    int prev = INT_MIN;    ListNode* deleteDuplicates(ListNode* head) &#123;        if(!head) return head;        // 有点像并查集里的路径压缩        head-&gt;next = deleteDuplicates(head-&gt;next);        if(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;            prev = head-&gt;val;            return head-&gt;next-&gt;next;        &#125;        if(head-&gt;val == prev)            return head-&gt;next;        return head;    &#125;&#125;;\n\n迭代class Solution &#123;public:    ListNode* deleteDuplicates(ListNode* head) &#123;        ListNode* dummy = new ListNode(INT_MAX, head);        ListNode* ptr = dummy;        while(ptr)&#123;            ListNode* cur = ptr-&gt;next;            while(cur &amp;&amp; cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;                cur = cur-&gt;next;            &#125;            if(cur == ptr-&gt;next) // 下一步没重复，放心走                ptr = ptr-&gt;next;            else // 有重复 cur必不为nullptr，否则就是没重复那步                ptr-&gt;next = cur-&gt;next;        &#125;        return dummy-&gt;next;    &#125;&#125;;","tags":["算法","特殊"]},{"title":"链表排序","url":"/2022/04/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","content":"1. 插入排序\n只要注意每次判断比前面的大那就不需要回头\n否则需要从头找合适的位置\n\nListNode* insertSort(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode dummy; dummy.next = head;    ListNode* prev = head;    ListNode* curr = head-&gt;next;    while (curr) &#123;        if (prev-&gt;val &lt;= curr-&gt;val) &#123;            prev = curr;            curr = curr-&gt;next;        &#125; else &#123;            ListNode* t = &amp;dummy;            while (t-&gt;next &amp;&amp; t-&gt;next-&gt;val &lt;= curr-&gt;val) t = t-&gt;next;            prev-&gt;next = curr-&gt;next;            curr-&gt;next = t-&gt;next;            t-&gt;next = curr;            curr = prev-&gt;next;        &#125;    &#125;    return dummy.next;&#125;\n\n2. 归并排序\n不论是主递归还是merge都要求两个链表以nullptr结尾\n也就是在合适的地方断开\n\n2.1 递归版本ListNode* mergeTwoList(ListNode* p2a, ListNode* p2b) &#123;    ListNode dummy;    ListNode* ptr = &amp;dummy;    while (p2a || p2b) &#123;        int a = p2a ? p2a-&gt;val : INT_MAX;        int b = p2b ? p2b-&gt;val : INT_MAX;        if (a &lt; b) &#123;            ptr-&gt;next = p2a;            p2a = p2a-&gt;next;        &#125;        else &#123;            ptr-&gt;next = p2b;            p2b = p2b-&gt;next;        &#125;        ptr = ptr-&gt;next; // 别忘了    &#125;    return dummy.next;&#125;ListNode* mergeSort(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode* slow = head, *fast = head;    while (fast) &#123; // 链表快慢指针有多种形式，要会灵活运用        fast = fast-&gt;next;        if(fast) fast = fast-&gt;next;        if(fast) slow = slow-&gt;next; // if(fast)：slow指向第一个链表的最后一位结点    &#125;    ListNode* head2 = slow-&gt;next;    slow-&gt;next = nullptr;    return mergeTwoList(mergeSort(head), mergeSort(head2));&#125;\n\n2.2 非递归版本ListNode* mergeTwoList(ListNode* p2a, ListNode* p2b) &#123;    ListNode dummy;    ListNode* ptr = &amp;dummy;    while (p2a || p2b) &#123;        int a = p2a ? p2a-&gt;val : INT_MAX;        int b = p2b ? p2b-&gt;val : INT_MAX;        if (a &lt; b) &#123;            ptr-&gt;next = p2a;            p2a = p2a-&gt;next;        &#125;        else &#123;            ptr-&gt;next = p2b;            p2b = p2b-&gt;next;        &#125;        ptr = ptr-&gt;next; // 别忘了    &#125;    return dummy.next;&#125;ListNode* mergeSort(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    int n = 0;    ListNode* ptr = head;    while (ptr) &#123; // 统计链表长度        ++n;        ptr = ptr-&gt;next;    &#125;    ListNode dummy;    dummy.next = head;    ptr = &amp;dummy;    ListNode* prev, *l, *r, *t, *next; // 屮，5个指针    for (int w = 1; w &lt; n; w &lt;&lt;= 1) &#123;        prev = &amp;dummy;        l = dummy.next;        r = nullptr;        while (l) &#123;            // 第一个子链表的最后一个元素 注意：i从1开始            t = l;            for (int i = 1; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;            r = nullptr;            if (t) &#123;                r = t-&gt;next;                t-&gt;next = nullptr;            &#125;            // 第二个子链表的最后一个元素 注意：i从1开始            t = r;            for (int i = 1; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;            next = nullptr;            if (t) &#123;                next = t-&gt;next;                t-&gt;next = nullptr;            &#125;            // 合并子链表            ListNode* ret = mergeTwoList(l, r);            prev-&gt;next = ret;            // prev指向合并后的子链表的最后一个元素            while (prev-&gt;next) prev = prev-&gt;next;            l = next;        &#125;    &#125;    return dummy.next;&#125;\n\n3. 快速排序\n其实对于链表，由于不需要额外空间，归并排序其实很优秀了；快速排序由于需要选取pivot，选的不好，会变成n^2，而归并排序是稳定的nlogn\npivot的选取可以将中点节点移到链头充当pivot或者随机一个节点充当pivot，否则对于有序数列，会退化为n^2\n由于无法采用l和r两边向中间靠拢的方式划分集合，只能采用单边形式，所以遇到“窄数据”或者都是一样值（窄特例化），也会退化为n^2\n\nListNode* quickSort(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    int pivot = head-&gt;val;    ListNode L, R;    ListNode* l = &amp;L, *r = &amp;R;    ListNode* ptr = head-&gt;next;    while (ptr) &#123;        if (ptr-&gt;val &lt;= pivot) &#123;            l-&gt;next = ptr;            l = l-&gt;next;        &#125;        else &#123;            r-&gt;next = ptr;            r = r-&gt;next;        &#125;        ptr = ptr-&gt;next;    &#125;    l-&gt;next = nullptr; // 断尾    r-&gt;next = nullptr; // 断尾    l = quickSort(L.next);    r = quickSort(R.next);    head-&gt;next = r;    if (!l) return head;    ListNode* t = l;    while (t-&gt;next) t = t-&gt;next;    t-&gt;next = head;    return l;&#125;\n\n取中间作为pivot\n\nListNode* quickSort(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode* slow = head, *fast = head;    while (fast) &#123;        fast = fast-&gt;next;        if (fast) fast = fast-&gt;next;        if (fast) slow = slow-&gt;next;    &#125;    ListNode* newHead = slow-&gt;next;    slow-&gt;next = newHead-&gt;next;    newHead-&gt;next = head;    int pivot = newHead-&gt;val;    ListNode L, R;    ListNode* l = &amp;L, *r = &amp;R;    ListNode* ptr = newHead-&gt;next;    while (ptr) &#123;        if (ptr-&gt;val &lt;= pivot) &#123;            l-&gt;next = ptr;            l = l-&gt;next;        &#125;        else &#123;            r-&gt;next = ptr;            r = r-&gt;next;        &#125;        ptr = ptr-&gt;next;    &#125;    l-&gt;next = nullptr; // 断尾    r-&gt;next = nullptr; // 断尾    l = quickSort(L.next);    r = quickSort(R.next);    newHead-&gt;next = r;    if (!l) return newHead;    ListNode* t = l;    while (t-&gt;next) t = t-&gt;next;    t-&gt;next = newHead;    return l;&#125;\n\n4. 辅助代码struct ListNode&#123;    int val;    ListNode* next;    ListNode(int _v = 0) :val(_v), next(nullptr) &#123;&#125;&#125;;ListNode* genList(int n, int range) &#123; // 数目， 分布范围    ListNode dummy;    ListNode* ptr = &amp;dummy;    for (int i = 0; i &lt; n; ++i) &#123;        int r = rand() % range;        ListNode* tmp = new ListNode(r);        ptr-&gt;next = tmp;        ptr = ptr-&gt;next;    &#125;    return dummy.next;&#125;void parseList(ListNode* p, bool show=true) &#123;    int ret = 0;    int cnt = 0;    while (p) &#123;        if(show) cout &lt;&lt; p-&gt;val &lt;&lt; &quot;\\t&quot;;        p = p-&gt;next;        ++cnt;        if (show &amp;&amp; cnt / 10) &#123;            ret += cnt;            cnt = 0;            cout &lt;&lt; endl;        &#125;    &#125;    ret += cnt;    cout &lt;&lt; &quot;总计:&quot;&lt;&lt; ret &lt;&lt; endl;&#125;int main() &#123;    ListNode* ptr = genList(1000, 1000);    parseList(ptr, true);    // ptr = yourSort(ptr);    parseList(ptr, true);    return 0;&#125;","tags":["算法","排序"]}]