[{"title":"Bitcpy","url":"/2021/06/24/Bitcpy/","content":"<blockquote>\n<p><strong>两种bitcpy的实现方式</strong></p>\n</blockquote>\n<h3 id=\"1-显示数据bits\"><a href=\"#1-显示数据bits\" class=\"headerlink\" title=\"1. 显示数据bits\"></a>1. 显示数据bits</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HALF_WORD   uint16_t</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WORD        uint32_t</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showBits</span><span class=\"params\">(<span class=\"type\">void</span>* d, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> bytes = len / <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span>* p = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)d;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; bytes; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span> tmp = <span class=\"number\">0x80</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">8</span>; j++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (tmp &amp; *p)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">\t\t\ttmp &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">\t\t++p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-bitcpy-算术方式\"><a href=\"#2-bitcpy-算术方式\" class=\"headerlink\" title=\"2. bitcpy 算术方式\"></a>2. bitcpy 算术方式</h3><p><strong>拷贝方式是从单个字节的低位开始拷贝，进位式拷贝。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitcopy</span><span class=\"params\">(<span class=\"type\">void</span>* to, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> tOfs, <span class=\"type\">int</span> tCnt, <span class=\"type\">const</span> <span class=\"type\">void</span>* from, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> fOfs, <span class=\"type\">int</span> fCnt)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> BitsOfHalfWord = <span class=\"built_in\">sizeof</span>(HALF_WORD) * <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// align data and offset to HALF_WORD</span></span><br><span class=\"line\">\tto = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)to + (tOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\tfrom = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)from + (fOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\tfOfs %= BitsOfHalfWord;</span><br><span class=\"line\">\ttOfs %= BitsOfHalfWord;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> NbrOfCopiedBits = <span class=\"number\">0</span>, bCnt = (fCnt &lt; tCnt) ? fCnt : tCnt;</span><br><span class=\"line\">\tWORD rMask, wMask;</span><br><span class=\"line\">\tWORD temp, * _to = (WORD*)to, * _from = (WORD*)from;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (bCnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// update counter</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;</span><br><span class=\"line\">\t\tbCnt -= BitsToCopy;</span><br><span class=\"line\">\t\tNbrOfCopiedBits += BitsToCopy;</span><br><span class=\"line\">\t\t<span class=\"comment\">// mask reading from &#x27;_from&#x27; and mask writing to &#x27;_to&#x27;</span></span><br><span class=\"line\">\t\trMask = (((WORD)<span class=\"number\">-1</span>) &lt;&lt; fOfs) ^ (((WORD)<span class=\"number\">-1</span>) &lt;&lt; (fOfs + BitsToCopy));</span><br><span class=\"line\">\t\twMask = (((WORD)<span class=\"number\">-1</span>) &lt;&lt; tOfs) ^ (((WORD)<span class=\"number\">-1</span>) &lt;&lt; (tOfs + BitsToCopy));</span><br><span class=\"line\">\t\t<span class=\"built_in\">showBits</span>(&amp;rMask, <span class=\"number\">32</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">showBits</span>(&amp;wMask, <span class=\"number\">32</span>);</span><br><span class=\"line\">\t\ttemp = (*_from &amp; rMask) &gt;&gt; fOfs &lt;&lt; tOfs;</span><br><span class=\"line\">\t\t*_to &amp;= ~wMask;</span><br><span class=\"line\">\t\t*_to |= temp;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d bit(s) copied\\n&quot;</span>, BitsToCopy);</span><br><span class=\"line\">\t\t<span class=\"comment\">// increase data pointer if copy is not completed</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (BitsToCopy == BitsOfHalfWord) &#123;</span><br><span class=\"line\">\t\t\t_to = (WORD*)((<span class=\"type\">intptr_t</span>)_to + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\t\t\t_from = (WORD*)((<span class=\"type\">intptr_t</span>)_from + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">showBits</span>(to, <span class=\"number\">64</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NbrOfCopiedBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-bitcpy-物理方式\"><a href=\"#3-bitcpy-物理方式\" class=\"headerlink\" title=\"3. bitcpy 物理方式\"></a>3. bitcpy 物理方式</h3><p><strong>物理左移</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">WORD <span class=\"title\">shiftLeft</span><span class=\"params\">(WORD w, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span>* s = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)&amp;w;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (len--) &#123;</span><br><span class=\"line\">\t\t*(s) &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*(s + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*(s + i) &amp; <span class=\"number\">0x80</span>)</span><br><span class=\"line\">\t\t\t\t*(s + i - <span class=\"number\">1</span>) |= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t*(s + i) &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>物理右移</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">WORD <span class=\"title\">shiftRight</span><span class=\"params\">(WORD w, <span class=\"type\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">char</span>* s = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>*)&amp;w;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (len--) &#123;</span><br><span class=\"line\">\t\t*(s+<span class=\"number\">3</span>) &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*(s + i) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (*(s + i) &amp; <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t\t*(s + i + <span class=\"number\">1</span>) |= <span class=\"number\">0x80</span>;</span><br><span class=\"line\">\t\t\t*(s + i) &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> w;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>拷贝方式是按照实际的物理bit位进行顺序拷贝的</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitcpy</span><span class=\"params\">(<span class=\"type\">void</span>* to, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> tOfs, <span class=\"type\">const</span> <span class=\"type\">void</span>* from, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> fOfs, <span class=\"type\">int</span> bCnt)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> BitsOfHalfWord = <span class=\"built_in\">sizeof</span>(HALF_WORD) * <span class=\"number\">8</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 将数据和偏置对其“半字”</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指针视为intptr_t，加1则前进一个Byte，且更安全（适用于将指针进行算术运算时使用）</span></span><br><span class=\"line\">\tto = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)to + (tOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\tfrom = (<span class=\"type\">void</span>*)((<span class=\"type\">intptr_t</span>)from + (fOfs / BitsOfHalfWord) * <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\tfOfs %= BitsOfHalfWord;</span><br><span class=\"line\">\ttOfs %= BitsOfHalfWord;</span><br><span class=\"line\">\t<span class=\"type\">int</span> NbrOfCopiedBits = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tWORD rMask, wMask;</span><br><span class=\"line\">\tWORD temp;</span><br><span class=\"line\">\tWORD *_to = (WORD*)to;</span><br><span class=\"line\">\tWORD *_from = (WORD*)from;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (bCnt &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> BitsToCopy = (bCnt &lt; BitsOfHalfWord) ? bCnt : BitsOfHalfWord;</span><br><span class=\"line\">\t\tbCnt -= BitsToCopy;</span><br><span class=\"line\">\t\tNbrOfCopiedBits += BitsToCopy;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 源与目标的遮罩</span></span><br><span class=\"line\">\t\trMask = <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, fOfs) ^ <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, fOfs + BitsToCopy);</span><br><span class=\"line\">\t\twMask = <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, tOfs) ^ <span class=\"built_in\">shiftRight</span>((WORD)<span class=\"number\">-1</span>, tOfs + BitsToCopy);</span><br><span class=\"line\">\t\ttemp = (*_from &amp; rMask);</span><br><span class=\"line\">\t\ttemp = <span class=\"built_in\">shiftLeft</span>(temp, fOfs);</span><br><span class=\"line\">\t\ttemp = <span class=\"built_in\">shiftRight</span>(temp, tOfs);</span><br><span class=\"line\">\t\t*_to &amp;= ~wMask;\t<span class=\"comment\">// 先清理此部分</span></span><br><span class=\"line\">\t\t*_to |= temp;\t<span class=\"comment\">// 在“拷贝”进来</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 拷贝未完成情况下，跟进指针</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (BitsToCopy == BitsOfHalfWord) &#123;</span><br><span class=\"line\">\t\t\t_to = (WORD*)((<span class=\"type\">intptr_t</span>)_to + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\t\t\t_from = (WORD*)((<span class=\"type\">intptr_t</span>)_from + <span class=\"built_in\">sizeof</span>(HALF_WORD));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> NbrOfCopiedBits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-运行效果\"><a href=\"#4-运行效果\" class=\"headerlink\" title=\"4. 运行效果\"></a>4. 运行效果</h3><p><img src=\"https://raw.githubusercontent.com/fkjkkll/My-Algorithm/master/Others/Bitcpy/BitcpyResult.png\" alt=\"\"></p>\n","tags":["C/C++"]},{"title":"C++ priority_queue自定义排序","url":"/2021/10/31/C-priority-queue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/","content":"<blockquote>\n<p><strong>C++ priority_queue自定义排序总结</strong></p>\n</blockquote>\n<h3 id=\"方法一：函数指针\"><a href=\"#方法一：函数指针\" class=\"headerlink\" title=\"方法一：函数指针\"></a>方法一：函数指针</h3><p>以下几种都可以，具体可参考《C++ Primer》</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef int elem;</span><br><span class=\"line\">bool cmp(elem a, elem b) &#123;</span><br><span class=\"line\">    return a &lt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, decltype(&amp;cmp)&gt; q(arr.begin(), arr.end(), cmp);</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, decltype(cmp)*&gt; q(arr.begin(), arr.end(), cmp);</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, bool(*)(elem, elem)&gt; q(arr.begin(), arr.end(), cmp);</span><br><span class=\"line\">// 构造函数前两个可以不填，但是必须传入cmp</span><br><span class=\"line\">// 前面模板只是告诉它是一个函数指针bool(*)(elem, elem)，但并没有传入函数地址（实体）</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, bool(*)(elem, elem)&gt; q(cmp);</span><br></pre></td></tr></table></figure>\n<p><strong>对于cmp和&amp;cmp你应该这样理解，cmp是函数的首地址，它的类型是bool(elem,  elem)，&amp;cmp表示一个指向函数cmp这个对象的地址，它的类型是bool(*)(elem, elem)，因此test和&amp;test所代表的地址的值是一样的，但类型不一样！</strong></p>\n<h3 id=\"方法二：重载运算符\"><a href=\"#方法二：重载运算符\" class=\"headerlink\" title=\"方法二：重载运算符\"></a>方法二：重载运算符</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct elem &#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    int b;</span><br><span class=\"line\">    bool operator&lt;(const elem&amp; another) const &#123;</span><br><span class=\"line\">        return this-&gt;b &lt; another.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, less&lt;elem&gt;&gt; q;</span><br></pre></td></tr></table></figure>\n<p>注意：operator函数要有const，这是能构成重载的，否则未找到对应函数报错</p>\n<h3 id=\"方法三：仿函数\"><a href=\"#方法三：仿函数\" class=\"headerlink\" title=\"方法三：仿函数\"></a>方法三：仿函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">struct elem &#123;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    int b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct cmp &#123;</span><br><span class=\"line\">    bool operator()(const elem&amp; left, const elem&amp; right) &#123;</span><br><span class=\"line\">        return left.b &lt; right.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">priority_queue&lt;elem, vector&lt;elem&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>\n","tags":["C/C++"]},{"title":"Hexo说明","url":"/2021/06/28/Hexo%E8%AF%B4%E6%98%8E/","content":"<blockquote>\n<p><strong>Hexo相关说明</strong></p>\n</blockquote>\n<h2 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h2><p><a href=\"https://blog.csdn.net/guixinchn/article/details/107787660\">安装hexo</a></p>\n<h2 id=\"Hexo基本语法\"><a href=\"#Hexo基本语法\" class=\"headerlink\" title=\"Hexo基本语法\"></a>Hexo基本语法</h2><p>hexo n “我的博客” == hexo new “我的博客” //新建文章<br>hexo g == hexo generate //生成<br>hexo s == hexo server //启动服务预览<br>hexo d == hexo deploy //部署</p>\n<p>hexo server //Hexo会监视文件变动并自动更新，无须重启服务器<br>hexo server -s //静态模式<br>hexo server -p 5000 //更改端口<br>hexo server -i 192.168.1.1 //自定义 IP<br>hexo clean //清除缓存，若是网页正常情况下可以忽略这条命令</p>\n<h3 id=\"Hexo相关\"><a href=\"#Hexo相关\" class=\"headerlink\" title=\"Hexo相关\"></a>Hexo相关</h3><ol>\n<li>自动展开设置1：<a href=\"https://blog.csdn.net/yueyue200830/article/details/104470646\">显示部分摘要</a></li>\n<li>自动展开设置2：<a href=\"https://www.zhihu.com/question/394167076\">显示部分摘要</a></li>\n<li>hexo显示公式乱码问题：<a href=\"https://www.cnblogs.com/zhyantao/p/10424874.html\">公式乱码问题</a></li>\n<li><a href=\"https://www.cnblogs.com/study-everyday/p/8902136.html\">如何在另一台电脑使用hexo更新博客</a></li>\n</ol>\n<h3 id=\"Github相关\"><a href=\"#Github相关\" class=\"headerlink\" title=\"Github相关\"></a>Github相关</h3><p>如果无法deploy到Github，此时打开命令行输入<code>ping github.com</code>又失败，则可能是梯子的原因，无法进行DNS，即使关掉梯子也不行。此时可以手动在电脑的hosts文件里添加到Github的域名到ip映射，具体操作如下：</p>\n<ol>\n<li>在<a href=\"https://ipaddress.com/website/github.com\">IP查询网页</a>搜索github，找到github的网站地址</li>\n<li>进入<code>C:\\Windows\\System32\\drivers\\etc</code>修改hosts</li>\n<li>由于需要权限所以<strong>以管理员模式</strong>打开cmd，cd到hosts，然后输入<code>notepad hosts</code>即可进行修改添加，只需插入<code>IP www.github.com和IP github.com</code>保存即可</li>\n</ol>\n<h3 id=\"主题相关\"><a href=\"#主题相关\" class=\"headerlink\" title=\"主题相关\"></a>主题相关</h3><ol>\n<li><a href=\"http://home.ustc.edu.cn/~liujunyan/blog/hexo-next-theme-config/\">NEXT常用配置</a></li>\n<li><a href=\"https://blog.csdn.net/qq_52116176/article/details/109406842\">背景图片修改问题</a></li>\n<li><a href=\"https://www.zhihu.com/question/29017171\">tags无法显示问题</a></li>\n<li><a href=\"https://blog.csdn.net/Domino_b/article/details/81704118\">next动画速度修改</a></li>\n</ol>\n","tags":["Others"]},{"title":"LC-124-543 二叉树最大和","url":"/2022/03/19/LC-124-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"<h1 id=\"1-124-二叉树中的最大路径和\"><a href=\"#1-124-二叉树中的最大路径和\" class=\"headerlink\" title=\"1. 124 二叉树中的最大路径和\"></a>1. 124 <a href=\"https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\">二叉树中的最大路径和</a></h1><h3 id=\"1-1-两个递归的笨方法\"><a href=\"#1-1-两个递归的笨方法\" class=\"headerlink\" title=\"1.1 两个递归的笨方法\"></a>1.1 两个递归的笨方法</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span> </span>&#123; <span class=\"comment\">// 找到以root为起点，深入向下的最大路径一条线（分叉只走一条）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">core</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(lv, rv), <span class=\"number\">0</span>) + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">recursion</span><span class=\"params\">(TreeNode* root)</span></span>&#123; <span class=\"comment\">// 遍历树中每个结点，尝试寻找本题答案的“起点根”</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">core</span>(root-&gt;left); <span class=\"comment\">// 以左孩子为起点的“线”</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">core</span>(root-&gt;right); <span class=\"comment\">// 以右孩子为起点的“线”</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lv &lt; <span class=\"number\">0</span>) lv = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rv &lt; <span class=\"number\">0</span>) rv = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, lv + rv + root-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">recursion</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-一个递归的好方法\"><a href=\"#1-2-一个递归的好方法\" class=\"headerlink\" title=\"1.2 一个递归的好方法\"></a>1.2 一个递归的好方法</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 递归计算左右子节点的最大贡献值</span></span><br><span class=\"line\">        <span class=\"comment\">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lv = <span class=\"built_in\">max</span>(<span class=\"built_in\">core</span>(root-&gt;left), <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> rv = <span class=\"built_in\">max</span>(<span class=\"built_in\">core</span>(root-&gt;right), <span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> ifAnsRoot = root-&gt;val + lv + rv;</span><br><span class=\"line\">        ans = <span class=\"built_in\">max</span>(ans, ifAnsRoot);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(lv, rv) + root-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxPathSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-543-二叉树的直径\"><a href=\"#2-543-二叉树的直径\" class=\"headerlink\" title=\"2. 543 二叉树的直径\"></a>2. 543 <a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\">二叉树的直径</a></h1><h2 id=\"这些问题都有共性：递归主线依旧，所求是副产物\"><a href=\"#这些问题都有共性：递归主线依旧，所求是副产物\" class=\"headerlink\" title=\"这些问题都有共性：递归主线依旧，所求是副产物\"></a><strong>这些问题都有共性：递归主线依旧，所求是副产物</strong></h2><h3 id=\"2-1-两个递归的笨方法\"><a href=\"#2-1-两个递归的笨方法\" class=\"headerlink\" title=\"2.1 两个递归的笨方法\"></a>2.1 两个递归的笨方法</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">core</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l, r) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">diameterOfBinaryTree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">diameterOfBinaryTree</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"type\">int</span> m = <span class=\"built_in\">core</span>(root-&gt;left) + <span class=\"built_in\">core</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(m, <span class=\"built_in\">max</span>(l, r));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-一个递归的好方法\"><a href=\"#2-2-一个递归的好方法\" class=\"headerlink\" title=\"2.2 一个递归的好方法\"></a>2.2 一个递归的好方法</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归主线还是算高度，直径是 [副产品]</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(TreeNode* root)</span></span>&#123; <span class=\"comment\">// 给定根节点，计算最长深度节点数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"built_in\">core</span>(root-&gt;left); <span class=\"comment\">// 左儿子为根的子树的深度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> r = <span class=\"built_in\">core</span>(root-&gt;right); <span class=\"comment\">// 右儿子为根的子树的深度</span></span><br><span class=\"line\">        res = <span class=\"built_in\">max</span>(res, l + r); <span class=\"comment\">// 在这里更新res，不用+1，因为路径长度是总结点长度-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(l, r) + <span class=\"number\">1</span>; <span class=\"comment\">// 返回该节点为根的子树的最长深度节点数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">core</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","tags":["算法","递归","树"]},{"title":"LC-1143-718 最长子序列子数组问题","url":"/2022/03/20/LC-1143-718-%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/","content":"<h1 id=\"1143-最长公共子序列\"><a href=\"#1143-最长公共子序列\" class=\"headerlink\" title=\"1143 最长公共子序列\"></a>1143 <a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">最长公共子序列</a></h1><ul>\n<li><strong>子序列是可以不连续的</strong></li>\n<li><strong>dp[i][j]的含义是text1[:i]和text2[:j]最长公共子序列，这个最长公共子序列不一定包含text1[i]和text2[j]</strong><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = text1.<span class=\"built_in\">size</span>(), n = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// 多一行一列</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1[i<span class=\"number\">-1</span>] == text2[j<span class=\"number\">-1</span>]) dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>; <span class=\"comment\">// 别忘了坐标偏移</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i][j] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"718-最长重复子数组\"><a href=\"#718-最长重复子数组\" class=\"headerlink\" title=\"718 最长重复子数组\"></a>718 <a href=\"https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/\">最长重复子数组</a></h1><ul>\n<li><strong>子数组是连续的</strong></li>\n<li><strong>dp[i][j]的含义是以nums1[i]结尾的nums1[:i]和以nums2[j]结尾的nums2[:j]的最长重复子数组</strong><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = nums1.<span class=\"built_in\">size</span>(), n = nums2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m+<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n+<span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; ++j)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums1[i<span class=\"number\">-1</span>] == nums2[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    ret = <span class=\"built_in\">max</span>(ret, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误1\"><a href=\"#错误1\" class=\"headerlink\" title=\"错误1\"></a>错误1</h2>如果里面写成这样：<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(nums1[i<span class=\"number\">-1</span>] == nums2[j<span class=\"number\">-1</span>]) dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span> dp[i][j] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[m][n];</span><br></pre></td></tr></table></figure>\n则是处理非连续的“数组子序列”，对于<code>[0,1,1,1,1]和[1,0,1,0,1]</code>给出的答案是3，但是正确答案应该是2<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  <span class=\"number\">1</span>   *<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  <span class=\"number\">2</span>   *<span class=\"number\">2</span>  <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   *<span class=\"number\">1</span>  *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  *<span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"错误2\"><a href=\"#错误2\" class=\"headerlink\" title=\"错误2\"></a>错误2</h2><p>如果里面写成这样：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][j] == <span class=\"built_in\">max</span>(<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]), dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">ret = <span class=\"built_in\">max</span>(ret, dp[i][j]);</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">return</span> ret;</span><br></pre></td></tr></table></figure><br>则属于<strong>彻底混淆</strong>了自己对于dp数组的定义，一定要是<strong>以nums1[i]结尾</strong>的子数组和<strong>以nums1[j]结尾</strong>的子数组的最长子数组，对于<code>[1,0,0,0,1]和[1,0,0,1,1]</code>给出的答案是4，但是正确答案应该是3<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   *<span class=\"number\">2</span>  *<span class=\"number\">2</span>  <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">2</span>  <span class=\"number\">3</span>   *<span class=\"number\">3</span>  <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   *<span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正确DP图</span></span><br><span class=\"line\">X | X   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\">——————————————————————————</span><br><span class=\"line\">X | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">2</span>   <span class=\"number\">1</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> | <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">3</span>   <span class=\"number\">2</span>   <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> | <span class=\"number\">0</span>   <span class=\"number\">1</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">0</span>   <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n","tags":["算法","动态规划"]},{"title":"LC-32 最长有效括号","url":"/2022/03/19/LC-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","content":"<h1 id=\"32-最长有效括号\"><a href=\"#32-最长有效括号\" class=\"headerlink\" title=\"32 最长有效括号\"></a>32 <a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\">最长有效括号</a></h1><h2 id=\"方法1：动态规划\"><a href=\"#方法1：动态规划\" class=\"headerlink\" title=\"方法1：动态规划\"></a>方法1：动态规划</h2><h3 id=\"1-1-错误1\"><a href=\"#1-1-错误1\" class=\"headerlink\" title=\"1.1 错误1\"></a>1.1 错误1</h3><p><strong>无法解决诸如<code>(())</code>的问题。</strong> 要考虑到当前碰到右括号后，前面的是左括号还是右括号，然后分别进行处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>]; <span class=\"comment\">// BUG</span></span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-错误2\"><a href=\"#1-2-错误2\" class=\"headerlink\" title=\"1.2 错误2\"></a>1.2 错误2</h3><p><strong>无法解决诸如<code>()(())</code>的问题。</strong> </p>\n<ol>\n<li><code>*****()</code> 好解决直接 <code>dp[i] += dp[i-2];</code></li>\n<li><code>*****))</code> 需要额外判断找到与当前右括号 $i$ 对应的左括号 $t$，然后 $t$ 的左边要继续判断<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span> &amp;&amp; i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;)&#x27;</span>) dp[i] += dp[i<span class=\"number\">-1</span>]; <span class=\"comment\">// 这里要继续修改</span></span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-正确答案\"><a href=\"#1-3-正确答案\" class=\"headerlink\" title=\"1.3 正确答案\"></a>1.3 正确答案</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                ++l; </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l)&#123;</span><br><span class=\"line\">                --l;</span><br><span class=\"line\">                dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span> &amp;&amp; i<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>) dp[i] += dp[i<span class=\"number\">-2</span>];</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                    dp[i] += dp[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-dp[i]&gt;=<span class=\"number\">0</span>) <span class=\"comment\">//添加这里</span></span><br><span class=\"line\">                        dp[i] += dp[i-dp[i]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ret = <span class=\"built_in\">max</span>(ret, dp[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-官方的DP（LC官方）-Elegant\"><a href=\"#1-4-官方的DP（LC官方）-Elegant\" class=\"headerlink\" title=\"1.4 官方的DP（LC官方）(Elegant)\"></a>1.4 官方的DP（LC官方）(Elegant)</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 只有以&#x27;)&#x27;结尾的才有效</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i<span class=\"number\">-2</span> &lt; <span class=\"number\">0</span>) dp[i] = <span class=\"number\">2</span>; <span class=\"comment\">// 防止越界</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> dp[i] = dp[i<span class=\"number\">-2</span>] + <span class=\"number\">2</span>; <span class=\"comment\">// 转移函数</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; s[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                    dp[i] = dp[i<span class=\"number\">-1</span>] + <span class=\"number\">2</span>; <span class=\"comment\">// 转移函数</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span> &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        dp[i] += dp[i-dp[i<span class=\"number\">-1</span>]<span class=\"number\">-2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"方法2：栈（LC官方）\"><a href=\"#方法2：栈（LC官方）\" class=\"headerlink\" title=\"方法2：栈（LC官方）\"></a>方法2：栈（LC官方）</h2><p>保持栈底元素为当前已经遍历过的元素中 <strong>「最后一个没有被匹配的右括号的下标」</strong> 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">        stk.<span class=\"built_in\">push</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) stk.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(stk.<span class=\"built_in\">empty</span>()) <span class=\"comment\">// 更新「最后一个没有被匹配的右括号的下标」</span></span><br><span class=\"line\">                    stk.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    res = <span class=\"built_in\">max</span>(res, i-stk.<span class=\"built_in\">top</span>()); <span class=\"comment\">// 以i结尾的有效性括号长度</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法3：贪心（LC官方）\"><a href=\"#方法3：贪心（LC官方）\" class=\"headerlink\" title=\"方法3：贪心（LC官方）\"></a>方法3：贪心（LC官方）</h2><p>利用两个计数器 $l和r$ ，从左到右遍历字符串，遇到左括号则 $l加1$ ，遇到右括号则 $r加1$ ；当 $l和r$ 相等时更新最长长度，当 $r&gt;l时将l和r置0$</p>\n<p>这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。</p>\n<p>解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：当 $r&lt;l 时将 l 和 r 置0$ 。</p>\n<p>这样我们就能涵盖所有情况从而求解出答案。<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;s.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ++r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l == r) res = <span class=\"built_in\">max</span>(res, l + r);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(r &gt; l) l = r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l = r = <span class=\"number\">0</span>; <span class=\"comment\">// 重置！</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=s.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>) ++l;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> ++r;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l == r) res = <span class=\"built_in\">max</span>(res, l + r);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(l &gt; r) l = r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","tags":["算法","动态规划","贪心","栈"]},{"title":"LC-33-153-162 旋转数组二分","url":"/2022/03/21/LC-33-153-162-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86/","content":"<h1 id=\"162-寻找峰值\"><a href=\"#162-寻找峰值\" class=\"headerlink\" title=\"162 寻找峰值\"></a>162 <a href=\"https://leetcode-cn.com/problems/find-peak-element/\">寻找峰值</a></h1><p>找到任意一个峰值，你可以假设 nums[-1] = nums[n] = -∞ 。</p>\n<h2 id=\"二分法（不怎么优雅）\"><a href=\"#二分法（不怎么优雅）\" class=\"headerlink\" title=\"二分法（不怎么优雅）\"></a>二分法（不怎么优雅）</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m<span class=\"number\">-1</span>&gt;=<span class=\"number\">0</span> &amp;&amp; nums[m<span class=\"number\">-1</span>]&gt;nums[m]) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(m+<span class=\"number\">1</span>&lt;nums.<span class=\"built_in\">size</span>() &amp;&amp; nums[m+<span class=\"number\">1</span>]&gt;nums[m])</span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 永远不会走</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分法（优雅）\"><a href=\"#二分法（优雅）\" class=\"headerlink\" title=\"二分法（优雅）\"></a>二分法（优雅）</h2><p><strong>其实只要搞清楚我们「二分」什么内容，根本不会存在说用哪种方式才能写过的情况。</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findPeakElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 这里m+1不会越界，因为l &lt;= m &lt; r，所以m-1是可能越界的，m+1必然不会越界</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &gt; nums[m+<span class=\"number\">1</span>])</span><br><span class=\"line\">                r = m;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"153-寻找旋转排序数组中的最小值\"><a href=\"#153-寻找旋转排序数组中的最小值\" class=\"headerlink\" title=\"153 寻找旋转排序数组中的最小值\"></a>153 <a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">寻找旋转排序数组中的最小值</a></h1><p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/LC-153.png\" alt=\"图解\"></p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><ul>\n<li>如上图所示，如果每次以 $nums[l] &lt; nums[m]$ 为条件虽然可以认定左区间是单调的，但是就全局最小值而言无法区分图1和图2的；但是以 $nums[m] &lt; nums[r]$ 可以认定右区间单调，且可以区分所有最小值情况。一定要理解二分时收缩区间的含义。</li>\n<li>不能动不动l = m+1，r = m-1这种大起大和的方式，因为目的是求极值而不是target，target不等于的时候，某一边确实可以跳；但是求极值时，例如下面代码中r = m，因为不确定nums[m]是不是极值，所以不能写成r = m - 1。<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMin</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &lt; nums[r])</span><br><span class=\"line\">                r = m; <span class=\"comment\">// 注意</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;  <span class=\"comment\">// 注意</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为什么左右不对称？为什么比较mid与right而不比较mid与left？能不能通过比较mid与left来解决问题？<br><br>左右不对称的原因是：这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。<br><br>为什么比较mid与right而不比较mid与left？具体原因前面已经分析过了，简单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。<br><br>那么能不能通过比较mid与left来解决问题？能，转换思路，不直接找最小值，而是先找最大值，最大值偏右，可以通过比较mid与left来找到最大值，最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）。<br><br>作者：armeria-program<br>链接：<a href=\"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/\">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/</a> 来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"33-搜索旋转排序数组\"><a href=\"#33-搜索旋转排序数组\" class=\"headerlink\" title=\"33 搜索旋转排序数组\"></a>33 <a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">搜索旋转排序数组</a></h1><h2 id=\"二分法（易理解）\"><a href=\"#二分法（易理解）\" class=\"headerlink\" title=\"二分法（易理解）\"></a>二分法（易理解）</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 因为如果就俩数，除以二肯定l == m, r == m+1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] == nums[m])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(r &lt; n &amp;&amp; nums[r] == target) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[l] &lt; nums[m])&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[m]) </span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 右边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二分法（优雅）-1\"><a href=\"#二分法（优雅）-1\" class=\"headerlink\" title=\"二分法（优雅）\"></a>二分法（优雅）</h2><ul>\n<li><strong>牢记：左区间是[l, m]，右区间是[m+1, r]，所以“左区间正常”包含等号</strong></li>\n<li>由于前一步 <code>if(nums[m] == target) return m;</code> 已经判定了 $nums[m] != target$ ，所以后面对target和nums[m]的比较<strong>不带等号</strong><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), l = <span class=\"number\">0</span>, r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[l] &lt;= nums[m])&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= nums[l] &amp;&amp; target &lt; nums[m]) </span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> </span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 右边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; nums[m] &amp;&amp; target &lt;= nums[r])</span><br><span class=\"line\">                    l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2022-08-10\"><a href=\"#2022-08-10\" class=\"headerlink\" title=\"2022.08.10\"></a>2022.08.10</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while等号和不等号</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] &lt; arr[r])&#123; <span class=\"comment\">// 右边正常（互不相同所以没等于）</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[l] == target?l:<span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt;= r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] == target) <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[m] &lt; arr[r])&#123; <span class=\"comment\">// 右边正常（互不相同所以没等于）</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt; arr[m] &amp;&amp; target&lt;=arr[r]) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 左边正常</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(target &gt;= arr[l] &amp;&amp; target&lt;arr[m]) r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","tags":["算法","二分法"]},{"title":"LC-43 字符串相乘","url":"/2022/03/19/LC-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/","content":"<h1 id=\"43-字符串相乘\"><a href=\"#43-字符串相乘\" class=\"headerlink\" title=\"43 字符串相乘\"></a>43 <a href=\"https://leetcode-cn.com/problems/multiply-strings/\">字符串相乘</a></h1><p><em>两数A位和B位，相加后位数最大为 $max(A, B)+1$；相乘后最大位数为$A+B$</em></p>\n<h3 id=\"1-1-常规法\"><a href=\"#1-1-常规法\" class=\"headerlink\" title=\"1.1 常规法\"></a>1.1 常规法</h3><p>将两个串的指针位置 $m$ 和 $n$ 、进位 $c$ 统一放入while循环，代码就会很<strong>优美</strong>。 代码可以继续优化速度存储：addtion函数改为原地相加，但是会破坏代码的逻辑性，就不改了。<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">addtion</span><span class=\"params\">(string&amp; num1, string&amp; num2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = num1.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>, n = num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">        string ret;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m&gt;=<span class=\"number\">0</span> || n&gt;=<span class=\"number\">0</span> || c)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = m&gt;=<span class=\"number\">0</span> ? num1[m]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> b = n&gt;=<span class=\"number\">0</span> ? num2[n]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">            <span class=\"type\">int</span> s = a + b + c;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + s % <span class=\"number\">10</span>);</span><br><span class=\"line\">            c = s / <span class=\"number\">10</span>;</span><br><span class=\"line\">            --m, --n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(ret.<span class=\"built_in\">begin</span>(), ret.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 反转</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num1==<span class=\"string\">&quot;0&quot;</span> || num2==<span class=\"string\">&quot;0&quot;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        string res = <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>; <span class=\"comment\">// 记录表示每次乘完左移的0的个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> m = num2.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> n = num1.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> b = num2[m] - <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"function\">string <span class=\"title\">ret</span><span class=\"params\">(cnt, <span class=\"string\">&#x27;0&#x27;</span>)</span></span>; <span class=\"comment\">// 初始化&quot;左移&quot;0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(n&gt;=<span class=\"number\">0</span> || c)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> a = n&gt;=<span class=\"number\">0</span> ? num1[n]-<span class=\"string\">&#x27;0&#x27;</span> : <span class=\"number\">0</span>; <span class=\"comment\">// 越界定0技巧</span></span><br><span class=\"line\">                <span class=\"type\">int</span> s = a * b + c;</span><br><span class=\"line\">                ret.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;0&#x27;</span> + s % <span class=\"number\">10</span>);</span><br><span class=\"line\">                c = s / <span class=\"number\">10</span>;</span><br><span class=\"line\">                --n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(ret.<span class=\"built_in\">begin</span>(), ret.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 反转</span></span><br><span class=\"line\">            res = <span class=\"built_in\">addtion</span>(res, ret);</span><br><span class=\"line\">            --m, ++cnt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-2-优化竖式-LC高赞-很难想到啊\"><a href=\"#1-2-优化竖式-LC高赞-很难想到啊\" class=\"headerlink\" title=\"1.2 优化竖式 (LC高赞)(很难想到啊)\"></a>1.2 优化竖式 (LC高赞)(很难想到啊)</h3><p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/LC-43-字符串相乘-1.png\" alt=\"说明图\"><br>num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">multiply</span><span class=\"params\">(string num1, string num2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num1 == <span class=\"string\">&quot;0&quot;</span> || num2 == <span class=\"string\">&quot;0&quot;</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;0&quot;</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = num1.<span class=\"built_in\">size</span>(), n = num2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">temp</span><span class=\"params\">(m+n, <span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// 数组哦</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=m<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=n<span class=\"number\">-1</span>; j&gt;=<span class=\"number\">0</span>; --j)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> cur = (num1[i]-<span class=\"string\">&#x27;0&#x27;</span>) * (num2[j]-<span class=\"string\">&#x27;0&#x27;</span>) + temp[i+j+<span class=\"number\">1</span>];</span><br><span class=\"line\">                temp[i+j+<span class=\"number\">1</span>] = cur % <span class=\"number\">10</span>; <span class=\"comment\">// 存储计算结果低位 =</span></span><br><span class=\"line\">                temp[i+j] += cur / <span class=\"number\">10</span>; <span class=\"comment\">// 存储计算结果高位 +=</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        string ret; ret.<span class=\"built_in\">reserve</span>(m+n);</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&lt;temp.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 去掉前缀0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp[i] != <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; i&lt;temp.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 放入字符串</span></span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">char</span>(temp[i] + <span class=\"string\">&#x27;0&#x27;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","tags":["算法","字符串"]},{"title":"LC-470 Rand7实现Rand10","url":"/2022/03/19/LC-470-Rand7%E5%AE%9E%E7%8E%B0Rand10/","content":"<h1 id=\"470-用-Rand7-实现-Rand10\"><a href=\"#470-用-Rand7-实现-Rand10\" class=\"headerlink\" title=\"470 用 Rand7() 实现 Rand10()\"></a>470 <a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">用 Rand7() 实现 Rand10()</a></h1><h2 id=\"1-拒绝采样\"><a href=\"#1-拒绝采样\" class=\"headerlink\" title=\"1. 拒绝采样\"></a>1. 拒绝采样</h2><p>在解LC-470前先介绍一道拒绝采样的经典问题：利用频率近似概率的方式求出Pi的值。在$1\\times1$的方块内随机坐标采样，记录落入以原点为圆心，半径为1的$\\frac{1}{4}$圆内的次数。</p>\n<p>由$\\frac{1}{4}\\pi r^2 = \\frac{cnt}{N}$ 可得 $\\pi = \\frac{4\\times cnt}{N\\times r^2}$ ，由于$r=1$，所以$\\pi = \\frac{4\\times cnt}{N}$<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">srand</span>((<span class=\"type\">unsigned</span>)<span class=\"built_in\">time</span>(<span class=\"number\">0</span>)); <span class=\"comment\">// time(0)表示从1970到现在的秒数</span></span><br><span class=\"line\">    <span class=\"type\">int</span> N = (<span class=\"type\">int</span>)<span class=\"number\">1e7</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i++) &#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> a = (<span class=\"number\">1.0</span> * <span class=\"built_in\">rand</span>() / RAND_MAX); <span class=\"comment\">// 除以RAND_MAX归一化0~1</span></span><br><span class=\"line\">        <span class=\"type\">double</span> b = (<span class=\"number\">1.0</span> * <span class=\"built_in\">rand</span>() / RAND_MAX);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a * a + b * b &lt; <span class=\"number\">1.0</span>) cnt++; <span class=\"comment\">// 落入1/4圆则加一</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lf&quot;</span>, (<span class=\"number\">4.0</span> * cnt) / N);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-LC-470-Rand7生成Rand10\"><a href=\"#2-LC-470-Rand7生成Rand10\" class=\"headerlink\" title=\"2. LC-470 Rand7生成Rand10\"></a>2. LC-470 Rand7生成Rand10</h2><p><a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/\">力扣高赞题解</a></p>\n<p><strong>(rand_X() - 1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数</strong><br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rand10</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 等概率生成[1,49]范围的随机数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> num = (<span class=\"built_in\">rand7</span>()<span class=\"number\">-1</span>)*<span class=\"number\">7</span> + <span class=\"built_in\">rand7</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 拒绝采样，并返回[1,10]范围的随机数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num &lt;= <span class=\"number\">40</span>) <span class=\"keyword\">return</span> num % <span class=\"number\">10</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","tags":["算法"]},{"title":"LC-540 二分变种","url":"/2022/03/21/LC-540-%E4%BA%8C%E5%88%86%E5%8F%98%E7%A7%8D/","content":"<h1 id=\"540-有序数组中的单一元素\"><a href=\"#540-有序数组中的单一元素\" class=\"headerlink\" title=\"540 有序数组中的单一元素\"></a>540 <a href=\"https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\">有序数组中的单一元素</a></h1><h2 id=\"我的二分\"><a href=\"#我的二分\" class=\"headerlink\" title=\"我的二分\"></a>我的二分</h2><ul>\n<li>与右侧配对失败:<ul>\n<li>右侧是奇数: <code>l = m + 1</code></li>\n<li>右侧是偶数: <code>r = m</code></li>\n</ul>\n</li>\n<li>与右侧配对成功:<ul>\n<li>右侧是奇数: <code>l = m + 2</code></li>\n<li>右侧是偶数: <code>r = m - 1</code><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123; <span class=\"comment\">// 这样可以放心取m+1不越界</span></span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] != nums[m+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((r-m) &amp; <span class=\"number\">1</span>) l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((r-m<span class=\"number\">-1</span>) &amp; <span class=\"number\">1</span>) l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> r = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"官方的全数组二分查找\"><a href=\"#官方的全数组二分查找\" class=\"headerlink\" title=\"官方的全数组二分查找\"></a>官方的全数组二分查找</h2><ul>\n<li>假设要找的是数字X，则在X左边的数，下标是偶数的都是重复数字的第一位，下标是奇数的都是重复数字的第二位；在X右边的数，下标是奇数的都是重复数字的第一位，下标是偶数的都是重复数字的第二位；</li>\n<li>取中值时，若m是偶数，则尝试与m+1比较是否相等，相等则表明[:m+1]正常，X在m+1的右侧，因此<code>l = m + 2</code>；若不相等，则X在[:m]，因此<code>r = m</code></li>\n<li>取中值时，若m是奇数，则尝试与m-1比较是否相等，相等则表明[:m]正常，X在m的右侧，因此<code>l = m + 1</code>；若不相等，则X在[:m]，因此<code>r = m</code><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((m &amp; <span class=\"number\">1</span>) &amp;&amp; nums[m] == nums[m<span class=\"number\">-1</span>])&#123; <span class=\"comment\">// 奇数</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(!(m &amp; <span class=\"number\">1</span>) &amp;&amp; nums[m] == nums[m+<span class=\"number\">1</span>])&#123; <span class=\"comment\">// 偶数</span></span><br><span class=\"line\">                l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li>上述思想可以在代码层面进行简化<code>m ^ 1</code>，对于偶数表示<code>m + 1</code>；对于奇数表示<code>m - 1</code>，同时照顾到短板，每次更新<code>l</code>时，有<code>l = m + 1</code><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[m] == nums[m ^ <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// 这是技巧</span></span><br><span class=\"line\">                l = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"官方的偶数范围二分查找\"><a href=\"#官方的偶数范围二分查找\" class=\"headerlink\" title=\"官方的偶数范围二分查找\"></a>官方的偶数范围二分查找</h2></li>\n<li>X的下标一定是偶数<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNonDuplicate</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">            m -= m &amp; <span class=\"number\">1</span>; <span class=\"comment\">// 变为偶数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[m] == nums[m + <span class=\"number\">1</span>]) &#123; <span class=\"comment\">// [...m+1]都ok</span></span><br><span class=\"line\">                l = m + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r = m;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[l];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","tags":["算法","二分法"]},{"title":"LC-78-90-39-40-46-47 子集组合排列","url":"/2022/03/20/LC-78-90-39-40-46-47-%E5%AD%90%E9%9B%86%E7%BB%84%E5%90%88%E6%8E%92%E5%88%97/","content":"<h1 id=\"零-子集、组合和排列问题汇总\"><a href=\"#零-子集、组合和排列问题汇总\" class=\"headerlink\" title=\"零. 子集、组合和排列问题汇总\"></a>零. 子集、组合和排列问题汇总</h1><ul>\n<li>组合问题和子集问题是等价的</li>\n<li>参考<a href=\"https://labuladong.gitee.io/algo/4/30/110/\">labuladong</a>和优秀题解</li>\n</ul>\n<h1 id=\"一-子集问题\"><a href=\"#一-子集问题\" class=\"headerlink\" title=\"一. 子集问题\"></a>一. 子集问题</h1><h2 id=\"78-子集划分\"><a href=\"#78-子集划分\" class=\"headerlink\" title=\"78 子集划分\"></a>78 <a href=\"https://leetcode-cn.com/problems/subsets/\">子集划分</a></h2><h3 id=\"1-1-子集扩张\"><a href=\"#1-1-子集扩张\" class=\"headerlink\" title=\"1.1 子集扩张\"></a>1.1 子集扩张</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;(<span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">        <span class=\"type\">int</span> last = nums.<span class=\"built_in\">back</span>(); nums.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; sub = <span class=\"built_in\">subsets</span>(nums);</span><br><span class=\"line\">        <span class=\"type\">int</span> sz = sub.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;sz; ++i)&#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; tmp = sub[i];</span><br><span class=\"line\">            tmp.<span class=\"built_in\">push_back</span>(last);</span><br><span class=\"line\">            sub.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sub;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-回溯1\"><a href=\"#1-2-回溯1\" class=\"headerlink\" title=\"1.2 回溯1\"></a>1.2 回溯1</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        tmp.<span class=\"built_in\">push_back</span>(nums[pos]);</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, pos+<span class=\"number\">1</span>);</span><br><span class=\"line\">        tmp.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, pos+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-回溯2-★\"><a href=\"#1-3-回溯2-★\" class=\"headerlink\" title=\"1.3 回溯2(★)\"></a>1.3 回溯2(★)</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; tmp;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            tmp.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">traceback</span>(nums, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">            tmp.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsets</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"90-子集划分Ⅱ\"><a href=\"#90-子集划分Ⅱ\" class=\"headerlink\" title=\"90 子集划分Ⅱ\"></a>90 <a href=\"https://leetcode-cn.com/problems/subsets-ii/\">子集划分Ⅱ</a></h2><ol>\n<li>两条值相同的相邻树枝会产生重复，如果<strong>一个节点</strong>有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历</li>\n<li><strong>“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。</strong> 我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重。（注意：这里的同一树层指的是由同一个父节点引出的子节点，叔伯的子节点可以用相同下一个值，比如下图[1]接2和[2]接2，都可以用2；但是[1]接2就不能接2’了！）</li>\n</ol>\n<p><img src=\"https://labuladong.gitee.io/algo/images/排列组合/9.jpeg\" alt=\"labuladong图示 LC-90\"></p>\n<h3 id=\"2-1-回溯1\"><a href=\"#2-1-回溯1\" class=\"headerlink\" title=\"2.1 回溯1\"></a>2.1 回溯1</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; t;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ans;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(<span class=\"type\">bool</span> choosePre, <span class=\"type\">int</span> cur, vector&lt;<span class=\"type\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == nums.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">false</span>, cur + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 要在 [选] 之前执行，要在 [不选] 之后执行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!choosePre &amp;&amp; cur &gt; <span class=\"number\">0</span> &amp;&amp; nums[cur - <span class=\"number\">1</span>] == nums[cur]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        t.<span class=\"built_in\">push_back</span>(nums[cur]);</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">true</span>, cur + <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">        t.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(<span class=\"literal\">false</span>, <span class=\"number\">0</span>, nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-回溯2-★\"><a href=\"#2-2-回溯2-★\" class=\"headerlink\" title=\"2.2 回溯2(★)\"></a>2.2 回溯2(★)</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// i从pos开始，天然可以判定同一父节点的子节点们不会重复</span></span><br><span class=\"line\">            <span class=\"comment\">// 即只让重复段的第一个节点的树向下生长</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果i从0开始，无法确定pos-1位置是否使用过，需要</span></span><br><span class=\"line\">            <span class=\"comment\">// 借助一个used数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; pos &amp;&amp; nums[i] == nums[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i+<span class=\"number\">1</span>);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 要排序</span></span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-回溯2（易读版利用used判断树层重复）\"><a href=\"#2-3-回溯2（易读版利用used判断树层重复）\" class=\"headerlink\" title=\"2.3 回溯2（易读版利用used判断树层重复）\"></a>2.3 回溯2（易读版利用used判断树层重复）</h3><p>也可用used数组来简化理解，$nums[i]$与$nums[i-1]$相等，且$nums[i-1]$没有使用的情况下，表明重复了，因为只有在$nums[i-1]$用过之后才会不用，而$nums[i-1]$之前用过，其后的子树是已经加入到结果了，即可跳过当前点<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtracking</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class=\"line\">        ret.<span class=\"built_in\">push_back</span>(path);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = pos; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// used[i-1] == true，说明同一树支nums[i-1]使用过</span></span><br><span class=\"line\">            <span class=\"comment\">// used[i-1] == false，说明同一树层nums[i-1]使用过</span></span><br><span class=\"line\">            <span class=\"comment\">// 而我们要对同一树层使用过的元素进行跳过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>] &amp;&amp; !used[i<span class=\"number\">-1</span>])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            path.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtracking</span>(nums, i + <span class=\"number\">1</span>, used);</span><br><span class=\"line\">            path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">subsetsWithDup</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 去重需要排序</span></span><br><span class=\"line\">        <span class=\"built_in\">backtracking</span>(nums, <span class=\"number\">0</span>, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"二-组合问题\"><a href=\"#二-组合问题\" class=\"headerlink\" title=\"二. 组合问题\"></a>二. 组合问题</h1><h2 id=\"39-组合总数\"><a href=\"#39-组合总数\" class=\"headerlink\" title=\"39 组合总数\"></a>39 <a href=\"https://leetcode-cn.com/problems/combination-sum/\">组合总数</a></h2><h3 id=\"1-1-回溯\"><a href=\"#1-1-回溯\" class=\"headerlink\" title=\"1.1 回溯\"></a>1.1 回溯</h3><p>nums中的每个数字可以多次使用<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i, target-nums[i]); <span class=\"comment\">// 依旧传入i</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-40-组合总数Ⅱ\"><a href=\"#2-40-组合总数Ⅱ\" class=\"headerlink\" title=\"2. 40 组合总数Ⅱ\"></a>2. 40 <a href=\"https://leetcode-cn.com/problems/combination-sum-ii/\">组合总数Ⅱ</a></h2><p>nums中的每个数字在每个组合中只能使用一次 &amp;&amp; 解集不能包含重复的组合。</p>\n<p>说这是一个组合问题，其实换个问法就变成子集问题了：请你计算 candidates 中所有和为 target 的子集。</p>\n<h3 id=\"2-1-回溯1-1\"><a href=\"#2-1-回溯1-1\" class=\"headerlink\" title=\"2.1 回溯1\"></a>2.1 回溯1</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target, <span class=\"type\">bool</span> preUsed)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos &gt;= nums.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span>; <span class=\"comment\">// 不能放前面</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[pos] &gt; target) <span class=\"keyword\">return</span>; <span class=\"comment\">// 剪枝：当前和后面的不可能会选</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 不选</span></span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, pos+<span class=\"number\">1</span>, target, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos&gt;<span class=\"number\">0</span> &amp;&amp; nums[pos<span class=\"number\">-1</span>] == nums[pos] &amp;&amp; !preUsed) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 选</span></span><br><span class=\"line\">        cur.<span class=\"built_in\">push_back</span>(nums[pos]);</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, pos+<span class=\"number\">1</span>, target - nums[pos], <span class=\"literal\">true</span>);</span><br><span class=\"line\">        cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-回溯2-★-1\"><a href=\"#2-2-回溯2-★-1\" class=\"headerlink\" title=\"2.2 回溯2(★)\"></a>2.2 回溯2(★)</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=pos; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;pos &amp;&amp; nums[i<span class=\"number\">-1</span>] == nums[i]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 值相同的树枝，只遍历第一条，防止重复</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target &lt; nums[i]) <span class=\"keyword\">return</span>; <span class=\"comment\">// 剪枝：当前和后面的不可能会选</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, i+<span class=\"number\">1</span>, target-nums[i]);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">combinationSum2</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, <span class=\"number\">0</span>, target);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"三-排列问题\"><a href=\"#三-排列问题\" class=\"headerlink\" title=\"三. 排列问题\"></a>三. 排列问题</h1><h2 id=\"1-46-全排列\"><a href=\"#1-46-全排列\" class=\"headerlink\" title=\"1. 46 全排列\"></a>1. 46 <a href=\"https://leetcode-cn.com/problems/permutations/\">全排列</a></h2><p>不含重复数字的数组：nums，经典回溯<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permute</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-47-全排列Ⅱ\"><a href=\"#2-47-全排列Ⅱ\" class=\"headerlink\" title=\"2. 47 全排列Ⅱ\"></a>2. 47 <a href=\"https://leetcode-cn.com/problems/permutations-ii/\">全排列Ⅱ</a></h2><p>含有重复数字的数组：nums</p>\n<h3 id=\"2-1-哈希（有意思）\"><a href=\"#2-1-哈希（有意思）\" class=\"headerlink\" title=\"2.1 哈希（有意思）\"></a>2.1 哈希（有意思）</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traceback</span><span class=\"params\">(map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; hash, vector&lt;<span class=\"type\">int</span>&gt;&amp; cur, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == n)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;::iterator itr=hash.<span class=\"built_in\">begin</span>(); itr!=hash.<span class=\"built_in\">end</span>(); ++itr)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(itr-&gt;second)&#123;</span><br><span class=\"line\">                --itr-&gt;second;</span><br><span class=\"line\">                cur.<span class=\"built_in\">push_back</span>(itr-&gt;first);</span><br><span class=\"line\">                <span class=\"built_in\">traceback</span>(hash, cur, n);</span><br><span class=\"line\">                cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                ++itr-&gt;second;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permuteUnique</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; hash;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> e: nums) ++hash[e];</span><br><span class=\"line\">        <span class=\"built_in\">traceback</span>(hash, cur, nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-回溯-跟子集问题2-3很像\"><a href=\"#2-2-回溯-跟子集问题2-3很像\" class=\"headerlink\" title=\"2.2 回溯(跟子集问题2.3很像)\"></a>2.2 回溯(跟子集问题2.3很像)</h3><p>当出现重复元素时，比如输入 nums = [1,2,2’,2’’]，2’ 只有在 2 已经被使用的情况下才会被选择，2’’ 只有在 2’ 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定。<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; ret;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; cur;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur.<span class=\"built_in\">size</span>() == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            ret.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;nums.<span class=\"built_in\">size</span>(); ++i)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// i从0开始，固定相同的元素在排列中的相对位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;<span class=\"number\">0</span> &amp;&amp; nums[i]==nums[i<span class=\"number\">-1</span>] &amp;&amp; !used[i<span class=\"number\">-1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">permuteUnique</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()); <span class=\"comment\">// 必须排序</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size(), <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","tags":["算法","递归","回溯","哈希"]},{"title":"LC-82-83 链表去重","url":"/2022/03/20/LC-82-83-%E9%93%BE%E8%A1%A8%E5%8E%BB%E9%87%8D/","content":"<h1 id=\"83-删除排序链表中重复元素\"><a href=\"#83-删除排序链表中重复元素\" class=\"headerlink\" title=\"83 删除排序链表中重复元素\"></a>83 <a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\">删除排序链表中重复元素</a></h1><h2 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* ptr = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr &amp;&amp; head-&gt;val == ptr-&gt;val) ptr = ptr-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下面俩方式效果一样</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(ptr);</span><br><span class=\"line\">        <span class=\"comment\">// head-&gt;next = ptr;</span></span><br><span class=\"line\">        <span class=\"comment\">// deleteDuplicates(ptr);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"后续遍历\"><a href=\"#后续遍历\" class=\"headerlink\" title=\"后续遍历\"></a>后续遍历</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"comment\">// 有点像并查集里的路径压缩</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代法\"><a href=\"#迭代法\" class=\"headerlink\" title=\"迭代法\"></a>迭代法</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;next) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur-&gt;val == cur-&gt;next-&gt;val) </span><br><span class=\"line\">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">                cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代法：双指针\"><a href=\"#迭代法：双指针\" class=\"headerlink\" title=\"迭代法：双指针\"></a>迭代法：双指针</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast-&gt;val != slow-&gt;val)&#123;</span><br><span class=\"line\">                slow-&gt;next = fast;</span><br><span class=\"line\">                slow = slow-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类似于数组去重，一模一样</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> slow = <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast &lt; nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class=\"line\">                nums[++slow] = nums[fast];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ++fast;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"82-删除排序链表中的重复元素Ⅱ\"><a href=\"#82-删除排序链表中的重复元素Ⅱ\" class=\"headerlink\" title=\"82 删除排序链表中的重复元素Ⅱ\"></a>82 <a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/\">删除排序链表中的重复元素Ⅱ</a></h1><h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> prev = INT_MAX;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head || !head-&gt;next)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head) prev = head-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head &amp;&amp; head-&gt;val == prev) <span class=\"comment\">// 如果要delete，在这里</span></span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head &amp;&amp; head-&gt;val &lt; prev) <span class=\"comment\">// 小于号很重要，因为是递增链表，防止prev更新旧值</span></span><br><span class=\"line\">            prev = head-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"递归2-类似83后续遍历\"><a href=\"#递归2-类似83后续遍历\" class=\"headerlink\" title=\"递归2(类似83后续遍历)\"></a>递归2(类似83后续遍历)</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> prev = INT_MIN;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!head) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"comment\">// 有点像并查集里的路径压缩</span></span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">deleteDuplicates</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next &amp;&amp; head-&gt;val == head-&gt;next-&gt;val)&#123;</span><br><span class=\"line\">            prev = head-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;val == prev)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(INT_MAX, head);</span><br><span class=\"line\">        ListNode* ptr = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ptr)&#123;</span><br><span class=\"line\">            ListNode* cur = ptr-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur &amp;&amp; cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)&#123;</span><br><span class=\"line\">                cur = cur-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur == ptr-&gt;next) <span class=\"comment\">// 下一步没重复，放心走</span></span><br><span class=\"line\">                ptr = ptr-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"comment\">// 有重复 cur必不为nullptr，否则就是没重复那步</span></span><br><span class=\"line\">                ptr-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","tags":["算法","递归","链表","双指针"]},{"title":"Set、Map、Unordered","url":"/2022/03/27/Set%E3%80%81Map%E3%80%81Unordered/","content":"<h1 id=\"Map和Set\"><a href=\"#Map和Set\" class=\"headerlink\" title=\"Map和Set\"></a>Map和Set</h1><ul>\n<li>Map是<code>&lt;key, value&gt;</code>结构；Set是<code>&lt;key&gt;</code>结构，天然具有去重功能。</li>\n<li>自定义类放入Map或Set需要实现<code>bool operator&lt;(const MyClass&amp; ano) const</code>，注意里面的两个const是必备的，不能漏。</li>\n<li>不用实现<code>operator=</code>，因为<code>a&lt;b == false &amp;&amp; a&gt;b == false</code>会自动推断出等于。所以当你放入自己的类的时候，</li>\n</ul>\n<h2 id=\"0、示范图\"><a href=\"#0、示范图\" class=\"headerlink\" title=\"0、示范图\"></a>0、示范图</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">         <span class=\"number\">0</span></span><br><span class=\"line\">         |</span><br><span class=\"line\">        (<span class=\"number\">1</span>)</span><br><span class=\"line\">         |</span><br><span class=\"line\"><span class=\"number\">2</span> —(<span class=\"number\">1</span>)—  <span class=\"number\">1</span>  —(<span class=\"number\">1</span>)— <span class=\"number\">3</span></span><br><span class=\"line\">   \\           /</span><br><span class=\"line\">   (<span class=\"number\">3</span>)       (<span class=\"number\">2</span>)</span><br><span class=\"line\">      \\     /</span><br><span class=\"line\">         <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"1、错误代码示例\"><a href=\"#1、错误代码示例\" class=\"headerlink\" title=\"1、错误代码示例\"></a>1、错误代码示例</h2><ul>\n<li>下面<code>Node</code>类，利用Set来实现Dijkstra是不对的，因为在<code>operator&lt;</code>中参与返回结果的只有<code>val</code>因此，两个不一样的<code>Node</code>在<code>Set</code>中会被认为是相同的。即<code>Node a = Node(&#123;1,1&#125;)和Node b = Node(&#123;2,1&#125;)</code>，由于<code>(a&lt;b==false &amp;&amp; b&gt;a==false)</code>所以被判定为相等，与我们的目的南辕北辙。<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _p, <span class=\"type\">int</span> _v):<span class=\"built_in\">pos</span>(_p), <span class=\"built_in\">val</span>(_v)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Node&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;val &lt; ano.val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; g = &#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0</span>,   <span class=\"number\">1</span>,   inf, inf, inf&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">1</span>,   <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">1</span>,   inf&#125;,</span><br><span class=\"line\">\t\t&#123;inf, <span class=\"number\">1</span>,   <span class=\"number\">0</span>,   inf, <span class=\"number\">3</span>  &#125;,</span><br><span class=\"line\">\t\t&#123;inf, <span class=\"number\">1</span>,   inf, <span class=\"number\">0</span>,   <span class=\"number\">2</span>  &#125;,</span><br><span class=\"line\">\t\t&#123;inf, inf, <span class=\"number\">3</span>,   <span class=\"number\">2</span>,   <span class=\"number\">0</span>  &#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = (<span class=\"type\">int</span>)g.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// ------------------------------------</span></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">\tdist[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tset&lt;Node&gt; pq;</span><br><span class=\"line\">\tpq.<span class=\"built_in\">insert</span>(<span class=\"built_in\">Node</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tNode cur = *pq.<span class=\"built_in\">begin</span>(); pq.<span class=\"built_in\">erase</span>(pq.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> from = cur.pos;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> dis = cur.val;</span><br><span class=\"line\">\t\tcout &lt;&lt; from &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; cur.val &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> to = <span class=\"number\">0</span>; to &lt; n; ++to) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[to] = dis + g[from][to];</span><br><span class=\"line\">\t\t\t\tpq.<span class=\"built_in\">insert</span>(<span class=\"built_in\">Node</span>(to, dist[to]));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : dist)</span><br><span class=\"line\">\t\tcout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n输出结果为：<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">5</span> <span class=\"comment\">// 错误，应该是4</span></span><br><span class=\"line\"><span class=\"comment\">// 原因是插入Node&#123;3,2&#125;时发现已经有了，所以就取消插入，因此无法利用&#123;3,2&#125;来更新最小边</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2、正确用法priority-queue\"><a href=\"#2、正确用法priority-queue\" class=\"headerlink\" title=\"2、正确用法priority_queue\"></a>2、正确用法priority_queue</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _p, <span class=\"type\">int</span> _v):<span class=\"built_in\">pos</span>(_p), <span class=\"built_in\">val</span>(_v)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pos;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Node&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;val &gt; ano.val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; g = &#123;</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">0</span>,   <span class=\"number\">1</span>,   inf, inf, inf&#125;,</span><br><span class=\"line\">\t\t&#123;<span class=\"number\">1</span>,   <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">1</span>,   inf&#125;,</span><br><span class=\"line\">\t\t&#123;inf, <span class=\"number\">1</span>,   <span class=\"number\">0</span>,   inf, <span class=\"number\">3</span>  &#125;,</span><br><span class=\"line\">\t\t&#123;inf, <span class=\"number\">1</span>,   inf, <span class=\"number\">0</span>,   <span class=\"number\">2</span>  &#125;,</span><br><span class=\"line\">\t\t&#123;inf, inf, <span class=\"number\">3</span>,   <span class=\"number\">2</span>,   <span class=\"number\">0</span>  &#125;,</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = (<span class=\"type\">int</span>)g.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// ------------------------------------</span></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n, INT_MAX)</span></span>;</span><br><span class=\"line\">\tdist[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tpriority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; pq;</span><br><span class=\"line\">\tpq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!pq.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tNode cur = pq.<span class=\"built_in\">top</span>(); pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> from = cur.pos;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> dis = cur.val;</span><br><span class=\"line\">\t\tcout &lt;&lt; from &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; cur.val &lt;&lt; endl;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> to = <span class=\"number\">0</span>; to &lt; n; ++to) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (g[from][to] &lt; inf &amp;&amp; dist[to] &gt; dis + g[from][to]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[to] = dis + g[from][to];</span><br><span class=\"line\">\t\t\t\tpq.<span class=\"built_in\">push</span>(<span class=\"built_in\">Node</span>(to, dist[to]));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> e : dist)</span><br><span class=\"line\">\t\tcout &lt;&lt; e &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">\tcout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">2</span> <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">4</span> <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"总之，以后写Dijkstra不要妄图用set和map来替换优先队列\"><a href=\"#总之，以后写Dijkstra不要妄图用set和map来替换优先队列\" class=\"headerlink\" title=\"总之，以后写Dijkstra不要妄图用set和map来替换优先队列!!!\"></a>总之，以后写Dijkstra不要妄图用set和map来替换优先队列!!!</h2><h1 id=\"Unordered-set和unordered-map\"><a href=\"#Unordered-set和unordered-map\" class=\"headerlink\" title=\"Unordered_set和unordered_map\"></a>Unordered_set和unordered_map</h1><ol>\n<li>需要定义一个仿函数<code>operator(...)</code>用来计算hash_value，并在定义时传入模板参数</li>\n<li>重载<code>operator==</code><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">node</span>(<span class=\"type\">int</span> _id, <span class=\"type\">double</span> _val) : <span class=\"built_in\">id</span>(_id), <span class=\"built_in\">val</span>(_val) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> id;</span><br><span class=\"line\">\t<span class=\"type\">double</span> val;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> node&amp; ano) <span class=\"type\">const</span> &#123; <span class=\"comment\">// 判断两个对象是否相等（自动加上key匹配再判断相等）</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> val == ano.val;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node_hash</span> &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> node&amp; v)</span> <span class=\"type\">const</span> </span>&#123; <span class=\"comment\">// 生成hash value，必须返回 [无符号整数] 用来进行映射</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.id; <span class=\"comment\">// 生成hash value的方式都可以灵活自定义</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//return hash&lt;double&gt;()(v.val);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tunordered_map&lt;node, string, node_hash&gt; ms;</span><br><span class=\"line\">\tnode a = &#123; <span class=\"number\">1</span>, <span class=\"number\">1.1111</span> &#125;;</span><br><span class=\"line\">\tnode b = &#123; <span class=\"number\">2</span>, <span class=\"number\">1.1111</span> &#125;;</span><br><span class=\"line\">\tms[a] = <span class=\"string\">&quot;aaaa&quot;</span>;</span><br><span class=\"line\">\tms[b] = <span class=\"string\">&quot;bbbb&quot;</span>;</span><br><span class=\"line\">\tcout &lt;&lt; ms[a] &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; ms[b] &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Essential C++ note","url":"/2021/08/05/essential-C-note/","content":"<blockquote>\n<p><strong>记录本书（对我来说）的一些重点内容</strong></p>\n</blockquote>\n<h3 id=\"1-C-编程基础\"><a href=\"#1-C-编程基础\" class=\"headerlink\" title=\"1 C++编程基础\"></a>1 C++编程基础</h3><ol>\n<li>初始化方法：构造函数法（constructor syntax）</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">var</span><span class=\"params\">(<span class=\"number\">66</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">int</span> var2&#123;<span class=\"number\">66</span>&#125;; <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>srand()随机数种子；rand()则产生一个介于0和int所能表示的最大整数；需包含头文件cstdlib</li>\n<li>cerr（standard error）代表标准错误设备，与cout唯一区别就是不带缓冲，立即显示于用户终端</li>\n</ol>\n<h3 id=\"2-面向过程的编程风格\"><a href=\"#2-面向过程的编程风格\" class=\"headerlink\" title=\"2 面向过程的编程风格\"></a>2 面向过程的编程风格</h3><ol>\n<li>使用模板，则声明与定义要放在一起</li>\n<li>函数指针</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给函数指针赋初值</span></span><br><span class=\"line\"><span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;* (*seq_str)(<span class=\"type\">int</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// seq_array是个数组，内放函数指针</span></span><br><span class=\"line\"><span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;* (*seq_array[])(<span class=\"type\">int</span>) = &#123;</span><br><span class=\"line\">    fibon_seq, lucas_seq, pell_seq,</span><br><span class=\"line\">    triang_seq, square_seq, pent_seq</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>inline函数的声明和定义都需要放在头文件，声明和定义有一个标明inline即可（在类定义中实现则默认是inline）；其他的函数，则必须是<strong>“定义放在程序代码文件”、“声明放在头文件”</strong></li>\n<li>多文件共享变量</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    变量只能定义一次，但是可以声明多次</span></span><br><span class=\"line\"><span class=\"comment\">    假定main.cpp func.cpp func.h三个文件</span></span><br><span class=\"line\"><span class=\"comment\">    1. 在func.cpp有一个int a=1;如果要在main.cpp中使用，要在func.h或main.cpp中写extern int a；</span></span><br><span class=\"line\"><span class=\"comment\">    2. const object和inline函数一样，是“一次定义”规则下的例外。const object定义只要一出文件外就</span></span><br><span class=\"line\"><span class=\"comment\">       不可见（意味着可以在多个程序代码中加以定义）。因此如果const int a=1想多文件共享，可以直接写</span></span><br><span class=\"line\"><span class=\"comment\">       在func.h中，其他的非const object则不可。</span></span><br><span class=\"line\"><span class=\"comment\">       可参考：https://www.icode9.com/content-1-915590.html</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-泛型编程风格\"><a href=\"#3-泛型编程风格\" class=\"headerlink\" title=\"3 泛型编程风格\"></a>3 泛型编程风格</h3><ol>\n<li>list不支持iterator的偏移运算（+、-）但是有++和—</li>\n<li>对于标准容器，不确保目标空间大小，可使用iterator inserter用插入操作替代赋值操作</li>\n<li>&lt;这章挺多东西，需要结合书本去看&gt;</li>\n</ol>\n<h3 id=\"4-基于对象的编程风格\"><a href=\"#4-基于对象的编程风格\" class=\"headerlink\" title=\"4 基于对象的编程风格\"></a>4 基于对象的编程风格</h3><ol>\n<li>如果有必要为某个class编写[拷贝构造]，则同样有必要为它编写[赋值操作]</li>\n<li>没有一个const reference class参数可以调用公开接口中的non-const成分</li>\n<li>类中的变量声明为mutable，标明其不会破坏对象的<strong>常量性</strong>（constness），即可在const函数中可以修改它</li>\n<li>当定义class的static function时，不可加上关键字static（同理静态成员变量）</li>\n<li>当类中有静态成员变量时，需要及时在类外进行初始化，否则报错：无法解析的外部命令</li>\n<li>通常情况：<strong>operator*无参表示解引用；有参表示乘法</strong></li>\n<li>friend声明可以出现在类定义任意位置，不受public或private影响</li>\n<li><strong>嵌套类型</strong>（Nested Type），类中可以定义嵌套类型，再用域解析符（例如每个STL容器类都有自己的iterator）</li>\n<li>重载iostream（看书）</li>\n<li>类的函数指针：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> (num_sequence::*pm)(<span class=\"type\">int</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果决定上面一行复杂可以写成：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span> <span class=\"params\">(num_sequence::*PtrType)</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\">PtrType pm = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 成员函数取址要加上class scope限定符和&amp;取地址运算符（不同于一般函数，都不可以省！）</span></span><br><span class=\"line\">PtrType pm = &amp;num_sequence::fibonaci;</span><br><span class=\"line\"><span class=\"comment\">// 调用，由此要引出pointer to member selection运算符“.*”和&quot;-&gt;*&quot;</span></span><br><span class=\"line\">(ns.*pm)(pos)</span><br><span class=\"line\">(pns-&gt;*pm)(pos)</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-面向对象编程风格\"><a href=\"#5-面向对象编程风格\" class=\"headerlink\" title=\"5 面向对象编程风格\"></a>5 面向对象编程风格</h3><ol>\n<li>纯虚函数：将虚函数赋值为0</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>任何类声明了纯虚函数，那么由于其接口不完整（无定义），程序无法为其产生实体。这种类只能作为派生类的子对象使用，而且前提是这些派生类为<strong>所有</strong>虚函数提供确切的定义。</li>\n<li>一般规则：凡基类定义了虚函数，则destructor也要声明为virtual</li>\n<li>一般而言，对象的拷贝构造函数开发者如果未提供，则编译器会自动生成默认的拷贝构造函数。然而以下情况默认的拷贝构造函数会被删除：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1、存在非静态的const成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    2、存在非静态的引用成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    3、存在不能拷贝的成员变量</span></span><br><span class=\"line\"><span class=\"comment\">    4、存在不能拷贝的基类</span></span><br><span class=\"line\"><span class=\"comment\">    5、存在用户定义的移动构造函数或移动赋值函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>在基类的constructor中，派生类的虚函数不允许被调用</li>\n<li>static_cast和dynamic_cast，前者无条件转换，后者判断（比如基类的指针是否真的指向了该派生类）是否可以转换为目的类型再进行转换</li>\n</ol>\n<h3 id=\"6-以template进行编程\"><a href=\"#6-以template进行编程\" class=\"headerlink\" title=\"6 以template进行编程\"></a>6 以template进行编程</h3><ol>\n<li>函数传入一个指针，只能改变指针所指对象的内容，要想改变指针本身（指向）就要传递reference to pointer</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">BTnode*&amp; prev <span class=\"comment\">// 可以看成BTnode* &amp;prev 或 ((BTnode*)&amp;) prev</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>模板类声明友元的问题：</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面代码直接运行会报错：无法解析的外部命令</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(T t):<span class=\"built_in\">dy</span>(t) &#123;&#125;</span><br><span class=\"line\">    T dy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&lt;T&gt;&amp; b);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(ostream&amp; os)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        os &lt;&lt; dy &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&lt;T&gt;&amp; b) &#123;</span><br><span class=\"line\">    b.<span class=\"built_in\">func</span>(os);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">A&lt;<span class=\"type\">double</span>&gt; <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">4.2</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    原因：</span></span><br><span class=\"line\"><span class=\"comment\">    因为&quot;operator&lt;&lt;&quot;这个函数的参数T不应该依赖于class的模板参数，友元本来是可以访问类的所有数据成员的(该模板类的int、double、string对象)，你这样依赖的话，放到外部表名该参数T是属于类内部本身，解决方案是为了更好的支持友元，我们一般单独给友元一个模板参数</span></span><br><span class=\"line\"><span class=\"comment\">    1、类中友元声明改为（意义不明不过能用，但是其下绿波浪线提示函数未定义）（不推荐）</span></span><br><span class=\"line\"><span class=\"comment\">    friend ostream&amp; operator&lt;&lt; &lt;T&gt;(ostream&amp; os, const A&lt;T&gt;&amp; b);</span></span><br><span class=\"line\"><span class=\"comment\">    2、类中友元声明改为（S不同于T）（推荐）</span></span><br><span class=\"line\"><span class=\"comment\">    template &lt;typename S&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&lt;S&gt;&amp; b);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>非类型参数</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1、这类参数在模板内部都是常量值</span></span><br><span class=\"line\"><span class=\"comment\">    2、只允许传入整形、指针和引用这三类</span></span><br><span class=\"line\"><span class=\"comment\">    3、调用非类型参数的实参必须为常量表达式（必须在编译时能计算出结果的）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-异常处理\"><a href=\"#7-异常处理\" class=\"headerlink\" title=\"7 异常处理\"></a>7 异常处理</h3><ol>\n<li>重新抛出时，只需写下关键字throw即可。它只能出现于catch子句中</li>\n<li>局部资源管理，在易发生异常后释放资源是一件风险很大的事情。虽然可以通过try catch处理，但是释放资源的代码要出现两次，不好。这就引出了resource acquisition is initialization(RAII)策略，即初始化阶段进行资源请求。说人话就是，在构造函数中请求所有资源，在析构函数中释放所有资源：C++保证，在异常处理机制终结某个函数之前，所有局部对象的destructor都会被调用。或者使用智能指针例如：unique_ptr、shared_ptr等。</li>\n<li>ptext = new vector<string>; 经过以下几个步骤（异常出现，余下不会执行，会沿着调用链抛出）</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    // 可能会reorder哦~</span></span><br><span class=\"line\"><span class=\"comment\">    1、分配足够的空间</span></span><br><span class=\"line\"><span class=\"comment\">    2、将vector&lt;string&gt; default constructor应用于heap对象之上</span></span><br><span class=\"line\"><span class=\"comment\">    3、将对象地址设置给ptext</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n","tags":["C/C++"]},{"title":"十大排序总结","url":"/2022/04/03/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","content":"<h1 id=\"一、简单排序\"><a href=\"#一、简单排序\" class=\"headerlink\" title=\"一、简单排序\"></a>一、简单排序</h1><h2 id=\"1-冒泡排序\"><a href=\"#1-冒泡排序\" class=\"headerlink\" title=\"1. 冒泡排序\"></a>1. 冒泡排序</h2><ul>\n<li>时间复杂度：O(N^2)</li>\n<li>空间复杂度：O(1)</li>\n<li>稳定<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n - <span class=\"number\">1</span> - i; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) <span class=\"built_in\">swap</span>(arr[j], arr[j + <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-选择排序\"><a href=\"#2-选择排序\" class=\"headerlink\" title=\"2. 选择排序\"></a>2. 选择排序</h2></li>\n<li>时间复杂度：O(N^2)</li>\n<li>空间复杂度：O(1)</li>\n<li><strong>不稳定</strong>（是不是以为<code>(arr[j] &gt; arr[pos])</code>改为<code>&gt;=</code>就变成稳定的了？那看一下<code>3, 2, 1, 2</code>。所以若想选择排序稳定，需要开辟新的数组空间；或者进行大量移动位置操作；或者是对链表排序）<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">selectSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n - i; ++j) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (arr[j] &gt; arr[pos]) pos = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[pos], arr[n - i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"3-插入排序\"><a href=\"#3-插入排序\" class=\"headerlink\" title=\"3. 插入排序\"></a>3. 插入排序</h2><ul>\n<li>时间复杂度：O(N^2)</li>\n<li>空间复杂度：O(1)</li>\n<li>稳定<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; --j)</span><br><span class=\"line\">\t\t\tarr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">\t\tarr[j + <span class=\"number\">1</span>] = cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二、高级排序\"><a href=\"#二、高级排序\" class=\"headerlink\" title=\"二、高级排序\"></a>二、高级排序</h1><h2 id=\"4-希尔排序\"><a href=\"#4-希尔排序\" class=\"headerlink\" title=\"4. 希尔排序\"></a>4. 希尔排序</h2></li>\n<li>时间复杂度：O(N^(4/3~3/2))复杂度非常难以估算</li>\n<li>空间复杂度：O(1)</li>\n<li><strong>不稳定</strong></li>\n<li>下面两个实现都一样，唯一区别就是<code>插入排序外循环里面i增加的形式，第一种分开实现，第二种合并了</code><h3 id=\"4-1-实现1\"><a href=\"#4-1-实现1\" class=\"headerlink\" title=\"4.1 实现1\"></a>4.1 实现1</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; incre = &#123; <span class=\"number\">1023</span>, <span class=\"number\">511</span>, <span class=\"number\">255</span>, <span class=\"number\">127</span>, <span class=\"number\">63</span>, <span class=\"number\">31</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">0</span>; u &lt;incre.<span class=\"built_in\">size</span>(); ++u) &#123; <span class=\"comment\">// 增量循环</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> width = incre[u];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (width &gt; n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> v = <span class=\"number\">0</span>; v &lt; width; ++v) &#123; <span class=\"comment\">// 当前增量循环</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = width + v; i &lt; n; i += width) &#123; <span class=\"comment\">// 插入排序外循环</span></span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"type\">int</span> j = i - width;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; j -= width) <span class=\"comment\">// 插入排序内循环</span></span><br><span class=\"line\">\t\t\t\t\tarr[j + width] = arr[j];</span><br><span class=\"line\">\t\t\t\tarr[j + width] = cur;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-实现2（浙大陈姥姥代码）\"><a href=\"#4-2-实现2（浙大陈姥姥代码）\" class=\"headerlink\" title=\"4.2 实现2（浙大陈姥姥代码）\"></a>4.2 实现2（浙大陈姥姥代码）</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"comment\">// 选择的增量序列是（2^k-1），可以跟随数组大小生成，但是为了简化算法代码，突出主题，在此固定长度了</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; incre = &#123; <span class=\"number\">1023</span>, <span class=\"number\">511</span>, <span class=\"number\">255</span>, <span class=\"number\">127</span>, <span class=\"number\">63</span>, <span class=\"number\">31</span>, <span class=\"number\">15</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> u = <span class=\"number\">0</span>; u &lt; incre.<span class=\"built_in\">size</span>(); ++u) &#123; <span class=\"comment\">// 增量循环</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> width = incre[u];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = width; i &lt; n; ++i) &#123; <span class=\"comment\">// 插入排序外循环</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = i - width;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; j -= width) <span class=\"comment\">// 插入排序内循环</span></span><br><span class=\"line\">\t\t\t\tarr[j + width] = arr[j];</span><br><span class=\"line\">\t\t\tarr[j + width] = cur;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"5-堆排序\"><a href=\"#5-堆排序\" class=\"headerlink\" title=\"5. 堆排序\"></a>5. 堆排序</h2><ul>\n<li>时间复杂度：O(NlogN)</li>\n<li>空间复杂度：O(1)</li>\n<li>不稳定<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">downMethod</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> f, <span class=\"type\">int</span> sz)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> s = f * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cur = arr[f];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(s &lt; sz)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (s + <span class=\"number\">1</span> &lt; sz &amp;&amp; arr[s] &lt; arr[s + <span class=\"number\">1</span>]) <span class=\"comment\">// 兄弟值大，让位</span></span><br><span class=\"line\">\t\t\t++s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[s] &lt;= cur) <span class=\"keyword\">break</span>; <span class=\"comment\">// 父亲值大，镇压</span></span><br><span class=\"line\">\t\tarr[f] = arr[s]; <span class=\"comment\">// 儿子值大，禅位</span></span><br><span class=\"line\">\t\tf = s; <span class=\"comment\">// 下一代的父亲</span></span><br><span class=\"line\">\t\ts = f * <span class=\"number\">2</span> + <span class=\"number\">1</span>; <span class=\"comment\">// 下一代的儿子</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tarr[f] = cur;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 数组形成堆</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = (n - <span class=\"number\">2</span>) / <span class=\"number\">2</span>; p &gt;= <span class=\"number\">0</span>; --p)</span><br><span class=\"line\">\t\t<span class=\"built_in\">downMethod</span>(arr, p, n);</span><br><span class=\"line\">    <span class=\"comment\">// 堆首尾交换进行排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> p = n<span class=\"number\">-1</span>; p &gt; <span class=\"number\">0</span>; --p) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[<span class=\"number\">0</span>], arr[p]);</span><br><span class=\"line\">\t\t<span class=\"built_in\">downMethod</span>(arr, <span class=\"number\">0</span>, p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"6-归并排序\"><a href=\"#6-归并排序\" class=\"headerlink\" title=\"6. 归并排序\"></a>6. 归并排序</h2><ul>\n<li>时间复杂度：O(NlogN)</li>\n<li>空间复杂度：O(N)</li>\n<li>稳定<h3 id=\"6-1-递归版本\"><a href=\"#6-1-递归版本\" class=\"headerlink\" title=\"6.1 递归版本\"></a>6.1 递归版本</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [l, m] [m+1, r]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeTwoArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> m, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>, k = l;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= m || j &lt;= r) &#123; <span class=\"comment\">// k &lt;= r 一样</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = i &lt;= m ? arr[i] : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> b = j &lt;= r ? arr[j] : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a &lt; b) ++i; <span class=\"comment\">// 每次i和j只能有一个增加</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ++j;</span><br><span class=\"line\">\t\ttrr[k++] = a &lt; b ? a : b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt;= r) &#123; <span class=\"comment\">// 拷贝回去</span></span><br><span class=\"line\">\t\tarr[l] = trr[l];</span><br><span class=\"line\">\t\t++l;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m = l + ((r - l) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeRecursion</span>(arr, trr, l, m);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeRecursion</span>(arr, trr, m + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t<span class=\"built_in\">mergeTwoArray</span>(arr, trr, l, m, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 避免频繁创建子数组</span></span><br><span class=\"line\">\t<span class=\"built_in\">mergeRecursion</span>(arr, trr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-非递归版本\"><a href=\"#6-2-非递归版本\" class=\"headerlink\" title=\"6.2 非递归版本\"></a>6.2 非递归版本</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [l, m] [m+1, r]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeTwoArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> m, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = l, j = m + <span class=\"number\">1</span>, k = l;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= m || j &lt;= r) &#123; <span class=\"comment\">// k &lt;= r 一样</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = i &lt;= m ? arr[i] : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> b = j &lt;= r ? arr[j] : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a &lt; b) ++i; <span class=\"comment\">// 每次i和j只能有一个增加</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> ++j;</span><br><span class=\"line\">\t\ttrr[k++] = a &lt; b ? a : b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不用拷贝回去...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> range = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 避免频繁创建子数组</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (range &lt; n) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i += range*<span class=\"number\">2</span>) &#123; <span class=\"comment\">// arr -&gt; trr</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> m = i + range - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (m &gt;= n - <span class=\"number\">1</span>) m = n - <span class=\"number\">1</span>; <span class=\"comment\">// 不能break</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> r = i + range * <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (r &gt;= n - <span class=\"number\">1</span>) r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mergeTwoArray</span>(arr, trr, i, m, r);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trange &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i += range*<span class=\"number\">2</span>) &#123; <span class=\"comment\">// trr -&gt; arr</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> m = i + range - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (m &gt;= n - <span class=\"number\">1</span>) m = n - <span class=\"number\">1</span>; <span class=\"comment\">// 不能break</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> r = i + range * <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (r &gt;= n - <span class=\"number\">1</span>) r = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">mergeTwoArray</span>(trr, arr, i, m, r);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\trange &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"7-快速排序\"><a href=\"#7-快速排序\" class=\"headerlink\" title=\"7. 快速排序\"></a>7. 快速排序</h2><ul>\n<li>时间复杂度：O(NlogN)</li>\n<li>空间复杂度：栈上O(logN)</li>\n<li>不稳定</li>\n<li>注意1：遇到l和r指向相等时，需要交换，不然遇到全1的数组，退化为n^2</li>\n<li>注意2：快排在数据范围较小时（<code>r-l&lt;threshold</code>）直接使用插入排序可有效优化速度<h3 id=\"7-1-实现1（朴素版）\"><a href=\"#7-1-实现1（朴素版）\" class=\"headerlink\" title=\"7.1 实现1（朴素版）\"></a>7.1 实现1（朴素版）</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> oldl = l, oldr = r;</span><br><span class=\"line\">\t<span class=\"comment\">// 选 [枢纽]</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\">\t<span class=\"comment\">// 排序</span></span><br><span class=\"line\">\t++r;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[--r] &gt; pivot); <span class=\"comment\">// 右侧先动是安全的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[++l] &lt; pivot); <span class=\"comment\">// 左侧后动</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &lt; r) <span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[oldl], arr[l]);</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, oldl, r - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, r + <span class=\"number\">1</span>, oldr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-实现2（改进朴素版）\"><a href=\"#7-2-实现2（改进朴素版）\" class=\"headerlink\" title=\"7.2 实现2（改进朴素版）\"></a>7.2 实现2（改进朴素版）</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\"><span class=\"comment\">// 改为</span></span><br><span class=\"line\"><span class=\"type\">int</span> randomPos = l + <span class=\"built_in\">rand</span>()%(r-l+<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(arr[l], arr[randomPos]);</span><br><span class=\"line\"><span class=\"type\">int</span> pivot = arr[l];</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-实现3（中间值枢纽）\"><a href=\"#7-3-实现3（中间值枢纽）\" class=\"headerlink\" title=\"7.3 实现3（中间值枢纽）\"></a>7.3 实现3（中间值枢纽）</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三数选中间数并将最小值放在l，最大值放在r，中间值(pivot)放在l+1</span></span><br><span class=\"line\"><span class=\"comment\">// 陈姥姥代码里是放在r-1的，这样肯定正确因为m肯定&lt;r</span></span><br><span class=\"line\"><span class=\"comment\">// 我为了兼容朴素版的大部分代码，选择放在l+1，这样由于m可能等于l，所以需要多一次特殊点判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">median3</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> m = l + ((r - l) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr[l] &gt; arr[m])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[l], arr[m]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr[l] &gt; arr[r])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arr[m] &gt; arr[r])</span><br><span class=\"line\">\t\t<span class=\"built_in\">swap</span>(arr[m], arr[r]);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l == m) <span class=\"keyword\">return</span> arr[l]; <span class=\"comment\">// 特殊点</span></span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[m], arr[l + <span class=\"number\">1</span>]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr[l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> oldl = l, oldr = r;</span><br><span class=\"line\">\t<span class=\"comment\">// 选 [枢纽]</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = <span class=\"built_in\">median3</span>(arr, l, r);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 排序</span></span><br><span class=\"line\">\t++l; <span class=\"comment\">// 注意：两端收缩了一位</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (l &lt; r) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[--r] &gt; pivot); <span class=\"comment\">// 右侧先动是安全的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l &lt; r &amp;&amp; arr[++l] &lt; pivot); <span class=\"comment\">// 左侧后动</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (l &lt; r) <span class=\"built_in\">swap</span>(arr[l], arr[r]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[oldl + <span class=\"number\">1</span>], arr[l]); <span class=\"comment\">// 注意：pivot枢纽放在了l+1位置</span></span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, oldl, r - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, r + <span class=\"number\">1</span>, oldr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-4-实现4（有限制）\"><a href=\"#7-4-实现4（有限制）\" class=\"headerlink\" title=\"7.4 实现4（有限制）\"></a>7.4 实现4（有限制）</h3>虽然代码看起来很简洁，但是有如下问题：</li>\n</ul>\n<ol>\n<li>极端情况会退化为n^2算法</li>\n<li>正因如此，在我的实验中，对3w个分布0~99的数字排序，会栈溢出（异常结束，main函数return 非0）。其实前面的方法里，移动i和j时如果<code>&gt;</code>改为<code>&gt;=</code>、<code>&lt;</code>改为<code>&lt;=</code>也会出现这种问题哦。因此在数据分布较窄时，这种方法无疑是低效的<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt;= r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 选 [枢纽] 可改进随机化但效果还是差</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = arr[l];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 排序</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> j = l;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l + <span class=\"number\">1</span>; i &lt;= r; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class=\"line\">\t\t\t++j;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">swap</span>(arr[i], arr[j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">swap</span>(arr[j], arr[l]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, l, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, j + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">quickRecursion</span>(arr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"三、特殊排序\"><a href=\"#三、特殊排序\" class=\"headerlink\" title=\"三、特殊排序\"></a>三、特殊排序</h1><h2 id=\"8-计数排序\"><a href=\"#8-计数排序\" class=\"headerlink\" title=\"8. 计数排序\"></a>8. 计数排序</h2><ul>\n<li>时间复杂度：O(B+N)，B是数据范围一般较小，可认为是O(N)</li>\n<li>空间复杂度：栈上O(B+N) -&gt; O(N)</li>\n<li>稳定（实现的不好则不稳定，比如从前往后填）<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">countingSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(maxV + <span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 计数数组</span></span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) ++counting[e]; <span class=\"comment\">// 计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">\t\tcounting[i] = counting[i - <span class=\"number\">1</span>] + counting[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123; <span class=\"comment\">// 从后向前填：稳定的排序</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = --counting[arr[i]];</span><br><span class=\"line\">\t\ttrr[pos] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">\t\tarr[i] = trr[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-基数排序\"><a href=\"#9-基数排序\" class=\"headerlink\" title=\"9. 基数排序\"></a>9. 基数排序</h2></li>\n<li>时间复杂度：O(Rs * N)，Rs是数据最大值的位数一般较小，可认为是O(N)</li>\n<li>空间复杂度：栈上O(10 + N) -&gt; O(N)</li>\n<li>稳定（实现的不好则不稳定，比如从前往后填）</li>\n<li>经常利用计数排序实现<h3 id=\"9-1-LSD基数排序\"><a href=\"#9-1-LSD基数排序\" class=\"headerlink\" title=\"9.1 LSD基数排序\"></a>9.1 LSD基数排序</h3></li>\n</ul>\n<ol>\n<li>最低位优先(Least Significant Digit first, LSD)，先排低位；再排高位</li>\n<li>由于每一位介于0~9，所以对每一个基位排序时都可看做是分为10个桶的桶排序<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得一个int的某一位的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getRadix</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> radices[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span>, <span class=\"number\">100000000</span>, <span class=\"number\">1000000000</span> &#125;;</span><br><span class=\"line\">\tnum %= radices[r + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num / radices[r];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixSortLSD</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> radixNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (maxV) &#123;</span><br><span class=\"line\">\t\t++radixNum;</span><br><span class=\"line\">\t\tmaxV /= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> r = <span class=\"number\">0</span>; r &lt; radixNum; ++r) &#123;</span><br><span class=\"line\">\t\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>; <span class=\"comment\">// 计数数组</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) ++counting[<span class=\"built_in\">getRadix</span>(e, r)]; <span class=\"comment\">// 计数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">\t\t\tcounting[i] = counting[i - <span class=\"number\">1</span>] + counting[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> pos = --counting[<span class=\"built_in\">getRadix</span>(arr[i], r)];</span><br><span class=\"line\">\t\t\ttrr[pos] = arr[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">\t\t\tarr[i] = trr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-2-MSD基数排序\"><a href=\"#9-2-MSD基数排序\" class=\"headerlink\" title=\"9.2 MSD基数排序\"></a>9.2 MSD基数排序</h3></li>\n</ol>\n<ul>\n<li>最高位优先(Most Significant Digit first, MSD)，先排高位；再排低位</li>\n<li>MSD一般采用递归写法：按高位分组，形成连续区段，然后在区段内递归处理低一位<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得一个int的某一位的数字</span></span><br><span class=\"line\"><span class=\"comment\">// 例如13247 r=0 -&gt; 7 | r=1 -&gt; 4 | r=2 -&gt; 2 | r=3 -&gt; 3 | r=4 -&gt; 1 | r = 5 -&gt; 0 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getRadix</span><span class=\"params\">(<span class=\"type\">int</span> num, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> radices[] = &#123; <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">100</span>, <span class=\"number\">1000</span>, <span class=\"number\">10000</span>, <span class=\"number\">100000</span>, <span class=\"number\">1000000</span>, <span class=\"number\">10000000</span>, <span class=\"number\">100000000</span>, <span class=\"number\">1000000000</span> &#125;;</span><br><span class=\"line\">\tnum %= radices[r + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num / radices[r];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixRecursion</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, vector&lt;<span class=\"type\">int</span>&gt;&amp; trr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r, <span class=\"type\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (l &gt;= r || d &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">counting</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i) </span><br><span class=\"line\">\t\t++counting[<span class=\"built_in\">getRadix</span>(arr[i], d)]; <span class=\"comment\">// l~r 计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; counting.<span class=\"built_in\">size</span>(); ++i) </span><br><span class=\"line\">\t\tcounting[i] = counting[i - <span class=\"number\">1</span>] + counting[i]; <span class=\"comment\">// 累加计数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = r; i &gt;= l; --i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = --counting[<span class=\"built_in\">getRadix</span>(arr[i], d)] + l; <span class=\"comment\">// + l 偏移别忘了</span></span><br><span class=\"line\">\t\ttrr[pos] = arr[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l; i &lt;= r; ++i) <span class=\"comment\">// 拷回去</span></span><br><span class=\"line\">\t\tarr[i] = trr[i];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"built_in\">radixRecursion</span>(arr, trr, l, l + counting[<span class=\"number\">0</span>] - <span class=\"number\">1</span>, d - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"built_in\">radixRecursion</span>(arr, trr, l + counting[i - <span class=\"number\">1</span>], l + counting[i] - <span class=\"number\">1</span>, d - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">radixSortMSD</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> radixNum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (maxV) &#123;</span><br><span class=\"line\">\t\t++radixNum;</span><br><span class=\"line\">\t\tmaxV /= <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">trr</span><span class=\"params\">(arr)</span></span>; <span class=\"comment\">// 留作中转拷贝</span></span><br><span class=\"line\">\t<span class=\"built_in\">radixRecursion</span>(arr, trr, <span class=\"number\">0</span>, n - <span class=\"number\">1</span>, radixNum<span class=\"number\">-1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-桶排序\"><a href=\"#10-桶排序\" class=\"headerlink\" title=\"10. 桶排序\"></a>10. 桶排序</h2></li>\n<li>桶排序的时间复杂度和空间复杂度以及是不是稳定都看你采取的子排序算法</li>\n<li>桶排序一般用于数据<strong>分布均匀</strong>的</li>\n<li>桶排序用于遏制N^2、NlogN等复杂度的算法因数据量太大而带来的速度问题<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cur = arr[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j] &gt; cur; --j)</span><br><span class=\"line\">\t\t\tarr[j + <span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">\t\tarr[j + <span class=\"number\">1</span>] = cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bucketSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> maxV = INT_MIN;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) maxV = maxV &gt; e ? maxV : e;</span><br><span class=\"line\">\t++maxV;</span><br><span class=\"line\">\t<span class=\"type\">int</span> bckNum = <span class=\"number\">10</span>; <span class=\"comment\">// 分十个桶</span></span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">buckets</span>(bckNum, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> pos = e * <span class=\"number\">10</span> / maxV;</span><br><span class=\"line\">\t\tbuckets[pos].<span class=\"built_in\">push_back</span>(e); <span class=\"comment\">// 放进桶里</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; b : buckets) &#123; <span class=\"comment\">// 随意选取排序算法</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">insertSort</span>(b);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; buckets.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; buckets[i].<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">\t\t\tarr[k++] = buckets[i][j]; <span class=\"comment\">// 从桶里面拿出来</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"四、辅助代码\"><a href=\"#四、辅助代码\" class=\"headerlink\" title=\"四、辅助代码\"></a>四、辅助代码</h1></li>\n<li>获取数据、判断排序合格、显示已排序frontN等<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> once</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Data</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Data</span>(string fn, <span class=\"type\">int</span> _n) : <span class=\"built_in\">arr</span>(_n) &#123;</span><br><span class=\"line\">\t\tfstream file;</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">open</span>(fn, ios::in);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!file) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"built_in\">string</span>(<span class=\"string\">&quot;ERROR!&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : arr)</span><br><span class=\"line\">\t\t\tfile &gt;&gt; e;</span><br><span class=\"line\">\t\tfile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt;&amp;&amp; <span class=\"title\">getData</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">move</span>(arr); &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSorted</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; arr.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (arr[i] &lt; arr[i - <span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showFrontN</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\tn = n &gt; arr.<span class=\"built_in\">size</span>() ? arr.<span class=\"built_in\">size</span>() : n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n;) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (; cnt &lt; <span class=\"number\">10</span> &amp;&amp; i + cnt &lt; n; ++cnt) <span class=\"comment\">// 每行十列显示</span></span><br><span class=\"line\">\t\t\tcout &lt;&lt; arr[i + cnt] &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">\t\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t\ti += cnt;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Data <span class=\"title\">dataGenerator</span><span class=\"params\">(<span class=\"string\">&quot;Data.txt&quot;</span>, <span class=\"number\">1000</span>)</span></span>;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; arr = dataGenerator.<span class=\"built_in\">getData</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t# <span class=\"built_in\">yourSort</span>(arr);</span><br><span class=\"line\">\t<span class=\"built_in\">showFrontN</span>(arr, <span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"built_in\">isSorted</span>(arr)) cout &lt;&lt; <span class=\"string\">&quot;排序完成&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> cout &lt;&lt; <span class=\"string\">&quot;排序出错&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","tags":["算法","递归","排序"]},{"title":"单例模式","url":"/2022/03/26/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","content":"<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><h2 id=\"1、普通版本（高并发效率不足）（安全）\"><a href=\"#1、普通版本（高并发效率不足）（安全）\" class=\"headerlink\" title=\"1、普通版本（高并发效率不足）（安全）\"></a>1、普通版本（高并发效率不足）（安全）</h2><ul>\n<li>在类中添加一个私有静态成员单例实例的指针。</li>\n<li>声明一个公有静态构建方法用于获取单例实例的指针。</li>\n<li>在静态方法中实现”延迟初始化”。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。</li>\n<li>将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。</li>\n<li>检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Singleton</span>(<span class=\"type\">const</span> string&amp; val) : <span class=\"built_in\">data</span>(val) &#123;&#125; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">\t~<span class=\"built_in\">Singleton</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"type\">static</span> Singleton* _instance; <span class=\"comment\">// 静态：实例的指针</span></span><br><span class=\"line\">\t<span class=\"type\">static</span> mutex _mutex;</span><br><span class=\"line\">\tstring data; <span class=\"comment\">// 代表类内的资源</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Singleton</span>(<span class=\"type\">const</span> Singleton&amp; another) = <span class=\"keyword\">delete</span>; <span class=\"comment\">// 禁止拷贝构造</span></span><br><span class=\"line\">\tSingleton&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Singleton&amp; another) = <span class=\"keyword\">delete</span>; <span class=\"comment\">// 禁止赋值</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">static</span> Singleton* <span class=\"title\">getInstance</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; val)</span></span>; <span class=\"comment\">// 静态：获取实例</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123; cout &lt;&lt; <span class=\"string\">&quot;data: &quot;</span> &lt;&lt; data &lt;&lt; endl; &#125; <span class=\"comment\">// 测试</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态成员需要在类外定义</span></span><br><span class=\"line\">Singleton* Singleton::_instance = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">mutex Singleton::_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; val)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">lock_guard&lt;mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(_mutex)</span></span>; <span class=\"comment\">// 出作用域自动释放</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_instance == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">\t\t_instance = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>(val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> _instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSingleton* a = Singleton::<span class=\"built_in\">getInstance</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">\ta-&gt;<span class=\"built_in\">show</span>(); <span class=\"comment\">// &quot;aaa&quot; ok</span></span><br><span class=\"line\">\tSingleton* b = Singleton::<span class=\"built_in\">getInstance</span>(<span class=\"string\">&quot;bbb&quot;</span>);</span><br><span class=\"line\">\tb-&gt;<span class=\"built_in\">show</span>(); <span class=\"comment\">// &quot;aaa&quot; ok</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2、双检查锁（有隐患）\"><a href=\"#2、双检查锁（有隐患）\" class=\"headerlink\" title=\"2、双检查锁（有隐患）\"></a>2、双检查锁（有隐患）</h2>reorder问题：通常new通常有三步：1、分配一块内存空间；2、执行构造器；3、返回指针；<br>但是由于编译器有时会进行优化，执行顺序变为132：即分配空间后先返回指针，再执行构造器<br>这样就会到来危险，比如线程A执行new，132，3执行完；线程B发现m_instance非空返回，然后外部直接用这个指针会出错<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双检查锁，但由于内存读写reorder不安全（不安全）</span></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m_instance==<span class=\"literal\">nullptr</span>)&#123; <span class=\"comment\">// 第一次检查，主要解决性能问题，毕竟读操作不需要上锁</span></span><br><span class=\"line\">        Lock lock;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_instance == <span class=\"literal\">nullptr</span>) &#123; <span class=\"comment\">// 第二次检查，解决核心问题：只能new单个</span></span><br><span class=\"line\">            m_instance = <span class=\"keyword\">new</span> <span class=\"built_in\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m_instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3、双检查锁（安全）\"><a href=\"#3、双检查锁（安全）\" class=\"headerlink\" title=\"3、双检查锁（安全）\"></a>3、双检查锁（安全）</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//C++ 11版本之后的跨平台实现 (volatile)（安全）</span></span><br><span class=\"line\">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class=\"line\">std::mutex Singleton::m_mutex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Singleton* <span class=\"title\">Singleton::getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Singleton* tmp = m_instance.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">    std::<span class=\"built_in\">atomic_thread_fence</span>(std::memory_order_acquire); <span class=\"comment\">// 获取内存fence</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(m_mutex)</span></span>;</span><br><span class=\"line\">        tmp = m_instance.<span class=\"built_in\">load</span>(std::memory_order_relaxed);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (tmp == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            tmp = <span class=\"keyword\">new</span> Singleton;</span><br><span class=\"line\">            std::<span class=\"built_in\">atomic_thread_fence</span>(std::memory_order_release); <span class=\"comment\">// 释放内存fence</span></span><br><span class=\"line\">            m_instance.<span class=\"built_in\">store</span>(tmp, std::memory_order_relaxed);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://refactoringguru.cn/design-patterns/catalog\">Refactoring.Guru</a></li>\n<li>李建忠 设计模式 课程</li>\n</ul>\n","tags":["C/C++","设计模式"]},{"title":"右值引用详解","url":"/2022/04/08/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E8%AF%A6%E8%A7%A3/","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><ol>\n<li>临时对象非必要的昂贵的拷贝操作</li>\n<li>在模板函数中如何按照参数的实际类型进行转发</li>\n</ol>\n<ul>\n<li>关键字：右值、纯右值、将亡值、universal references、引用折叠、移动语义、move语义、完美转发</li>\n<li>以下用四条代码来阐述C++的右值引用及其思想</li>\n</ul>\n<h1 id=\"1-第一行代码\"><a href=\"#1-第一行代码\" class=\"headerlink\" title=\"1. 第一行代码\"></a>1. 第一行代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"built_in\">getVal</span>();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>上式代码会产生一个左值和纯右值，<strong>右值是不具名的，判断左值和右值的办法就是看能否取地址</strong></li>\n<li>在C++11中所有的值必属于左值、将亡值、纯右值三者之一。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。</li>\n</ul>\n<h1 id=\"2-第二行代码\"><a href=\"#2-第二行代码\" class=\"headerlink\" title=\"2. 第二行代码\"></a>2. 第二行代码</h1><h2 id=\"2-1-特点1：重获新生\"><a href=\"#2-1-特点1：重获新生\" class=\"headerlink\" title=\"2.1 特点1：重获新生\"></a>2.1 特点1：重获新生</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">T <span class=\"title\">getVal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">T</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">T k = <span class=\"built_in\">getVal</span>();     <span class=\"comment\">// F1</span></span><br><span class=\"line\">T&amp;&amp; k = <span class=\"built_in\">getVal</span>();   <span class=\"comment\">// F2</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>F1：调用一次默认构造、两次拷贝构造（一次函数内到函数外的临时值，一次临时值到k）</li>\n<li>F2：调用一次默认构造、一次拷贝构造（一次函数内到函数外的临时值，并且临时值通过右值引用<strong>重获新生</strong>）</li>\n<li>现代编译器进行了优化，可能仅仅调用一次默认构造，但这不是C++标准</li>\n<li>当然在C++98/03年代，为了相同的目的，可以用常量左值引用这种万能引用：<code>const T&amp; k = getVal();</code>，也能达到减少一次拷贝构造的目的，但是k不能再改变了。</li>\n</ul>\n<h2 id=\"2-2-特点2：右值引用“二相性”\"><a href=\"#2-2-特点2：右值引用“二相性”\" class=\"headerlink\" title=\"2.2 特点2：右值引用“二相性”\"></a>2.2 特点2：右值引用“二相性”</h2><ul>\n<li>右值引用独立于左值和右值，即，右值引用类型的变量可能是左值也可能是右值，例如：<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; val = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></li>\n<li><strong>val类型为右值引用，但val本身是左值</strong>，所有具名变量都是左值<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">f</span>(<span class=\"number\">10</span>); <span class=\"comment\">// t是右值 T&amp;&amp; t = 10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">f</span>(x);  <span class=\"comment\">// t是左值 (T&amp;)&amp;&amp; t = x，折叠后变为T&amp; t = x;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3-特点3：通用引用-universal-references\"><a href=\"#2-3-特点3：通用引用-universal-references\" class=\"headerlink\" title=\"2.3 特点3：通用引用(universal references)\"></a>2.3 特点3：通用引用(universal references)</h2></li>\n<li>T&amp;&amp; t在<strong>发生自动类型推断</strong>的时候，它是通用引用类型</li>\n<li>通用引用是需要初始化的，如果是左值，那就归为左值引用，如果是右值，那就归为右值引用。<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意上述关键词：&quot;发生自动类型推断&quot;时</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp;&amp; b = a;  <span class=\"comment\">// b类型为左值引用 (int&amp;)&amp;&amp; b -&gt; int&amp; b = a</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span>&amp;&amp; c = <span class=\"number\">10</span>; <span class=\"comment\">// c类型为右值引用 int&amp;&amp; b = 10</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"引用折叠\"><a href=\"#引用折叠\" class=\"headerlink\" title=\"引用折叠\"></a><strong>引用折叠</strong></h3></li>\n</ul>\n<ol>\n<li>所有的右值引用叠加到右值引用上仍然还是一个右值引用<ul>\n<li>类型 T&amp;&amp; &amp;&amp; 折叠成 T&amp;&amp;</li>\n</ul>\n</li>\n<li>所有的其他引用类型之间的叠加都将变成左值引用<ul>\n<li>T&amp; &amp;、T&amp; &amp;&amp; 和 T&amp;&amp; &amp; 都会折叠成类型 T&amp;</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"3-第三行代码\"><a href=\"#3-第三行代码\" class=\"headerlink\" title=\"3. 第三行代码\"></a>3. 第三行代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; a) : <span class=\"built_in\">m_val</span>(a.m_val) &#123; a.m_val=<span class=\"literal\">nullptr</span>; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>即，移动构造函数(move constructor)，采用浅拷贝的方式，因为某些临时变量如果没有移动构造函数，则会频繁发生拷贝构造（深拷贝），如果对象内部堆空间很大的话，代价会非常大</li>\n<li>这里介绍move语句，move语句会将一个左值变为一个右值类型。<code>move(val)</code>后，并不会对val本身做出改变。类似上面的代码，将<code>move(val)</code>交给一个构造函数或者一个赋值函数，那么会按照右值类型匹配对应的移动构造函数和移动赋值函数，在移动函数里会将<code>val</code>的资源指针交给别人，<code>val</code>自身资源指针指向<code>nullptr</code>，这个时候<code>val</code>才会发生改变（你在代码里<code>move(val)</code>一百次，但是不交给对应函数匹配处理，那么<code>val</code>就不会有一丁点的变化）。当然，这些操作别人已经实现好了，如果是你自己的类，要自己实现！</li>\n</ul>\n<h1 id=\"4-第四行代码\"><a href=\"#4-第四行代码\" class=\"headerlink\" title=\"4. 第四行代码\"></a>4. 第四行代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123; </span><br><span class=\"line\">    <span class=\"built_in\">foo</span>(std::forward&lt;T&gt;(val));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-1-C-11前，调用模板函数的问题\"><a href=\"#4-1-C-11前，调用模板函数的问题\" class=\"headerlink\" title=\"4.1 C++11前，调用模板函数的问题\"></a>4.1 C++11前，调用模板函数的问题</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">processValue</span>(val); <span class=\"comment\">// 右值参数会变成左值传递给processValue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>因此引入了完美转发<code>std::forward</code>，他会按照参数的实际类型进行转发<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a)</span></span>&#123; cout &lt;&lt; <span class=\"string\">&quot;lvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processValue</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; a)</span></span>&#123; cout &lt;&lt; <span class=\"string\">&quot;rvalue&quot;</span> &lt;&lt; endl; &#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">forwardValue</span><span class=\"params\">(T&amp;&amp; val)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 照参数本来的类型进行转发。</span></span><br><span class=\"line\">    <span class=\"built_in\">processValue</span>(std::forward&lt;T&gt;(val)); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Testdelcl</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    forwardValue(i); <span class=\"comment\">// 传入左值 输出：lvaue </span></span><br><span class=\"line\">    forwardValue(<span class=\"number\">0</span>); <span class=\"comment\">// 传入右值 暑促和：rvalue</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>T&amp;&amp;是一个通用引用(universal references)，可以接受左值或者右值，正是这个特性让他适合作为一个参数的<strong>路由</strong>，然后再通过std::forward按照参数的实际类型去匹配对应的重载函数，最终实现完美转发。</li>\n</ul>\n<h2 id=\"4-2-进一步体会完美转发\"><a href=\"#4-2-进一步体会完美转发\" class=\"headerlink\" title=\"4.2 进一步体会完美转发\"></a>4.2 进一步体会完美转发</h2><h3 id=\"4-2-1-问题\"><a href=\"#4-2-1-问题\" class=\"headerlink\" title=\"4.2.1 问题\"></a>4.2.1 问题</h3><ul>\n<li><code>func</code>函数接收的<code>v2</code>是引用，但是引用的却是<code>middle</code>里面的一个局部变量<code>t2</code>，而非<code>main</code>中的<code>t2</code>，应该怎么办？<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1 t1, T2 t2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">f</span>(t1, t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;  <span class=\"comment\">// v2 是一个引用</span></span><br><span class=\"line\">  ++v1;</span><br><span class=\"line\">  ++v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">func</span>(<span class=\"number\">42</span>, i);</span><br><span class=\"line\">  <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">middle</span>(func, <span class=\"number\">42</span>, i);</span><br><span class=\"line\">  <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-2-尝试\"><a href=\"#4-2-2-尝试\" class=\"headerlink\" title=\"4.2.2 尝试\"></a>4.2.2 尝试</h3></li>\n<li><code>middle</code>中<code>t1</code>类型是<code>int&amp;&amp;</code>，<code>t2</code>类型是<code>int&amp; &amp;&amp; -&gt; int&amp;</code>，<code>i</code>的值也如预期般变化<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">f</span>(t1, t2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;  <span class=\"comment\">// v2 是一个引用</span></span><br><span class=\"line\">  ++v1;</span><br><span class=\"line\">  ++v2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>* argv[])</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">func</span>(<span class=\"number\">42</span>, i);</span><br><span class=\"line\">  <span class=\"comment\">// here i = 1</span></span><br><span class=\"line\">  <span class=\"built_in\">middle</span>(func, <span class=\"number\">42</span>, i);</span><br><span class=\"line\">  <span class=\"comment\">// here i = 2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>虽然看似没毛病，但是我们改一下<code>func</code>，就会暴露问题，修改func如下：<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; v1, <span class=\"type\">int</span>&amp; v2)</span> </span>&#123;</span><br><span class=\"line\">  ++v1;</span><br><span class=\"line\">  ++v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>修改<code>func</code>后再用4.2.2的代码运行就会报错，提示：“无法将一个右值引用绑定到左值上”，why？因为，在<code>main</code>中42虽然是右值，传入到<code>middle</code>后<code>t1</code>的类型也确实是<code>int&amp;&amp;</code>，但是<code>t1</code>本身作为具名变量，它是一个左值！而左值是无法与右值进行绑定的。</li>\n</ul>\n<h3 id=\"4-2-3-解决\"><a href=\"#4-2-3-解决\" class=\"headerlink\" title=\"4.2.3 解决\"></a>4.2.3 解决</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> F, <span class=\"keyword\">typename</span> T1, <span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">middle</span><span class=\"params\">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">f</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>forward</code>就是解决以上问题的关键</li>\n<li><code>42</code>传入<code>middle</code>后绑定到<code>t1</code>，此时t1类型是<code>int&amp;&amp;</code>（其中<code>T1</code>是<code>int</code>）。通过<code>forward&lt;T1&gt;(t1) -&gt; forward&lt;int&gt;(t1)</code>，将返回<code>int&amp;&amp;</code>成功传给func函数。这里你肯定有疑问，刚才不就是<code>int&amp;&amp;</code>？你绕一大圈子是不是耍人？其实不然，之前的那个啊叫named rvalue，有名字，传参时被当成左值！现在通过<code>forward</code>返回的是无名字的真正的右值，从而右值得到了保留！</li>\n<li><code>i</code>传入<code>middle</code>后绑定到<code>t2</code>，此时t2类型为<code>int&amp; &amp;&amp;</code>（其中<code>T2</code>是<code>int&amp;</code>，why？因为<code>T2</code>如果是<code>int</code>，那么就变成<code>int&amp;&amp; t2 = i</code>，会导致右值绑定一个左值从而报错！）经过引用折叠变为<code>int&amp;</code>.通过<code>forward&lt;T2&gt;(t2) -&gt; forward&lt;int&amp;&gt;(t2)</code>，将返回一个<code>int&amp; &amp;</code>，折叠后变为<code>int&amp;</code>，左值也得到了保留！</li>\n</ul>\n<h2 id=\"4-3-应用：泛型工厂函数\"><a href=\"#4-3-应用：泛型工厂函数\" class=\"headerlink\" title=\"4.3 应用：泛型工厂函数\"></a>4.3 应用：泛型工厂函数</h2><p>利用forward可以实现一个泛型的工厂函数，这个工厂函数可以创建所有类型的对象。具体实现如下：<br><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span>…  Args&gt;</span></span><br><span class=\"line\"><span class=\"function\">T* <span class=\"title\">Instance</span><span class=\"params\">(Args&amp;&amp;… args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">T</span>(std::forward&lt;Args &gt;(args)…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>这个工厂函数的参数是右值引用类型，内部使用std::forward按照参数的实际类型进行转发，如果参数的实际类型是右值，那么创建的时候会自动匹配移动构造，如果是左值则会匹配拷贝构造。</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li><a href=\"https://www.cnblogs.com/qicosmos/p/4283455.html#:~:text=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E6%98%AFC,%E8%BF%99%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98%E7%9A%84%E3%80%82\">博客园qicosmos(江南)</a></li>\n<li><a href=\"https://www.guodong.plus/2020/0314-132811/\">Dong’s Blog</a></li>\n</ul>\n","tags":["C/C++"]},{"title":"字符串匹配","url":"/2022/04/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","content":"<h1 id=\"BF-Brute-Force-算法\"><a href=\"#BF-Brute-Force-算法\" class=\"headerlink\" title=\"BF(Brute Force)算法\"></a>BF(Brute Force)算法</h1><ul>\n<li>BF是最符合人类直觉的字符串匹配算法，但是主串的下标<code>i</code>经常要往回走，无法利用已匹配信息，效率不够好<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bruteForce</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// i和j都是非负数，所以可以和无符号直接比较</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; t.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; p.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (t[i] == p[j]) &#123;</span><br><span class=\"line\">\t\t\t++i; ++j;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\ti = i - j + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tj = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h1><ul>\n<li>思想：“利用已部分匹配的信息，保持 $i$ 指针不回溯，通过修改 $j$ 指针，让模式串尽量移动到有效的位置”</li>\n<li>定义 $next$ 数组： <code>next[j] = d</code> 表示当 <code>t[i] != p[j]</code> 时， $j$ 下一次匹配的位置。注意到，下标从0开始，$d$ 值实际上是下标 $j$ 前的<strong>最长前后缀子串</strong>的<strong>长度</strong></li>\n<li>求取 $next$ 的过程本身就是 $p$ 串与自己匹配的过程<ol>\n<li>当 <code>p[i]==p[j]</code> ，则 <code>p[++i] = ++j</code></li>\n<li>当 <code>p[i]!=p[j]</code> ，则利用前面已求得的 $next$ 数组，<code>j=next[j]</code> ；直到无法找到，此时 <code>j=-1</code> ，自动进入第一个 $if$ 语句，此时 $i$ 往后走一步，妙<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">\tnext[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// !!! i &lt; n 则会在下面越界，因为0已经求过了，循环只会进行n-1次</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || p[i] == p[j]) &#123;</span><br><span class=\"line\">\t\t\t++i, ++j;</span><br><span class=\"line\">\t\t\tnext[i] = j;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; next = <span class=\"built_in\">getNext</span>(p);</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = t.<span class=\"built_in\">size</span>(), m = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// !!! j可以为负数，和无符号比较会转换为无符号比较法(南辕北辙)</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || t[i] == p[j]) &#123;</span><br><span class=\"line\">\t\t\t++i; ++j;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"KMP之Next优化\"><a href=\"#KMP之Next优化\" class=\"headerlink\" title=\"KMP之Next优化\"></a>KMP之Next优化</h1><ul>\n<li>比如 $[ A B A B ]$ 这个串，按照上面所述KMP得到的结果是 [-1, 0, 0, 1] ，然而，例如匹配的是 $[ A B A B D E]$ ，在下标为 $3$ 处失败了，$next$ 指导去下标 $1$ 处继续匹配，但是，下标 $1$ 和下标 $3$ 都是 $B$ ，没有必要再进行比较了。诸如此类的例子还有 $[ A A A A B]$ ，用上述KMP得到的 $next$ 是 [-1, 0, 1, 2, 3]</li>\n<li>方法就是在 <code>++i, ++j</code> 后加一步判断，本来直接 <code>next[i]=j</code> 但是如果 <code>p[i]==p[j]</code> 则如果以后匹配 <code>p[i]</code> 失败，则匹配 <code>p[j]</code> 肯定也失败啊，所以如果两者相等，直接 <code>next[i] = next[j]</code> 。此时的结果对于 $[ A B A B ]$ 产生的是 [-1, 0, -1, 0]；对于 $[ A A A A B]$ 产生的是 [-1, -1, -1, -1, 3]</li>\n<li>加三行代码就行了<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">\tnext[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || p[i] == p[j]) &#123;</span><br><span class=\"line\">\t\t\t++i, ++j;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (p[i] == p[j]) <span class=\"comment\">// new </span></span><br><span class=\"line\">\t\t\t\tnext[i] = next[j]; <span class=\"comment\">// new </span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> <span class=\"comment\">// new</span></span><br><span class=\"line\">\t\t\t\tnext[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; t, <span class=\"type\">const</span> string&amp; p)</span> </span>&#123;</span><br><span class=\"line\">\tvector&lt;<span class=\"type\">int</span>&gt; next = <span class=\"built_in\">getNext</span>(p);</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = t.<span class=\"built_in\">size</span>(), m = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || t[i] == p[j]) &#123;</span><br><span class=\"line\">\t\t\t++i; ++j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ul>\n<li>博客园博主：<a href=\"https://www.cnblogs.com/dusf/p/kmp.html\">sofu6</a></li>\n</ul>\n","tags":["算法","字符串"]},{"title":"目标检测SSD","url":"/2021/11/23/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BSSD/","content":"<blockquote>\n<p><strong>目标检测SSD</strong></p>\n</blockquote>\n<h3 id=\"1-锚框的长和宽\"><a href=\"#1-锚框的长和宽\" class=\"headerlink\" title=\"1. 锚框的长和宽\"></a>1. 锚框的长和宽</h3><h4 id=\"1-1-书上代码解析\"><a href=\"#1-1-书上代码解析\" class=\"headerlink\" title=\"1.1 书上代码解析\"></a>1.1 书上代码解析</h4><script type=\"math/tex; mode=display\">\ns指的是长宽的缩放比例而非面积的缩放比例。\\\\\n比如s=0.5，则面积就是原图像的0.5^2=0.25倍\\\\\n----------------\\\\\nr是宽高比，指的是将原图像归一化为正方形后截取\\\\\n的锚框的宽高比；或者说是在原图像的宽高比基础上\\\\\n乘以r，才是锚框的宽高比。锚框的实际宽高比即\\\\\n\\frac{w}{h}*r，\\\\\n之所以r=1时你看到的是方形，之后会解释\\\\\n----------------\\\\\n由此，可得以下方程组\\\\\n\\begin{cases}\nw_0*h_0=s^2*w*h\\\\\n\\frac{w_0}{h_0}=\\frac{w}{h} * r\\\\\n\\end{cases}\\\\\n解得\\\\\n\\begin{cases}\nw_0=s*w*\\sqrt{r}\\\\\nh_0=s*h/\\sqrt{r}\\\\\n\\end{cases}\\\\\nw_0和h_0分别处以w和h进行归一化，可得\\\\\n\\begin{cases}\nw_0=s*\\sqrt{r}\\\\\nh_0=s/\\sqrt{r}\\\\\n\\end{cases}\\\\</script><p>而在代码中我们可以看到：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">w0 = torch.cat((size_tensor * torch.sqrt(ratio_tensor[0]),</span><br><span class=\"line\">                   sizes[0] * torch.sqrt(ratio_tensor[1:])))\\</span><br><span class=\"line\">                   * in_height / in_width</span><br><span class=\"line\">h0 = torch.cat((size_tensor / torch.sqrt(ratio_tensor[0]),</span><br><span class=\"line\">                   sizes[0] / torch.sqrt(ratio_tensor[1:])))</span><br></pre></td></tr></table></figure>\n<p>先不看<code>in_height / in_width</code>。上面解得的归一化后的公式与代码所写的一模一样。代码中的$w_0$和$h_0$就是锚框归一化后的宽高（此时消除了原图像w和h的影响，可以认为，r所代表的宽高比就是此时锚框的宽高比，r=1时，是一个正方形锚框，也即此时$w_0$和$h_0$的值是一样的）。但是呢，由于我们显示的时候需要乘以图像的实际宽高所以，乘后的锚框实际宽高比就不是1了，所以才要乘以<code>in_height / in_width</code>，作用就是抵消乘以实际图像长宽后r会改变的问题，当然这样做存粹是为了显示方便（也让你误以为r是指锚框的宽高比），带来的副作用就是，锚框的实际面积就不再是原始图像的$s^2$。<code>(￣ε(#￣)。</code></p>\n<p>由于实际在我们进行目标检测时，特征图长和宽都是相同的，比如(19, 19)、(7, 7)，所以<code>in_height / in_width</code>恒等于1，因此对于实际的使用并不会带来副作用。但此时，如果要将锚框显示出来，归一化后的锚框再乘以图像实际长宽后，所显示的锚框的长宽比会改变。如下图所示，特征图宽高是(1, 1)，当r=1，s=0.5时，最终锚框的宽高比并不是r=1，而是$\\frac{w}{h}*r$。即上述代码中<code>in_height / in_width</code>这部分失效了。好消息是，面积是原图的$s^2$，又符合定义了。<code>\\(￣︶￣\\))</code></p>\n<p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/目标检测SSD-图1.png\" alt=\"\"></p>\n<h4 id=\"1-2-尝试的改动\"><a href=\"#1-2-尝试的改动\" class=\"headerlink\" title=\"1.2 尝试的改动\"></a>1.2 尝试的改动</h4><p>所以如果r宽高比的定义按照<strong>原图像的宽高比*r</strong>来定义，那么沐神的代码和书上的公式在<strong>实际使用</strong>时都是没问题的。只是将这个函数作用于特征图<strong>宽高不相同</strong>的实例时（比如为了给观众显示方便，直接作用上面这幅图像），会产生一丢丢歧义：此时的r的定义居然又变回了<strong>锚框的宽高比</strong>。</p>\n<p>我们可以尝试来重新定义宽高比r（s定义不变），直接<strong>认定它代表锚框的宽高比</strong>，会有如下公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\frac{w_0}{h_0}=r\\\\\nw_0*h_0 = s^2*w*h\\\\\n\\end{cases}\\\\\n解得\\\\\n\\begin{cases}\nw_0=s*\\sqrt{w*h*r}\\\\\nh_0=s*\\sqrt{\\frac{w*h}{r}}\\\\\n\\end{cases}\\\\\nw_0和h_0分别处以w和h进行归一化，可得\\\\\n\\begin{cases}\nw_0=s*\\sqrt{\\frac{h*r}{w}}\\\\\nh_0=s*\\sqrt{\\frac{w}{r*h}}\\\\\n\\end{cases}\\\\</script><p>这样定义的话，就要求<code>multibox_prior()</code>函数要传入原图像的长度和宽度。<br>下面实验验证，不论特征图的长宽怎么变，r和s的定义都是一致的。</p>\n<p><img src=\"https://raw.githubusercontent.com/fkjkkll/OnlineSource/master/Image/目标检测SSD-图2.png\" alt=\"\"></p>\n<h3 id=\"2-锚框偏移\"><a href=\"#2-锚框偏移\" class=\"headerlink\" title=\"2. 锚框偏移\"></a>2. 锚框偏移</h3><p>假设$\\hat{g}_j$是某个标签目标，$d_i$是某个anchor，边框回归与Faster-RCNN类似<br>回归的偏移相对的是$d_i$的中点和宽高(cx, cy, w, h)</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\hat{g}^{cx}_j = (g^{cx}_j - d^{cx}_i)/d^w_i\\\\\n\\hat{g}^{cy}_j = (g^{cy}_j - d^{cy}_i)/d^h_i\\\\\n\\hat{g}^{cw}_j = log(g^{cw}_j / d^{cw}_i)\\\\\n\\hat{g}^{ch}_j = log(g^{ch}_j / d^{ch}_i)\\\\\n\\end{cases}\\\\</script><p>解释：</p>\n<ul>\n<li>激活的锚框（即给分配了某gt的正样本），其与某gt的IOU肯定不低，则其x、y、w、h也肯定差不大，这是前提</li>\n<li>x、y：做差后分布于零点对称，除以锚框宽或高起到归一化作用，值分布变窄</li>\n<li>w、h：做除法后用log，可近似线性，且使得结果的分布呈现零点对称，使得网络回归更简单</li>\n</ul>\n","tags":["目标检测"]},{"title":"线程安全智能指针","url":"/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"<h1 id=\"线程安全的share指针\"><a href=\"#线程安全的share指针\" class=\"headerlink\" title=\"线程安全的share指针\"></a>线程安全的share指针</h1><h2 id=\"1-代码部分\"><a href=\"#1-代码部分\" class=\"headerlink\" title=\"1. 代码部分\"></a>1. 代码部分</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">Counter</span>(): <span class=\"built_in\">m_Counter</span>(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">Counter</span>(<span class=\"type\">const</span> Counter&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">\tCounter&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Counter&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">\t~<span class=\"built_in\">Counter</span>() &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">()</span> </span>&#123; m_Counter = <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_Counter; &#125;</span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>++() &#123; m_Counter++; &#125;</span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) &#123; m_Counter++; &#125;</span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>--() &#123; m_Counter--; &#125;</span><br><span class=\"line\">\t<span class=\"type\">void</span> <span class=\"keyword\">operator</span>--(<span class=\"type\">int</span>) &#123; m_Counter--; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> m_Counter&#123;&#125;; <span class=\"comment\">// 花括号也可以初始化</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">SharedPtr</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">SharedPtr</span><span class=\"params\">(T *ptr = <span class=\"literal\">nullptr</span>)</span>: // explicit</span></span><br><span class=\"line\"><span class=\"function\">\t\tpData(ptr),</span></span><br><span class=\"line\"><span class=\"function\">\t\tpCounter(new Counter()),</span></span><br><span class=\"line\"><span class=\"function\">\t\tpMutex(new std::mutex)</span></span><br><span class=\"line\"><span class=\"function\">\t&#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ptr) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">SharedPtr</span>(<span class=\"type\">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class=\"line\">\t\tpData = sp.pData;</span><br><span class=\"line\">\t\tpCounter = sp.pCounter;</span><br><span class=\"line\">\t\tpMutex = sp.pMutex;</span><br><span class=\"line\">\t\t<span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSharedPtr&lt;T&gt;&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> SharedPtr&lt;T&gt;&amp; sp) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pData != sp.pData) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">subCount</span>();</span><br><span class=\"line\">\t\t\tpData = sp.pData;</span><br><span class=\"line\">\t\t\tpCounter = sp.pCounter;</span><br><span class=\"line\">\t\t\tpMutex = sp.pMutex;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">addCount</span>();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tT* <span class=\"keyword\">operator</span>-&gt;() &#123; <span class=\"keyword\">return</span> pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tT&amp; <span class=\"keyword\">operator</span>*() &#123; <span class=\"keyword\">return</span> *pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">T* <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> pData; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> pCounter-&gt;<span class=\"built_in\">get</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t~<span class=\"built_in\">SharedPtr</span>() &#123; <span class=\"built_in\">subCount</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tpMutex-&gt;<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t\t++(*pCounter);</span><br><span class=\"line\">\t\tpMutex-&gt;<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">subCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">bool</span> deleteflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\tpMutex-&gt;<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">\t\t--(*pCounter);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pCounter-&gt;<span class=\"built_in\">get</span>() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> pCounter;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">delete</span> pData;</span><br><span class=\"line\">\t\t\tdeleteflag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpMutex-&gt;<span class=\"built_in\">unlock</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (deleteflag == <span class=\"literal\">true</span>) <span class=\"keyword\">delete</span> pMutex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT *pData;</span><br><span class=\"line\">\tstd::mutex *pMutex;</span><br><span class=\"line\">\tCounter *pCounter;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">MyClass</span>() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Constructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t~<span class=\"built_in\">MyClass</span>() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">SharedPtr&lt;MyClass&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> MyClass())</span></span>;</span><br><span class=\"line\">\tSharedPtr&lt;MyClass&gt; p2 = p;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;END&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-参考资料\"><a href=\"#2-参考资料\" class=\"headerlink\" title=\"2. 参考资料\"></a>2. 参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/songguangfan/article/details/121974538\">1. 线程安全智能指针</a></li>\n<li><a href=\"https://www.cnblogs.com/WindSun/p/11444429.html\">2. 智能指针</a></li>\n</ul>\n","tags":["C/C++"]},{"title":"计算器","url":"/2022/04/05/%E8%AE%A1%E7%AE%97%E5%99%A8/","content":"<h1 id=\"功能说明\"><a href=\"#功能说明\" class=\"headerlink\" title=\"功能说明\"></a>功能说明</h1><ul>\n<li>实现+、-、*、/、括号的整数运算</li>\n<li>实现处理多余空格</li>\n</ul>\n<h1 id=\"实现1（更高效）\"><a href=\"#实现1（更高效）\" class=\"headerlink\" title=\"实现1（更高效）\"></a>实现1（更高效）</h1><ul>\n<li>用引用<code>l</code>指针的方式逐步处理<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span>&amp; l)</span> </span>&#123;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> sign = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (; l &lt; n; ++l) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> c = s[l];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c)) </span><br><span class=\"line\">\t\t\tnum = num * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// if(c == &#x27; &#x27;) continue是不对的，因为l=n-1时一定要最后来一次</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((!<span class=\"built_in\">isdigit</span>(c) &amp;&amp; c != <span class=\"string\">&#x27; &#x27;</span>) || l == n - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span>) </span><br><span class=\"line\">\t\t\t\tnum = <span class=\"built_in\">core</span>(s, ++l); <span class=\"comment\">// 理解这种递归思想很重要</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> prev;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (sign) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(-num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tprev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(prev * num);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tprev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(prev / num);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsign = c;</span><br><span class=\"line\">\t\t\tnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span>) </span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!stk.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tret += stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\tstk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">caculator</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> tmp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">core</span>(s, tmp);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"实现2（更优雅）\"><a href=\"#实现2（更优雅）\" class=\"headerlink\" title=\"实现2（更优雅）\"></a>实现2（更优雅）</h1><ul>\n<li>由于需要不停<code>pop</code>首部，所以采用<code>deque</code>代替移动的<code>l</code>，更优雅<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">core</span><span class=\"params\">(deque&lt;<span class=\"type\">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class=\"line\">\tstack&lt;<span class=\"type\">int</span>&gt; stk;</span><br><span class=\"line\">\t<span class=\"type\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> sign = <span class=\"string\">&#x27;+&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> c = s[<span class=\"number\">0</span>]; s.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">isdigit</span>(c))</span><br><span class=\"line\">\t\t\tnum = num * <span class=\"number\">10</span> + (c - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((!<span class=\"built_in\">isdigit</span>(c) &amp;&amp; c != <span class=\"string\">&#x27; &#x27;</span>) || s.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;(&#x27;</span>)</span><br><span class=\"line\">\t\t\t\tnum = <span class=\"built_in\">core</span>(s);</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> prev;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">switch</span> (sign) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(-num); <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;*&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tprev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(prev * num);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">\t\t\t\tprev = stk.<span class=\"built_in\">top</span>(); stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t\t\tstk.<span class=\"built_in\">push</span>(prev / num);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">default</span>: <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tsign = c;</span><br><span class=\"line\">\t\t\tnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;)&#x27;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!stk.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tret += stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">\t\tstk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">caculator</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">\tdeque&lt;<span class=\"type\">char</span>&gt; dq;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; e : s) dq.<span class=\"built_in\">push_back</span>(e);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">core</span>(dq);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>labuladong的算法小抄</li>\n</ul>\n","tags":["算法","递归","栈"]},{"title":"读者写者问题","url":"/2021/08/27/%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/","content":"<blockquote>\n<p><strong>经典读者写者问题</strong></p>\n</blockquote>\n<h3 id=\"读者写者问题\"><a href=\"#读者写者问题\" class=\"headerlink\" title=\"读者写者问题\"></a>读者写者问题</h3><h5 id=\"1、读者优先\"><a href=\"#1、读者优先\" class=\"headerlink\" title=\"1、读者优先\"></a>1、读者优先</h5><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> readcount=<span class=\"number\">0</span>; </span><br><span class=\"line\">semaphore RCSignal=<span class=\"number\">1</span>, fileSrc=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// RCSignal readcount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// fileSrc 文件资源互斥量：实现读者优先</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读者进程：</span></span><br><span class=\"line\">\t<span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">\treadcount++;\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (readcount == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">\t<span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"comment\">// reading is performed</span></span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">\treadcount--;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (readcount == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\">\t<span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 写者进程：     </span></span><br><span class=\"line\">\t<span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//writing is performed</span></span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">\t<span class=\"built_in\">V</span>(fileSrc);</span><br></pre></td></tr></table></figure>\n<h5 id=\"2、写者优先\"><a href=\"#2、写者优先\" class=\"headerlink\" title=\"2、写者优先\"></a>2、写者优先</h5><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> readcount=<span class=\"number\">0</span>, writecount=<span class=\"number\">0</span>; </span><br><span class=\"line\">semaphore RCSignal=<span class=\"number\">1</span>, WCSignal=<span class=\"number\">1</span>, read=<span class=\"number\">1</span>, fileSrc;</span><br><span class=\"line\"><span class=\"comment\">// RCSignal readcount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// WCSignal writecount修改互斥量</span></span><br><span class=\"line\"><span class=\"comment\">// read 实现写者优先：拦截读者</span></span><br><span class=\"line\"><span class=\"comment\">// fileSrc 文件资源互斥量：保护剩余读者（拦截写者），以及写者唯一</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读者进程：</span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(read);</span><br><span class=\"line\">\t<span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">\t\treadcount++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(readcount == <span class=\"number\">1</span> ) </span><br><span class=\"line\">    \t\t<span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">\t<span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(read);</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"comment\">// reading is performed</span></span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(RCSignal);</span><br><span class=\"line\">    readcount--;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (readcount == <span class=\"number\">0</span> )</span><br><span class=\"line\">\t\t<span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(RCSignal);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写者进程：     </span></span><br><span class=\"line\"><span class=\"built_in\">P</span>(WCSingal);</span><br><span class=\"line\">    writecount++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writecount == <span class=\"number\">1</span> )</span><br><span class=\"line\">\t\t<span class=\"built_in\">P</span>(read);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(WCSingal);</span><br><span class=\"line\"><span class=\"built_in\">P</span>(fileSrc);</span><br><span class=\"line\">    <span class=\"comment\">// writing is performed</span></span><br><span class=\"line\"><span class=\"built_in\">V</span>(fileSrc);</span><br><span class=\"line\"><span class=\"built_in\">P</span>(WCSingal);</span><br><span class=\"line\">    writecount --;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (writecount == <span class=\"number\">0</span>)</span><br><span class=\"line\">    \t<span class=\"built_in\">V</span>(read);</span><br><span class=\"line\"><span class=\"built_in\">V</span>(WCSingal); </span><br></pre></td></tr></table></figure>\n<h5 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h5><p><a href=\"https://www.bilibili.com/video/av21593625\">https://www.bilibili.com/video/av21593625</a><br><a href=\"https://blog.csdn.net/c1194758555/article/details/52805918\">https://blog.csdn.net/c1194758555/article/details/52805918</a><br><a href=\"https://blog.csdn.net/william_munch/article/details/84256690\">https://blog.csdn.net/william_munch/article/details/84256690</a>      （有问题？）</p>\n","tags":["操作系统"]},{"title":"路径搜索","url":"/2022/04/07/%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2/","content":"<h1 id=\"辅助代码（全局变量）\"><a href=\"#辅助代码（全局变量）\" class=\"headerlink\" title=\"辅助代码（全局变量）\"></a>辅助代码（全局变量）</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; node;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; G = &#123;</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">\t&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> row = (<span class=\"type\">int</span>)G.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"><span class=\"type\">int</span> col = (<span class=\"type\">int</span>)G[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">node S = &#123; <span class=\"number\">5</span>,<span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">node E = &#123; <span class=\"number\">5</span>,<span class=\"number\">10</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dir[] = &#123; <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span> &#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><ul>\n<li><strong>DFS是无法找到最优路径的</strong>（理论上可以，但是复杂度巨高，如果是四个方向搜索的话，那么就是四叉树，高度是图中结点数，也就是说如果是10x10的图，那就是大约4^100复杂度）</li>\n<li>下面代码只表示找到任意一条路后直接返回<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">visited</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(col, <span class=\"literal\">false</span>));</span><br><span class=\"line\">vector&lt;node&gt; path;</span><br><span class=\"line\"><span class=\"type\">bool</span> END = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(node cur)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cur == E) </span><br><span class=\"line\">\t\tEND = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tvisited[cur.first][cur.second] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tpath.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span> &amp;&amp; !END; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ix = cur.first + dir[i];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> iy = cur.second + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col || visited[ix][iy]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">dfs</span>(&#123; ix, iy &#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (END) <span class=\"keyword\">return</span>; <span class=\"comment\">// 保留路径</span></span><br><span class=\"line\">\tpath.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">\tvisited[cur.first][cur.second] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><ul>\n<li>BFS是可以找到最优路径的，每次到某点的距离变小时就将其加入队列</li>\n<li><strong>不可以提前结束</strong>，无法确定是否能够通过后面的点来缩短到终点的距离<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tqueue&lt;node&gt; qe;</span><br><span class=\"line\">\tqe.<span class=\"built_in\">push</span>(S);</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">10000</span>));</span><br><span class=\"line\">\tdist[S.first][S.second] = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\tnode cur = qe.<span class=\"built_in\">front</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ix = cur.first + dir[i];</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> iy = cur.second + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[ix][iy] &gt; dist[cur.first][cur.second] + G[ix][iy]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[ix][iy] = dist[cur.first][cur.second] + G[ix][iy];</span><br><span class=\"line\">\t\t\t\tqe.<span class=\"built_in\">emplace</span>(ix, iy);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"Dijkstra\"><a href=\"#Dijkstra\" class=\"headerlink\" title=\"Dijkstra\"></a>Dijkstra</h1><ul>\n<li>每次弹出优先队列的都是确定下来的最优解，因此可以接触终点时直接<code>break</code>提前结束</li>\n<li>也不需要visited数组，因为遇到重复的x和y时，优先队列会依照priority排列，大的自动排到后面，由于接触到终点直接break，那些非最优的都没机会弹出队列。</li>\n<li>你可能会想到有没有这种可能绕一个大圈然后使得到达终点的距离进一步降低？其实不可能的，因为优先队列的贪心思想，反证法：如果之前已经将E弹出，后面又经过X到达E使得dist(E)降低；但是既然后面再弹出的X，那证明X的dist比之前第一次弹出的E的dist要大(优先队列先弹出dist小的)，那如何能使得经过X后让E的dist减小呢？矛盾！<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">item</span>&#123; <span class=\"comment\">// 存放在优先队列的结构体</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"type\">int</span> priority;</span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> item&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;priority &gt; ano.priority;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpriority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">1000</span>)); <span class=\"comment\">// dist二维数组</span></span><br><span class=\"line\">\tqe.<span class=\"built_in\">push</span>(&#123; S.first, S.second, <span class=\"number\">0</span> &#125;); <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">\tdist[S.first][S.second] = <span class=\"number\">0</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\titem cur = qe.<span class=\"built_in\">top</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到后可以直接返回，这里贪心算法，确保是最优解</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur.x == E.first &amp;&amp; cur.y == E.second) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ix = cur.x + dir[i];</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> iy = cur.y + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[ix][iy] &gt; cur.priority + G[ix][iy]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[ix][iy] = cur.priority + G[ix][iy];</span><br><span class=\"line\">\t\t\t\tqe.<span class=\"built_in\">push</span>(&#123; ix, iy, dist[ix][iy] &#125;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"A星\"><a href=\"#A星\" class=\"headerlink\" title=\"A星\"></a>A星</h1></li>\n<li>A星的思想是对Dijkstra的一点改进。首先BFS是没有方向的，Dijkstra是在BFS之上加入了贪心思想，但是同样没有方向，A星则是增加了终点方向的属性，并入到Dijkstra的优先级中，参与优先队列的弹出选择，对于能明确表明与终点距离的图问题来说，效果相当不错。<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">item</span>&#123; <span class=\"comment\">// 存放在优先队列的结构体</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t<span class=\"type\">int</span> y;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p1; <span class=\"comment\">// 从起点到该点的 dist (与实际图权值相关，如果无权图则退化为曼哈顿距离)</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> p2; <span class=\"comment\">// 从该点到终点的 [曼哈顿距离] </span></span><br><span class=\"line\">\t<span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> item&amp; ano) <span class=\"type\">const</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p1 + p2 &gt; ano.p1 + ano.p2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取曼哈顿距离的函数</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> getP2 = [&amp;](<span class=\"type\">int</span> x, <span class=\"type\">int</span> y) &#123;<span class=\"keyword\">return</span> <span class=\"built_in\">abs</span>(E.first - x) + <span class=\"built_in\">abs</span>(E.second - y); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">aStar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tpriority_queue&lt;item, vector&lt;item&gt;, greater&lt;item&gt;&gt; qe;</span><br><span class=\"line\">\tvector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dist</span>(row, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(col, <span class=\"number\">1000</span>)); <span class=\"comment\">// dist二维数组</span></span><br><span class=\"line\">\tqe.<span class=\"built_in\">push</span>(&#123; S.first, S.second, <span class=\"number\">0</span>, <span class=\"built_in\">getP2</span>(S.first, S.second)&#125;); <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">\tdist[S.first][S.second] = <span class=\"number\">0</span>; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (!qe.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">\t\titem cur = qe.<span class=\"built_in\">top</span>(); qe.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\t<span class=\"comment\">// 找到后可以直接返回，这里贪心算法，确保是最优解</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cur.x == E.first &amp;&amp; cur.y == E.second) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; ++i) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> ix = cur.x + dir[i];</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> iy = cur.y + dir[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (ix &lt; <span class=\"number\">0</span> || ix &gt;= row || iy &lt; <span class=\"number\">0</span> || iy &gt;= col) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[ix][iy] &gt; cur.p1 + G[ix][iy]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[ix][iy] = cur.p1 + G[ix][iy];</span><br><span class=\"line\">\t\t\t\tqe.<span class=\"built_in\">push</span>(&#123; ix, iy, dist[ix][iy], <span class=\"built_in\">getP2</span>(ix, iy) &#125;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n","tags":["算法","递归"]},{"title":"链表排序","url":"/2022/04/04/%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F/","content":"<h1 id=\"1-插入排序\"><a href=\"#1-插入排序\" class=\"headerlink\" title=\"1. 插入排序\"></a>1. 插入排序</h1><ul>\n<li>只要注意每次判断比前面的大那就不需要回头</li>\n<li>否则需要从头找合适的位置<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">insertSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\tListNode dummy; dummy.next = head;</span><br><span class=\"line\">\tListNode* prev = head;</span><br><span class=\"line\">\tListNode* curr = head-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (curr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (prev-&gt;val &lt;= curr-&gt;val) &#123;</span><br><span class=\"line\">\t\t\tprev = curr;</span><br><span class=\"line\">\t\t\tcurr = curr-&gt;next;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tListNode* t = &amp;dummy;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (t-&gt;next &amp;&amp; t-&gt;next-&gt;val &lt;= curr-&gt;val) t = t-&gt;next;</span><br><span class=\"line\">\t\t\tprev-&gt;next = curr-&gt;next;</span><br><span class=\"line\">\t\t\tcurr-&gt;next = t-&gt;next;</span><br><span class=\"line\">\t\t\tt-&gt;next = curr;</span><br><span class=\"line\">\t\t\tcurr = prev-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"2-归并排序\"><a href=\"#2-归并排序\" class=\"headerlink\" title=\"2. 归并排序\"></a>2. 归并排序</h1><ul>\n<li>不论是主递归还是merge都要求两个链表以nullptr结尾</li>\n<li>也就是在合适的地方断开<h2 id=\"2-1-递归版本\"><a href=\"#2-1-递归版本\" class=\"headerlink\" title=\"2.1 递归版本\"></a>2.1 递归版本</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoList</span><span class=\"params\">(ListNode* p2a, ListNode* p2b)</span> </span>&#123;</span><br><span class=\"line\">\tListNode dummy;</span><br><span class=\"line\">\tListNode* ptr = &amp;dummy;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2a || p2b) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = p2a ? p2a-&gt;val : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> b = p2b ? p2b-&gt;val : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a &lt; b) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2a;</span><br><span class=\"line\">\t\t\tp2a = p2a-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2b;</span><br><span class=\"line\">\t\t\tp2b = p2b-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\tListNode* slow = head, *fast = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fast) &#123; <span class=\"comment\">// 链表快慢指针有多种形式，要会灵活运用</span></span><br><span class=\"line\">\t\tfast = fast-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fast) fast = fast-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(fast) slow = slow-&gt;next; <span class=\"comment\">// if(fast)：slow指向第一个链表的最后一位结点</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tListNode* head2 = slow-&gt;next;</span><br><span class=\"line\">\tslow-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">mergeTwoList</span>(<span class=\"built_in\">mergeSort</span>(head), <span class=\"built_in\">mergeSort</span>(head2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"2-2-非递归版本\"><a href=\"#2-2-非递归版本\" class=\"headerlink\" title=\"2.2 非递归版本\"></a>2.2 非递归版本</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeTwoList</span><span class=\"params\">(ListNode* p2a, ListNode* p2b)</span> </span>&#123;</span><br><span class=\"line\">\tListNode dummy;</span><br><span class=\"line\">\tListNode* ptr = &amp;dummy;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p2a || p2b) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = p2a ? p2a-&gt;val : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> b = p2b ? p2b-&gt;val : INT_MAX;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a &lt; b) &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2a;</span><br><span class=\"line\">\t\t\tp2a = p2a-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tptr-&gt;next = p2b;</span><br><span class=\"line\">\t\t\tp2b = p2b-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next; <span class=\"comment\">// 别忘了</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">mergeSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tListNode* ptr = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ptr) &#123; <span class=\"comment\">// 统计链表长度</span></span><br><span class=\"line\">\t\t++n;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tListNode dummy;</span><br><span class=\"line\">\tdummy.next = head;</span><br><span class=\"line\">\tptr = &amp;dummy;</span><br><span class=\"line\">\tListNode* prev, *l, *r, *t, *next; <span class=\"comment\">// 屮，5个指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> w = <span class=\"number\">1</span>; w &lt; n; w &lt;&lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\t\tprev = &amp;dummy;</span><br><span class=\"line\">\t\tl = dummy.next;</span><br><span class=\"line\">\t\tr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (l) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 第一个子链表的最后一个元素 注意：i从1开始</span></span><br><span class=\"line\">            t = l;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;</span><br><span class=\"line\">\t\t\tr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">\t\t\t\tr = t-&gt;next;</span><br><span class=\"line\">\t\t\t\tt-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 第二个子链表的最后一个元素 注意：i从1开始</span></span><br><span class=\"line\">            t = r;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; w &amp;&amp; t; ++i) t = t-&gt;next;</span><br><span class=\"line\">\t\t\tnext = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (t) &#123;</span><br><span class=\"line\">\t\t\t\tnext = t-&gt;next;</span><br><span class=\"line\">\t\t\t\tt-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            <span class=\"comment\">// 合并子链表</span></span><br><span class=\"line\">\t\t\tListNode* ret = <span class=\"built_in\">mergeTwoList</span>(l, r);</span><br><span class=\"line\">\t\t\tprev-&gt;next = ret;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// prev指向合并后的子链表的最后一个元素</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (prev-&gt;next) prev = prev-&gt;next;</span><br><span class=\"line\">\t\t\tl = next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"3-快速排序\"><a href=\"#3-快速排序\" class=\"headerlink\" title=\"3. 快速排序\"></a>3. 快速排序</h1><ul>\n<li>其实对于链表，由于不需要额外空间，归并排序其实很优秀了；快速排序由于需要选取pivot，选的不好，会变成n^2，而归并排序是稳定的nlogn</li>\n<li>pivot的选取可以将中点节点移到链头充当pivot或者随机一个节点充当pivot，否则对于有序数列，会退化为n^2</li>\n<li>由于无法采用l和r两边向中间靠拢的方式划分集合，只能采用单边形式，所以遇到“窄数据”或者都是一样值（窄特例化），也会退化为n^2<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">quickSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = head-&gt;val;</span><br><span class=\"line\">\tListNode L, R;</span><br><span class=\"line\">\tListNode* l = &amp;L, *r = &amp;R;</span><br><span class=\"line\">\tListNode* ptr = head-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ptr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ptr-&gt;val &lt;= pivot) &#123;</span><br><span class=\"line\">\t\t\tl-&gt;next = ptr;</span><br><span class=\"line\">\t\t\tl = l-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr-&gt;next = ptr;</span><br><span class=\"line\">\t\t\tr = r-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">\tr-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">\tl = <span class=\"built_in\">quickSort</span>(L.next);</span><br><span class=\"line\">\tr = <span class=\"built_in\">quickSort</span>(R.next);</span><br><span class=\"line\">\thead-&gt;next = r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!l) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\tListNode* t = l;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t-&gt;next) t = t-&gt;next;</span><br><span class=\"line\">\tt-&gt;next = head;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>取中间作为pivot<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">quickSort</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!head || !head-&gt;next) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\tListNode* slow = head, *fast = head;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (fast) &#123;</span><br><span class=\"line\">\t\tfast = fast-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fast) fast = fast-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (fast) slow = slow-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tListNode* newHead = slow-&gt;next;</span><br><span class=\"line\">\tslow-&gt;next = newHead-&gt;next;</span><br><span class=\"line\">\tnewHead-&gt;next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> pivot = newHead-&gt;val;</span><br><span class=\"line\">\tListNode L, R;</span><br><span class=\"line\">\tListNode* l = &amp;L, *r = &amp;R;</span><br><span class=\"line\">\tListNode* ptr = newHead-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ptr) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ptr-&gt;val &lt;= pivot) &#123;</span><br><span class=\"line\">\t\t\tl-&gt;next = ptr;</span><br><span class=\"line\">\t\t\tl = l-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tr-&gt;next = ptr;</span><br><span class=\"line\">\t\t\tr = r-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tl-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">\tr-&gt;next = <span class=\"literal\">nullptr</span>; <span class=\"comment\">// 断尾</span></span><br><span class=\"line\">\tl = <span class=\"built_in\">quickSort</span>(L.next);</span><br><span class=\"line\">\tr = <span class=\"built_in\">quickSort</span>(R.next);</span><br><span class=\"line\">\tnewHead-&gt;next = r;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!l) <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">\tListNode* t = l;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (t-&gt;next) t = t-&gt;next;</span><br><span class=\"line\">\tt-&gt;next = newHead;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"4-辅助代码\"><a href=\"#4-辅助代码\" class=\"headerlink\" title=\"4. 辅助代码\"></a>4. 辅助代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> val;</span><br><span class=\"line\">\tListNode* next;</span><br><span class=\"line\">\t<span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> _v = <span class=\"number\">0</span>) :<span class=\"built_in\">val</span>(_v), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">genList</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> range)</span> </span>&#123; <span class=\"comment\">// 数目， 分布范围</span></span><br><span class=\"line\">\tListNode dummy;</span><br><span class=\"line\">\tListNode* ptr = &amp;dummy;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> r = <span class=\"built_in\">rand</span>() % range;</span><br><span class=\"line\">\t\tListNode* tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(r);</span><br><span class=\"line\">\t\tptr-&gt;next = tmp;</span><br><span class=\"line\">\t\tptr = ptr-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> dummy.next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">parseList</span><span class=\"params\">(ListNode* p, <span class=\"type\">bool</span> show=<span class=\"literal\">true</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(show) cout &lt;&lt; p-&gt;val &lt;&lt; <span class=\"string\">&quot;\\t&quot;</span>;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\t++cnt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (show &amp;&amp; cnt / <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">\t\t\tret += cnt;</span><br><span class=\"line\">\t\t\tcnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tret += cnt;</span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;总计:&quot;</span>&lt;&lt; ret &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tListNode* ptr = <span class=\"built_in\">genList</span>(<span class=\"number\">1000</span>, <span class=\"number\">1000</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">parseList</span>(ptr, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// ptr = yourSort(ptr);</span></span><br><span class=\"line\">\t<span class=\"built_in\">parseList</span>(ptr, <span class=\"literal\">true</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","tags":["算法","递归","排序"]}]